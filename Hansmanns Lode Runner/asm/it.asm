; --------------------------------------------------------------------------------------------------------------------- ;
; Hansmans Lode Runner - it.prg
; --------------------------------------------------------------------------------------------------------------------- ;
; Memory Map
; --------------------------------------------------------------------------------------------------------------------- ;
; $0000 - $00ff:  Zero Page
; $0400 - $04f7:  Screen Multi Color
; $04f8 - $04ff:  Sprite Pointers
; $0800 - $09c3:  Buffer Expanded level data - in game modified with loderunner/enemies/holes
; $0a00 - $0bc3:  Buffer Expanded level data - original without loderunner/enemies/holes
; $0c00 - $0cff:  Buffer Sprite Data 01
; $0d00 - $0dff:  Buffer Sprite Data 02
; $0e00 - $0ec7:  Table  HiRes rows start address LO
; $0f00 - $0fc7:  Table  HiRes rows start address HI
; $1000 - $10ff:  Buffer Level Data Save/Load
; $1100 - $11ff:  Buffer High Score Save/Load
; $1200 - $12ff:  Game Work Tables
; $1300 - $133b:  Game Variables
; $1400 - $1fff:  Data Start Graphic
; $2000 - $3fff:  Screen Multicolor HiRes Display
; $4000 - $5fff:  Screen Multicolor HiRes Prepare
; --------------------------------------------------------------------------------------------------------------------- ;
; $6000 - $c1ff:  Game code
; --------------------------------------------------------------------------------------------------------------------- ;
; $c200 - $c2ff:  Buffer Tunes Play Time
; $c300 - $c3ff:  Buffer Tunes Data Ptr Voice 2
; $c400 - $c4ff:  Buffer Tunes Data Ptr Voice 3
; $c500 - $c5ff:  Buffer Tunes Sustain/Release/Volume (not used)
; $c600 - $c6ff:  Table  Image address table low  byte 
; $c700 - $c7ff:  Table  Image address table high byte
; $c800 - $c8ff:  Table  Enlarged hidden ladders - max $80 (128)
; $c900 - $c9ff:  Table  Random numbers for random level selection
; $ca00 - $caff:  Table  Save Games List
; --------------------------------------------------------------------------------------------------------------------- ;
; $cb00 - $cfff:  Buffer Area of Independent Buffers - $500 (640) bytes
; --------------------------------------------------------------------------------------------------------------------- ;
; $cb00 - $cfff:  Demo move recording (no overflow check - move $281 starts to overwrite the i/o area - crashes the game)
; $cb00 - $cbff:  Swap two disk levels
; $cb00 - $cbff:  Non selected level numbers for random table number generation
; $cb00 - $cbff:  Leaderboard update
; $cc00 - $ccff:  Leaderboard update result
; --------------------------------------------------------------------------------------------------------------------- ;
                            * = $6000
; --------------------------------------------------------------------------------------------------------------------- ;
; compiler settings
; --------------------------------------------------------------------------------------------------------------------- ;
                            .cpu "6502"                     ; standard 65xx processor
                            
Mem                         .include "../../inc/c64.MEM.asm" ; C64 Memory layout (includes found via -I cmd line option)
; --------------------------------------------------------------------------------------------------------------------- ;
Var                         .include "../inc/HL_Var.asm"    ; Game Variables
ZPG                         .include "../inc/HL_Zpg.asm"    ; Game Zero Page Equates
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Start                     Does    : entry point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Start                      .block                           ; 
                            lda #HL_Volume_Off              ; get initial value
                            sta HL_Volume                   ; set volume off
;                            
                            jsr StartInitMachine            ; set up the machine
; --------------------------------------------------------------------------------------------------------------------- ;
; read in score block and validate LR disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read flag with force score processing               .hbu001.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize the level times buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_TimerBuf_BlockNum_01    ; get times disk block number 01 (253)                      .hbu037.
                            lda #HL_DiskRead | HL_DiskForce_Times ; get flag read with force times processing           .hbu037.
                            jsr TimerDiskHandler            ; read or write the times block for the disk level number   .hbu037.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColdStart                 Does    : restart the game in case of disk errors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColdStart                  .block                           ; 
                            lda #$ff                        ; get initial value
                            sta HL_Volume                   ; ini volume
                            sta HL_LodeRuFallsDown          ; ini $00=fall $20=no fall $ff=init
;                           sta HL_TuneDeath                ; <obsolete> here - overwritten in next ini block           .hbu001.
                            sta HL_LodeRuShootMode          ; ini HL_LodeRuShootMode_Front
                            
                            lda #$00                        ; get init value
                            sta HL_TuneFreeBufferPosOff     ; ini offset to next free tune buffer byte
                            sta HL_TuneToPlayOff            ; ini offset to next tune to play
                            sta HL_LodeRuShoot              ; ini HL_LodeRuShoot_No
                            sta HL_TuneDeath                ; ini HL_TuneDeath_None
                            sta HL_KeyNew                   ; ini new key input
                            sta HL_KeyOld                   ; ini pressed key store
                            sta HL_SpriteShow               ; ini HL_SpriteShow_On
                            sta HL_ModeMirror               ; ini HL_ModeMirror_Off                                     .hbu018.
                            sta HL_ModeRnd                  ; ini HL_ModeRnd_Off                                        .hbu021.
                            sta HL_ModeDebugUsed            ; ini HL_ModeDebugUsed_Off                                  .hbu022.
                            
                            jsr GameDemoMoveToggleRec       ; switch off demo recording and replay                      .hbu034.
                            
                            lda #$01                        ;                                                           .hbu001.
                            sta HL_Cheated                  ; ini HL_Cheated_No                                         .hbu001.
                            
                            lda #>HL_LevelDataBuf           ; get address buffer packed level data page from disk HI
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; ini ReadDiskData command
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; ini WriteDiskData command
                            sta HL_GoldJingleRndSeed        ; ini RND beam pos seed
                            
                            lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            sta HL_KeyOld                   ; ini pressed key store
                            
                            lda #LSTX_NONE                  ; get ini value - no key pressed
                            sta LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            
                            lda #HL_GameSpeed_Normal        ; get wait cout of 5 interupts before next move (normal speed)
                            sta HL_GameSpeed                ; ini normal speed 
                            
                            lda #HL_ControllerType_Joystick ; get controller typ joystick
                            sta HL_ControllerType           ; ini controller typ joystick
                            
                            lda #HL_GameMode_Start          ; get flag show start grafic
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit
                            
                            lda #$03                        ; get long wait time                                        .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.

                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStart                 Does    : start a new game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStart                  .block                           ; 
                            lda #$00                        ; get ini value
                            sta HL_Score_Lo                 ; ini scores
                            sta HL_Score_Mid_Lo             ; 
                            sta HL_Score_Mid_Hi             ; 
                            sta HL_Score_Hi                 ; 
                            sta HL_GameSpeedCtrl            ; ini game speed
                            sta HL_EnemyBirthCol            ; ini HL_EnemyBirthCol_Min
                            
                            sta HL_LevelTest                ; switch off level test mode                                .hbu019.
                            sta HL_ModeXmit                 ; ini XmitLevelMode_Off                                     .hbu099.
                            sta HL_XmitLevelNum             ; ini xmit level number                                     .hbu099.
                            sta HL_ModeDebug                ; ini HL_ModeDebug_Off                                      .hbu022.
                            sta HL_LastLevelPassed          ; ini HL_LastLevelPassed_No                                 .hbu041.
                            
                            ldx HL_DemoRecReplay            ; get flag demo move replay mode                            .hbu034.
                            bmi SetForceReload              ; check: HL_DemoRecReplay_Yes - yes: keep border color      .hbu034.
                            
                            sta EXTCOL                      ; VIC($D020) Border Color - revert a possible Debug color   .hbu022.
                            
;                           sta HLZ_DemoMoveDuration        ; ini demo move duration                                    .hbu003. removed
;                           sta HLZ_DemoMoveDataPtr_Lo      ; ini demo move data pointer LO                             .hbu003. removed
                            
;                           lda #>TabDemoMoves              ; ini demo move data pointer LO                             .hbu003. removed
;                           sta HLZ_DemoMoveDataPtr_Hi      ; ini DemoMoveData pointer                                  .hbu003. removed
                            
SetForceReload              lda #HL_LevelReload_Force       ; get flag force level reload
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk
                            
                            lda #HL_NumLivesInit            ; get initial value
                            sta HL_NumLives                 ; ini number of lives
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen
                            sta HLZ_TargetGfxOutput         ; ini target output indicator $20=$2000 $40=$4000
                            
                            jsr JingleGotAllGoldInit        ; init the jingle control data
                            jsr ScreenClearBoth             ; clear the display and prepare screen hires screens
                            
;                           lda #HR_CYAN_RED                ; get hires color                                           .hbu006. removed
                            jsr ColorLevelSelect            ; select a new color combination every 10th level           .hbu006.
                            
;                           lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu006.hbu032. removed
;                           ora #SCROLX_MCM_ON              ; switch on Multi Color Mode (MCM)                          .hbu006.hbu032. removed
;                           sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu006.hbu032. removed
                            
                            jsr ColorStatus                 ; fill the status row with the selected colors              .hbu006.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelStart                Does    : start a new level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelStart                 .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_OutToScreenPrep_No      ; get flag no copy data to prepare hires screen
                            jsr GameLevelDataExpand         ; expand compressed level disk data
                            
                            sta HL_TuneToPlayOff            ; ini offset tune to play
                            sta HL_TuneFreeBufferPosOff     ; ini offset next free tune buffer byte
                            
                            ldy HL_EnemyCount               ; get number of enemies ($00-$05)
                            lda TabEnemySpriteNum,y         ; get loderunner/enemy sprite enablement value
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda #HL_JoystickMoveDir_None    ; get initial value
                            sta HL_JoystickMoveDirY         ; ini joystick dir Y
                            sta HL_JoystickMoveDirX         ; ini joystick dir X
; --------------------------------------------------------------------------------------------------------------------- ;
; save level start scores - will be reset if level is not finished successfully
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_Score_Lo                 ;                                                           .hbu031.
                            sta HL_ScoreOld_Lo              ;                                                           .hbu031.
                            lda HL_Score_Mid_Lo             ;                                                           .hbu031.
                            sta HL_ScoreOld_Mid_Lo          ;                                                           .hbu031.
                            lda HL_Score_Mid_Hi             ;                                                           .hbu031.
                            sta HL_ScoreOld_Mid_Hi          ;                                                           .hbu031.
                            lda HL_Score_Hi                 ;                                                           .hbu031.
                            sta HL_ScoreOld_Hi              ;                                                           .hbu031.
; --------------------------------------------------------------------------------------------------------------------- ;
; no best times display and loderunner sprite flicker in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit
                            lsr a                           ; shift out mode flag
                            beq MainLoopInit                ; check: demo - yes: bypass time display and flicker
; --------------------------------------------------------------------------------------------------------------------- ;
; no best times display in test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelTest                ; flag: level testmode on/off                               .hbu038.
                            bmi WaitGetNextLodeRuShadeIni   ; check: HL_LevelTest_On - yes: bypass time display         .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; try to display a possible best level time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPENA                       ; get VIC($D015) Sprite Enable Register value               .hbu038.
                            pha                             ; save VIC($D015) Sprite Enable Register value              .hbu038.
                            
                            lda #HR_CYAN_LT_GREY            ; get standard level time color                             .hbu038.
                            sta HL_ColorTimerMsg            ; set standard level time color                             .hbu038.
                            
                            jsr TimerShowRecordHandler      ; look for and display a possible level best time           .hbu038.
                            
                            pla                             ; get VIC($D015) Sprite Enable Register value               .hbu038.
                            sta SPENA                       ; restore VIC($D015) Sprite Enable Register value           .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player key - slowly flicker loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
WaitGetNextLodeRuShadeIni   ldy #TabLodeRuWaitShade_Len - $01 ; wait color tab pointer - $09 for a complete cycle       .hbu013.
WaitGetNextLodeRuShade      lda TabLodeRuWaitShade,y        ;                                                           .hbu013.
                            sta SP0COL                      ; VIC 2 - $D027 = Color Sprite 0                            .hbu013.
                            
                            sty HL_LodeRuShadeTabOff        ; save loderunner flicker color table offset                .hbu013.
                            
                            ldx #$00                        ; get waittime LO                                           .hbu013.
                            ldy #$05                        ; get waittime HI                                           .hbu013.
WaitNextLodeRuPlayerInput   jsr PlayerCheckInput            ; look for player input                                     .hbu013.
                            bcs ForceLodeRuBackToWhite      ; check: playes pressed key/fire - yes: exit                .hbu013.
; --------------------------------------------------------------------------------------------------------------------- ;
; dec wait counter
; --------------------------------------------------------------------------------------------------------------------- ;
                            dex                             ; wait                                                      .hbu013.
                            bne WaitNextLodeRuPlayerInput   ;                                                           .hbu013.
                            dey                             ; wait                                                      .hbu013.
                            bne WaitNextLodeRuPlayerInput   ;                                                           .hbu013.
; --------------------------------------------------------------------------------------------------------------------- ;
; phase wait time expired - dim player sprite from black to white and vice versa
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_LodeRuShadeTabOff        ; get actual loderunner flicker color table offset          .hbu013.
                            dey                             ; set next position                                         .hbu013.
                            bpl WaitGetNextLodeRuShade      ; check: min - no: next step                                .hbu013.
                            bmi WaitGetNextLodeRuShadeIni   ; always - restart color counter                            .hbu013.
; --------------------------------------------------------------------------------------------------------------------- ;
; end of wait - switch on a possibly switched off loderunner sprite
; --------------------------------------------------------------------------------------------------------------------- ;
ForceLodeRuBackToWhite      lda #WHITE                      ;                                                           .hbu013.
                            sta SP0COL                      ; VIC 2 - $D027 = Color Sprite 0                            .hbu013.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset a possible best time message
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr StatusMsgTextReset          ; reset status line / display new num of lives              .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; test demo recording request
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_KeyNew                   ;                                                           .hbu034.
                            cmp #$92                        ; test D - toggle demo recording mode                       .hbu034.
                            bne ChkCmdSaveGame              ; check: EQ - no: no demo recording status change           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; enable demo recording
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DemoRec                  ; get flag demo move recording mode                         .hbu034.
                            eor #HL_DemoRec_On              ; toggle flag demo move recording mode                      .hbu034.
                            jsr GameDemoMoveToggleRec       ; (de)activeate demo move recording mode                    .hbu034.
                            jmp WaitGetNextLodeRuShadeIni   ;                                                           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; test save game request - a game can only be saved at level start to avoid saving a life
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCmdSaveGame              cmp #$8d                        ; test S - save game command                                .hbu028.
                            bne MainLoopInit                ; check: EQ - no: no save                                   .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; no save game in test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu028.
                            bmi MainLoopInit                ; check: HL_LevelTest_On - yes: no saves                    .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; no save game after cheating
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_Cheated                  ; get flag: cheated                                         .hbu028.
                            beq MainLoopInit                ; check: HL_Cheated_Yes - yes: no saves                     .hbu028.

                            jmp GameStorageStart            ; save a game only at level start                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoopInit              Does    : game main loop preparations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoopInit               .block                           ; 
                            ldx #HL_LodeRuShoot_No          ; get initial value
                            stx HL_LodeRuShoot              ; ini loderunner does not shoot - $00=no $01=right $ff=left
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate offset into enemy move dispatch table
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameSpeedCtrl            ; get game speed control value ($00-$0a)
                            clc                             ; 
                            adc HL_EnemyCount               ; add number of enemies ($00-$05)
                            tay                             ; set enemy cycle tab offset
; --------------------------------------------------------------------------------------------------------------------- ;
; fill enemy move control table - used in EnemyMoveHandler
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabEnemyMoveCyclesOff,y     ; get offsets enemy move cycles tab
                            lda TabEnemyMoveCycle_01,x      ; get enemy move cycles tab value 1
                            sta HLZ_EnemyMoveCycle_01       ; set tab value 1 
                            
                            lda TabEnemyMoveCycle_02,x      ; get enemy move cycles tab value 2
                            sta HLZ_EnemyMoveCycle_02       ; set tab value 2
                            
                            lda TabEnemyMoveCycle_03,x      ; get enemy move cycles tab value 3
                            sta HLZ_EnemyMoveCycle_03       ; set tab calue 3
                            
                            ldy HL_GameSpeedCtrl            ; get lap counter for speed up ($00-$0a)
                            lda TabEnemyInHoleTime,y        ; get time in hole tab
                            sta HL_EnemyInHoleTime          ; set enemy in hole time
                            
                            jsr TimerInit                   ; init the level timer                                      .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoop                  Does    : game main loop
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop                   .block                           ; 
                            jsr LodeRuMoveHandler           ; control loderunner moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has survived his last move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LodeRuState              ; get loderunner heartbeat
                            bne MainLoop_CheckLrGold        ; check: HL_LodeRuState_Alive - had an accident - no        .hbu004.
                            
                            jmp LodeRuDeath                 ; loderunner had an deathly accident                        .hbu004.
                            
MainLoop_CheckLrGold        lda HL_GoldToCollect            ; get gold to collect count
                            bne MainLoop_CheckLrRow         ; check: got all - no: some gold still left over
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner still alive and all gold collected
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr JingleGotAllGoldCopy        ; prepare the all gold collected jingle
                            jsr StatusMsgTextShow           ; display a possible success message                        .hbu009.
                            jsr LevelExitLadderShow         ; show possible exit ladders
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on top of the screen 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CheckLrRow         lda HLZ_LodeRuRow               ; get actual row loderunner
                            bne MainLoop_CloseHoles         ; check: loderunner on top row - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on mid of image 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner pos on image left/right
                            cmp #HLZ_LodeRuOnImgPosY_Mid    ; test center of screen image
                            bne MainLoop_CloseHoles         ; check: center of screen image - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; all gold must be collected - level completed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GoldToCollect            ; get number of gold to collect for this level
                            beq LevelComplete               ; check: got all gold - yes: level finished successfully
                            cmp #$ff                        ; test -1
                            beq LevelComplete               ; check: got all gold plus one - yes: level finished successfully
; --------------------------------------------------------------------------------------------------------------------- ;
; continue play
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CloseHoles         jsr GameCloseHoles              ; close open holes and eventually kill trapped loderunner and enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner survived the close hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LodeRuState              ; get loderunner heartbeat
                            bne MoveEnemies                 ; check: HL_LodeRuState_Alive - trapped in a hole - no      .hbu041.
                            
                            jmp LodeRuDeath                 ; loderunner was trapped in a hole                          .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; move next enemy - one by one
; --------------------------------------------------------------------------------------------------------------------- ;
MoveEnemies                 jsr EnemyMoveHandler            ; control all enemy moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LodeRuState              ; get loderunner heartbeat                                  .hbu022.
                            bne MainLoop_Delay              ; check: HL_LodeRuState_Alive - cought by an enemy - no     .hbu022.
                            
                            jmp LodeRuDeath                 ; death caused by an enemy                                  .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; check demo mode - do not wait then - let demo run with maximum speed
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu004.
;                           lsr a                           ; shift demo flag out                                       .hbu004.
;                           beq MainLoop                    ; check: demo - yes: no delay                               .hbu004.
; --------------------------------------------------------------------------------------------------------------------- ;
; normal game mode - wait a bit befor next main loop round
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_Delay              lda HL_CountIRQs                ; get wait counter (inc'd every IRQ)
                            cmp HL_GameSpeed                ; test with game speed
                            bcc MainLoop_Delay              ; check: lower - yes: wait
                                                              
                            lda #HL_CountIRQs_Init          ; get initial value
                            sta HL_CountIRQs                ; ini wait counter (inc'd every IRQ)
                                                              
                            jmp MainLoop                    ; continue the endless loop
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelComplete             Does    : prepare for next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelComplete              .block                           ; 
                            ldx HL_DemoRecReplay            ; get flag demo recording replay                            .hbu034.
                            beq CheckLevelRecordMode        ; check: HL_DemoRecReplay_No - yes: check record mode       .hbu034.
                            
                            ldx #$00                        ;                                                           .hbu034.
                            stx HLZ_RecordDemoMoveBufOff    ; reinit recording buffer offset                            .hbu034.

                            lda #>HL_BufDemoMoves           ; get buffer address Hi                                     .hbu034.
                            sta HLZ_DemoMoveBufferPtr_Hi    ; reinit buffer address Hi                                  .hbu034.
                            
                            jmp GameStart                   ; start game preparations
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelRecordMode        ldx HL_DemoRec                  ; get flag demo move recording mode                         .hbu034.
                            beq CheckLevelTestMode          ; check: HL_DemoRec_Off - yes: normal end processing        .hbu034.
                            
                            jmp GameDemoMoveInitReplay      ; end the demo move recording mode and init the replay      .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelTestMode          ldx HL_LevelTest                ; get flag: test level mode                                 .hbu019.
                            beq OutLevelCompleteMsg         ; check: HL_LevelTest_Off - yes: display time used          .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; test mode - simply return to editor
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp IGC_LevelTestQuit           ; no level completion handling necessary in test mode       .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
OutLevelCompleteMsg         jsr TimerMsgOut                 ; announce the level exit time                              .hbu011.
                            jsr GameLevelNumIncHandler      ; get next level number                                     .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; finish the actual game tune
; --------------------------------------------------------------------------------------------------------------------- ;
WaitTuneFinished            lda HL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp HL_TuneToPlayOff            ; test still playing
                            bne WaitTuneFinished            ; check: tune still playing - yes: continue wait
                            
                            jsr JingleGotAllGoldNext        ; set the next level completed jingle
; --------------------------------------------------------------------------------------------------------------------- ;
; increase loderunner number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_NumLives                 ; 
                            bne ScoreTuneIni                ; check: maximum - no: bypass adaptation
                            
                            dec HL_NumLives                 ; ensure a max of $ff (255)
; --------------------------------------------------------------------------------------------------------------------- ;
; init level end scoring tune - each dec of HLZ_SfxScoreSub scores 100 points
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneIni                lda #HLZ_SfxScoreSub_Start      ; get init score tune subtraction value
                            sta HLZ_SfxScoreSub             ; set substraction value
                            
                            sei                             ; disallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; increase score whilst the scoring tune gets higher and higher
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneNext               lda #HLZ_SfxScoreSub_Base       ; get base tune value 
                            sec                             ; 
                            sbc HLZ_SfxScoreSub             ; 
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            ldy #$2c                        ; get wait time LO
ScoreWaitTuneGetNextHi      ldx #$00                        ; get wait time HI
ScoreWaitTuneDecNextLo      dex                             ; dec wait time LO
                            bne ScoreWaitTuneDecNextLo      ; check: min - no: continue
                            dey                             ; dec wait time HI
                            bne ScoreWaitTuneGetNextHi      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch tune off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; score next 100
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; $00 - score add value LO - each time tick scores 100 points
                            iny                             ; $01 - score add value HI
                            jsr StatusOutScore              ; score and update status row
; --------------------------------------------------------------------------------------------------------------------- ;
; dec until 1500 points are scored
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_SfxScoreSub             ; sub value - tune gets higher and higher
                            bpl ScoreTuneNext               ; check: underflow - no: continue
                            
                            cli                             ; reallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; check if last level was solved and congratulate then
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LastLevelPassed          ; get flag last level solved
                            beq StartNextLevel              ; check: HL_LastLevelPassed_No - yes: bypass congratulation .hbu041.
                            
                            jsr GameNewChampionHandler      ; be sure to congratulate                                   .hbu041.
                            
                            dec HL_LastLevelPassed          ; reset flag all 250 levels solved                          .hbu041.
                            
StartNextLevel              lda HL_ModeDebug                ; get flag debug mode                                       .hbu022.
                            bmi LevelCompleteX              ; check: debug mode switched on - yes: skip reset           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset flag debug mode used for the next level
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebugUsed            ; get flag debug mode used                                  .hbu022.
                            and #~HL_ModeDebugUsed_Level    ; reset flag debug mode was used for this level             .hbu022.
                            sta HL_ModeDebugUsed            ; set flag no debug mode used for this level                .hbu022.
                            
LevelCompleteX              jmp LevelStart                  ; start next level
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuDeath               Does    : discount loderunner lives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuDeath                .block                           ; 
                            ldx HL_DemoRecReplay            ; get flag demo recording replay                            .hbu034.
                            beq CheckLevelRecordingMode     ; check: HL_DemoRecReplay_No - yes: check record mode       .hbu034.
                            
                            jmp GameDemoMoveStopReplay      ; stop the recorded demo replay and return to game mode     .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelRecordingMode     ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            beq CheckLevelTestMode          ; check: HL_DemoRec_Off - yes: normal death processing      .hbu034.
                            
                            jmp GameDemoMoveInitReplay      ; end the demo move recording mode and init the replay      .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelTestMode          ldx HL_LevelTest                ; get flag level test mode                                  .hbu019.
                            bmi IniDeathJingle              ; check: HL_LevelTest_On - yes: do not discount lives       .hbu019.
                            
                            dec HL_NumLives                 ; discount number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
GetGameMode                 lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit
                            lsr a                           ; shift out mode flag 
                            bne StatusRowUpdate             ; check: demo - no: play death tune
                            
                            jmp DemoVolumeHandler           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
StatusRowUpdate             jsr StatusMsgTextReset          ; reset status line / display new num of lives              .hbu009.
                            
IniDeathJingle              lda #HL_TuneDeath_Ini           ; get initial value
                            sta HL_TuneDeath                ; ini death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; complete running jingles
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForGameTunesFinish      lda HL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp HL_TuneToPlayOff            ; test with tune to play offset
                            bne WaitForGameTunesFinish      ; check: finished - no: wait for all in game tunes to be finished
; --------------------------------------------------------------------------------------------------------------------- ;
; reset values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LodeRuShoot_No          ; get shoot off
                            sta HL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            lda #HL_LodeRuFallsDown_No      ; get flag no fall
                            sta HL_LodeRuFallsDown          ; set $00=fall $20=no fall $ff=init
; --------------------------------------------------------------------------------------------------------------------- ;
; complete funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForDeathTuneEnd         lda HL_TuneDeath                ; get death tune value
                            bne WaitForDeathTuneEnd         ; check: min - no: continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
; no score processing in test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_LevelTest                ; get flag level test mode                                  .hbu019.
                            bmi LodeRuDeathX                ; check: HL_LevelTest_On - yes: do not discount lives       .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore level start scores - loose all scores collected in this level so far
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebug                ; get flag debub mode                                       .hbu022.
                            bmi LodeRuCheckLives            ; check: HL_ModeDebug_On - yes: no score reset              .hbu022.
                            
                            lda HL_ScoreOld_Lo              ;                                                           .hbu031.
                            sta HL_Score_Lo                 ;                                                           .hbu031.
                            lda HL_ScoreOld_Mid_Lo          ;                                                           .hbu031.
                            sta HL_Score_Mid_Lo             ;                                                           .hbu031.
                            lda HL_ScoreOld_Mid_Hi          ;                                                           .hbu031.
                            sta HL_Score_Mid_Hi             ;                                                           .hbu031.
                            lda HL_ScoreOld_Hi              ;                                                           .hbu031.
                            sta HL_Score_Hi                 ;                                                           .hbu031.
; --------------------------------------------------------------------------------------------------------------------- ;
; add $00 - just do a score redisplay
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; ac=score  10s                                             .hbu031.
                            tay                             ; yr=score 100s                                             .hbu031.
                            jsr StatusOutScore              ; add zero - simply show new scores                         .hbu031.
; --------------------------------------------------------------------------------------------------------------------- ;
; check number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCheckLives            lda HL_NumLives                 ; get number of lives
                            beq GameOver                    ; check: all used up - yes                                  .hbu034.
                            
LodeRuDeathX                jmp LevelStart                  ; continue game with one live less
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOver                  Does    : spin game over sign and wait for game restart or demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOver                   .block                           ; 
                            ldx HL_DemoRecReplay            ; get flag demo recording replay                            .hbu034.
                            beq CheckLevelRecordingMode     ; check: HL_DemoRecReplay_No - yes: check record mode       .hbu034.
                            
                            jmp GameDemoMoveStopReplay      ; stop the recorded demo replay and return to game mode     .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelRecordingMode     ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            beq CheckLeaderboard            ; check: Demo recording off - yes: normal end processing    .hbu034.
                            
                            jsr GameDemoMoveInitReplay      ; end the demo move recording mode and init the replay      .hbu034.
                            jmp DemoGameInit                ; auto start the replay                                     .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLeaderboard            jsr ScoreEntryHandler           ; check if score reached is worth an entry on the leaderboard
                            jsr GameOverSpinSign            ; spin game over billboard
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoWaitInit              Does    : init wait time for demo start and player input
;                           Expects : .C=0 - force new key reset
;                                   : .C=1 - bypass new key reset
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoWaitInit               .block                           ;                                                           .hbu001.
                            ldx #$ff                        ; get wait time LO
;                           ldy #$ff                        ; get wait time MID                                         .hbu001. removed
                            ldy #$7f                        ; get wait time MID                                         .hbu001.
                            
                            bcs DemoWaitIniCounter_Hi       ; check: flag demo - yes: bypass key reset
; --------------------------------------------------------------------------------------------------------------------- ;
; reset player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_KeyNew_None             ; get initial value
                            sta HL_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; init wait counter HI
; --------------------------------------------------------------------------------------------------------------------- ;
smDemoWaitCounter_Hi        = * + $01                       ; enable variable wait time                                 .hbu001.
DemoWaitIniCounter_Hi       lda #$03                        ; get wait time HI
                            sta HLZ_WaitForDemoCounter      ; set wait time HI
                            
DemoWaitPlayerInput         lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check game start joystick
; --------------------------------------------------------------------------------------------------------------------- ;
;                           beq GameStartInit               ; check: fire button pressed - yes                          .hbu040. removed
                            bne GetInputKey_Special         ; check: fire button pressed - no: check keeyboard input    .hbu040.
                            
                            jmp GameStartInit               ; init game start                                           .hbu040.
; --------------------------------------------------------------------------------------------------------------------- ;
; check game start keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
GetInputKey_Special         lda HL_KeyNew                   ; get key pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check 'E' - editor start
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$8e                        ; test "E" to start editor
                            bne CheckShowLeaderboard        ; check: EQ - no: check <ENTER> to show leaderboard
                            
                            jsr IRQ_GameSet                 ; switch back to game IRQ                                   .hbu032.
                            jmp BED_Start                   ; start the Loderunner Board Editor
; --------------------------------------------------------------------------------------------------------------------- ;
; check <ENTER> - show leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
CheckShowLeaderboard        cmp #$01                        ; test <ENTER>
                            bne GetInputKey_Other           ; check: EQ - no: check other keyboard input                .hbu040.
;                           beq DemoHighScoreHandler.GoScoreShowLeaderboard ; check: EQ - yes: show leaderboard         .hbu040. removed
                            
                            lda HL_ScoreShown               ; get flag highscores display active                        .hbu040.
                            bne GetInputKey_Other           ; check: HL_ScoreShown_Yes - yes: skip display              .hbu040.
                            
                            jmp DemoHighScoreHandler.GoScoreShowLeaderboard ; show leaderboard                          .hbu040.
; --------------------------------------------------------------------------------------------------------------------- ;
; check other keys
; --------------------------------------------------------------------------------------------------------------------- ;
GetInputKey_Other           lda HL_KeyNew                   ; get player key
                            bne GameStartInit               ; check: player key - yes: start game
; --------------------------------------------------------------------------------------------------------------------- ;
; continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
                            dex                             ; count down wait time LO
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dey                             ; count down wait time MID
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dec HLZ_WaitForDemoCounter      ; count down wait time HI
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
; --------------------------------------------------------------------------------------------------------------------- ;
; wait time is over without any player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit
                            bne DemoHighScoreHandler        ; check: start screen - no: show high scores
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoGameInit              Does    : init start of demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoGameInit               .block                           ;                                                           .hbu034.
                            ldx #$01                        ; get initial value
                            stx HL_GameMode                 ; ini game mode - $01=demo
                            stx HL_LevelNumGame             ; ini game level number (001-250)
;                           stx HLZ_DemoNoFunction          ; ini flag - used but has no function                       .hbu001. removed
                            stx HL_Cheated                  ; ini HL_Cheated_No
                            
;                           ldx HL_Volume                   ; get volume                                                .hbu005. removed
;                           stx DemoVolumeHandler.smSetVolume ; set game volume                                         .hbu005. removed
                            
                            lda #$00                        ; get demo volume off
;                           sta HL_Volume                   ; set demo volume off                                       .hbu005. removed
                            sta HL_LevelNumDisk             ; set disk level num (000-249)  - 1st demo level
                            
                            jsr IRQ_GameSet                 ; switch back to game IRQ                                   .hbu032.
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoVolumeHandler         Does    : control game volume
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoVolumeHandler          .block                           ; 
;smSetVolume                = * + $01                       ;                                                           .hbu005. removed
;                           lda #HL_Volume_Off              ; get modified game volume                                  .hbu005. removed
;                           sta HL_Volume                   ; set game volume                                           .hbu005. removed
                            
                            lda #HL_TuneDeath_Ini           ; get initial value                                         .hbu005.
                            sta HL_TuneDeath                ; ini death tune                                            .hbu005.
                            
                            lda #$02                        ; get short wait time                                       .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.
                            
                            clc                             ; force new key reset                                       .hbu001.
                            jmp DemoWaitInit                ; init wait for demo                                        .hbu005.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHighScoreHandler      Does    : show the leaderboard of ten entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHighScoreHandler       .block                           ; 
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            beq CheckGameDemoMode           ; check: Demo recording off - yes: normal end processing    .hbu034.
                            
                            jmp DemoGameInit                ; init game demo
; --------------------------------------------------------------------------------------------------------------------- ;
CheckGameDemoMode           cmp #HL_GameMode_Demo           ; test demo mode
                            bne DemoShowStartGraphic        ; check: was demo - no: show start graphic screen
; --------------------------------------------------------------------------------------------------------------------- ;
; show leaderboard after the demo
; --------------------------------------------------------------------------------------------------------------------- ;
GoScoreShowLeaderboard      jsr IRQ_GameSet                 ; switch back to game IRQ                                   .hbu032.
                            jsr ScoreShowLeaderboard        ; show leaderboard
                            
                            lda #HL_GameMode_Play           ; get play mode
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit
                            
                            lda #HL_ScoreShown_Yes          ; get flag leaderboard displa active                        .hbu040.
                            sta HL_ScoreShown               ; set flag: scores already displayed                        .hbu040.
                            
                            lda #$03                        ; get long wait time                                        .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.
                            
                            clc                             ; force new key reset
                            jmp DemoWaitInit                ; init wait for demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoShowStartGraphic        lda #$00                        ; get initial value
                            sta HL_LevelNumDisk             ; set disk level num (000-249) 
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit
                            
                            lda #$02                        ; get mid wait time                                         .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.
                            
                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStartInit             Does    : initialize game (re)start values
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStartInit              .block                           ; 
                            jsr IRQ_GameSet                 ; switch back to game IRQ                                   .hbu032.
                            
                            lda #HL_LevelNumDisk_Min        ; get initial value                                         .hbu001.
                            sta HL_LevelNumDisk             ; ini disk level num (000-249)                              .hbu001.
                            
                            lda #HL_LevelNumGame_Min        ; get initial value                                         .hbu001.
                            sta HL_LevelNumGame             ; set game level num (001-250)                              .hbu001.
                            
                            lda #HL_Cheated_No              ; get initial value                                         .hbu001.
                            sta HL_Cheated                  ; not cheating until now                                    .hbu001.
                            
                            lda #HL_ModeDebugUsed_No        ; get initial value                                         .hbu022.
                            sta HL_ModeDebugUsed            ; set flag not debbugged until now                          .hbu022.
                            
                            lda #HL_ModeRnd_Off             ; get intial value                                          .hbu021.
                            sta HL_ModeRnd                  ; ini HL_ModeRnd_Off                                        .hbu021.
                            
                            lda #HL_ModeMirror_Off          ; get intial value                                          .hbu018.
                            sta HL_ModeMirror               ; ini HL_ModeMirror_Off                                     .hbu018.
                            
                            lda #HL_GameMode_Play           ; get play mode
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit
                            
                            lda #HL_Volume_Max              ; get switch on volume again
                            sta HL_Volume                   ; set volume
                            
                            lda #HL_KeyNew_None             ;                                                           .hbu001.
                            sta HL_KeyNew                   ; avoid an immediate start                                  .hbu001.
                            sta HL_ScoreShown               ; ini HL_ScoreShown_No                                      .hbu001.
                            
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesOff       = * ; 
                            .byte TabEnemyMoveCyclesBlock_00 - TabEnemyMoveCycles ; 00 - $00
                            .byte TabEnemyMoveCyclesBlock_01 - TabEnemyMoveCycles ; 01 - $03
                            .byte TabEnemyMoveCyclesBlock_02 - TabEnemyMoveCycles ; 02 - $06
                            .byte TabEnemyMoveCyclesBlock_03 - TabEnemyMoveCycles ; 03 - $09
                            .byte TabEnemyMoveCyclesBlock_04 - TabEnemyMoveCycles ; 04 - $0c
                            .byte TabEnemyMoveCyclesBlock_05 - TabEnemyMoveCycles ; 05 - $0f
                            .byte TabEnemyMoveCyclesBlock_06 - TabEnemyMoveCycles ; 06 - $12
                            .byte TabEnemyMoveCyclesBlock_07 - TabEnemyMoveCycles ; 07 - $15
                            .byte TabEnemyMoveCyclesBlock_08 - TabEnemyMoveCycles ; 08 - $18
                            .byte TabEnemyMoveCyclesBlock_09 - TabEnemyMoveCycles ; 09 - $1b
                            .byte TabEnemyMoveCyclesBlock_0a - TabEnemyMoveCycles ; 0a - $1e
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyInHoleTime          = *       ; 
                            .byte $26 ; $00
                            .byte $26 ; $01
                            .byte $2e ; $02
                            .byte $44 ; $03
                            .byte $47 ; $04
                            .byte $49 ; $05
                            .byte $4a ; $06
                            .byte $4b ; $07
                            .byte $4c ; $08
                            .byte $4d ; $09
                            .byte $4e ; $0a
                            .byte $4f ; $0b
                            .byte $50 ; $0c
                            .byte $51 ; $0d
                            .byte $52 ; $0e
                            .byte $53 ; $0f
                            .byte $54 ; $10
                            .byte $55 ; $11
                            .byte $56 ; $12
                            .byte $57 ; $13
                            .byte $58 ; $14
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusMsgTextShow         Does    : print a victory message in the message area of the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusMsgTextShow          .block                           ; 
                            jsr LED_CursorPosSave           ; save actual edit cursr position                           .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; check the correct message identifier
; --------------------------------------------------------------------------------------------------------------------- .hbu009.
                            ldy #HL_LevelDataBufMsgID_Len   ; message id length                                         .hbu009.
CheckNextMsgIdByte          lda HL_LevelDataBufMsgID - $01,y; compare with message identifier                           .hbu009.
                            cmp TabLevelMsgId,y             ; LODERUNNEr                                                .hbu009.
                            bne IniDefaultMsg               ; check: EQ - no: no valid message identifier found
                            
                            dey                             ; dec message id length                                     .hbu009.
                            bpl CheckNextMsgIdByte          ; check: min - no: continue                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; message identifier valid - copy and check for a blank msg text
; --------------------------------------------------------------------------------------------------------------------- ;
IniCopyGameMsgTxt           lda #$00                        ; get initial value                                         .hbu009.
                            sta HLZ_WorkMsgBufferCheck      ; ini blank msg indicator                                   .hbu009.
                            
                            ldy #HL_LevelDataBufMsgTxt_Len - $01 ; get buffer length                                    .hbu009.
GetNextMsgTxtChar           lda HL_LevelDataBufMsgTxt,y     ; get the message                                           .hbu009.
                            sta TabLevelMsgBufferEdit,y     ; copy msg string for edit mode                             .hbu009.
                            sta TabLevelMsgBuffer,y         ; copy msg string                                           .hbu009.
                            sta HL_InputBuffer,y            ; prepare the input buffer for a possible edit              .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; set up message text check byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor #" " | $80                  ; <SHIFT_SPACE>                                             .hbu009.
                            ora HLZ_WorkMsgBufferCheck      ;                                                           .hbu009.
                            sta HLZ_WorkMsgBufferCheck      ; save text bit pattern                                     .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; dec buffer length                                         .hbu009.
                            bpl GetNextMsgTxtChar           ; check: min - no: continue                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; check for blank message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_WorkMsgBufferCheck      ; get msg text check byte                                   .hbu009.
                            bne IniMsgOut                   ; check: empty msg - no: display the level msg text         .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; no message id or a blank message text found - set the default message text
; --------------------------------------------------------------------------------------------------------------------- ;
IniDefaultMsg               ldy #HL_LevelDataBufMsgTxt_Len - $01 ; get buffer length                                    .hbu009.
SetNextDefaultMsgByte       lda TabLevelMsgDefault,y        ; get a default msg text byte                               .hbu009.
                            sta TabLevelMsgBufferEdit,y     ; copy msg string for edit mode                             .hbu009.
                            sta TabLevelMsgBuffer,y         ; init the message buffer                                   .hbu009.
                            sta HL_InputBuffer,y            ; init the input buffer                                     .hbu009.
                            
                            dey                             ; dec buffer length                                         .hbu009.
                            bpl SetNextDefaultMsgByte       ; check: min - no: continue                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
IniMsgOut                   lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu009.
                            sta HLZ_TargetGfxOutput         ; output to display screen only                             .hbu009.
                            
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu009.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelMsgBuffer            = *                            ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            
                            .byte $00 ; EndOfText           ;                                                           .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
GetLevelMsgColor            lda HL_ColorStatusMsg           ; preset game message color                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in edit mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu009.
                            cpx #HL_GameMode_Edit           ; test edit mode                                            .hbu009.
                            bne StatusMsgTextShowX          ; check: edit mode - no: exit                               .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; in edit mode the prepare screen needs to have the mesage too
; --------------------------------------------------------------------------------------------------------------------- ;
MsgOutToPrep                lda #>HL_ScreenGfxPrepare       ; get prepare display screen                                .hbu009.
                            sta HLZ_TargetGfxOutput         ; output to prepare screen only                             .hbu009.
                            
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu009.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelMsgBufferEdit        = *                            ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            
                            .byte $00 ; EndOfText           ;                                                           .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; in edit mode set fix message color to yellow
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosRestore        ; restore old edit cursor position                          .hbu009.
                            
                            lda #HR_YELLOW_YELLOW           ;                                                           .hbu009.
                            
StatusMsgTextShowX          jmp StatusMsgTextColor          ;                                                           .hbu009.
                           .bend                            ;                                                           .hbu009.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelMsgId                = *                            ;                                                           .hbu009. 
                            .byte $00                       ;                                                           .hbu009.
                            .byte $00                       ;                                                           .hbu009.
                            .byte $00                       ;                                                           .hbu009.
                            
                            .byte "l" | $80 ;               ; LODE RUNNEr                                               .hbu009.
                            .byte "o" | $80 ;               ;                                                           .hbu009.
                            .byte "d" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "r" | $80 ;               ;                                                           .hbu009.
                            .byte "u" | $80 ;               ;                                                           .hbu009.
                            .byte "n" | $80 ;               ;                                                           .hbu009.
                            .byte "n" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "r"       ;               ;                                                           .hbu009.
TabLevelMsgId_Len           = * - TabLevelMsgId - $01 ;                                                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelMsgDefault           = *                            ;                                                           .hbu009.
                            .byte "l" | $80 ; <SHIFT_SPACE> ; LEVEL  COMPLETE                                           .hbu009.
                            .byte "e" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "v" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "e" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "l" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "c" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "o" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "m" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "p" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "l" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "e" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "t" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "e" | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusMsgTextReset        Does    : reset victory message on death or update number of lives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusMsgTextReset         .block                           ; 
                            lda HL_ScreenMC_MsgColor - $01  ; get status line fix part color                            .hbu009.
                            cmp HL_ScreenMC_MsgColor        ; test with status line msg part color                      .hbu009.
                            bne ClearBaseMsg                ;                                                           .hbu009.
                                                                                                                        
                            jmp StatusOutLives              ; simply update no of lives                                 .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
ClearBaseMsg                jsr GameLevelClearMsgOutArea    ; clear the message area                                    .hbu009.
                            
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu009.
                            jmp StatusOutMenLevel           ;                                                           .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerMsgOutX              Does    : timer message error exit
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerMsgOutX               .block                           ;                                                           .hbu011.
                            rts                             ;                                                           .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerMsgOut               Does    : print the level time used in the message area of the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerMsgOut                .block                           ;                                                           .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; do not print times in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu011.
                            lsr a                           ; shift out demo flag                                       .hbu011.
                            beq TimerMsgOutX                ; check: was demo - yes: exit                               .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; no times after debug mode was used
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebugUsed            ; get flag debug mode used                                  .hbu011.
                            and #HL_ModeDebugUsed_Level     ; isolate flag debug mode was used for this level           .hbu011.
                            bne TimerMsgOutX                ; check: HL_ModeDebugUsed_Level - yes: exit                 .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; print level time
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TimerGetValues              ; fill in the elapsed timer values into the info message    .hbu011.
                            
                            lda #HL_DiskRead                ; get flag read                                             .hbu011.
                            jsr TimerDiskHandler            ; read or write the times block for the disk level number   .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; care for a possible new record time
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TimerCheckNewRecord         ; check and eventually set a new level record time          .hbu038.
                            pha                             ; save the level time message color                         .hbu038.
                            
                            jsr GameLevelClearMsgOutArea    ; clear the message area                                    .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; print time used message                                                                                               .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
SetCursor                   jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu011.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu011.
                            .byte "t" | $80 ;               ;  TIME<                                                    .hbu011.
                            .byte "i" | $80 ;               ;                                                           .hbu011.
                            .byte "m" | $80 ;               ;                                                           .hbu011.
                            .byte "e" | $80 ;               ;                                                           .hbu011.
                            .byte "<" | $80 ;               ;                                                           .hbu011.
                             
                            .byte $00 ; EndOfText           ;                                                           .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the timer values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_Timer_BCD_Mins           ;                                                           .hbu011.
                            jsr StatusOutDigitBCD           ;                                                           .hbu011.
                            
                            lda #":" | $80                  ; :                                                         .hbu011.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu011.
                            
                            lda HL_Timer_BCD_Secs           ;                                                           .hbu011.
                            jsr StatusOutDigitBCD           ;                                                           .hbu011.
                            
                            lda #"." | $80                  ; .                                                         .hbu011.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu011.
                            
                            lda HL_Timer_BCD_10th           ;                                                           .hbu011.
                            jsr StatusOutDigitBCD           ;                                                           .hbu011.

                            lda #">" | $80                  ; >                                                         .hbu011.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; set fix timer colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore the level time message color                      .hbu038.
                            jmp TimerMsgColor               ; set the fix timer message color for all levels            .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerRecordOut            Does    : print the level record time in the message area of the status row
;                           Expects : .A=offset level number entry in timer block
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerRecordOut             .block                           ; 
                            sta HL_Timer_LevelBlockOff      ; save offset level number entry in timer block             .hbu038.
                            
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu038.
                            lsr a                           ; shift out demo flag                                       .hbu038.
                            bne ClearMsgArea                ; check: was demo - no                                      .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; do not print best times in demo mode                                                                                  .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; no best times in demo mode                                .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
ClearMsgArea                jsr GameLevelClearMsgOutArea    ; clear the message area                                    .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; print time used message                                                                                               .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
SetCursor                   jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu038.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu038.
                            .byte "b" | $80 ;               ;   BEST<                                                   .hbu038.
                            .byte "e" | $80 ;               ;                                                           .hbu038.
                            .byte "s" | $80 ;               ;                                                           .hbu038.
                            .byte "t" | $80 ;               ;                                                           .hbu038.
                            .byte "<" | $80 ;               ;                                                           .hbu038.
                             
                            .byte $00 ; EndOfText           ;                                                           .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the timer values
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_Timer_LevelBlockOff      ; restore offset level number entry in timer block          .hbu038.
                            lda HL_TimerBuf + $00,y         ; get best mins                                             .hbu038.
                            jsr StatusOutDigitBCD           ;                                                           .hbu038.
                            
                            lda #":" | $80                  ; :                                                         .hbu038.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu038.
                            
                            ldy HL_Timer_LevelBlockOff      ; restore offset level number entry in timer block          .hbu038.
                            lda HL_TimerBuf + $01,y         ; get best secs                                             .hbu038.
                            jsr StatusOutDigitBCD           ;                                                           .hbu038.
                            
                            lda #"." | $80                  ; .                                                         .hbu038.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu038.
                            
                            ldy HL_Timer_LevelBlockOff      ; restore offset level number entry in timer block          .hbu038.
                            lda HL_TimerBuf + $02,y         ; get best 10th                                             .hbu038.
                            jsr StatusOutDigitBCD           ;                                                           .hbu038.

                            lda #">" | $80                  ; >                                                         .hbu038.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu038.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerMsgColor             Does    : set the fix timer message color for all levels
;                           Expects : .A=level time color
;                           Returns : 
; ` ------------------------------------------------------------------------------------------------------------------- ;
TimerMsgColor              .block                           ; 
                            lda HL_ColorTimerMsg            ; get level times message color                             .hbu038.
                            jmp StatusMsgTextColor          ; color the status line message area and return             .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerInit                 Does    : initialize the level timer
;                           Expects : 
;                           Returns : 
; ` ------------------------------------------------------------------------------------------------------------------- ;
TimerInit                  .block                           ; 
                            ldx #$00		                    ;                                                           .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; write to TODHRS --> ToD clock is automatically stopped
; --------------------------------------------------------------------------------------------------------------------- ;
                            stx TO2HR                       ; CIA2($DD0B) Time of Day Clock - ini Hours                 .hbu011.
                            stx TO2MIN                      ; CIA2($DD0A) Time of Day Clock - ini Minutes               .hbu011.
                            stx TO2SEC                      ; CIA2($DD09) Time of Day Clock - ini Seconds               .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; write to TO10TH - ToD clock is automatically started
; --------------------------------------------------------------------------------------------------------------------- ;
                            stx TO210TH                     ; CIA2($DD08) Time of Day Clock - ini Tenths                .hbu011.
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerGetValues            Does    : get in the elapsed timer values
;                           Expects : 
;                           Returns : 
;                           ID      : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerGetValues             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; read TODHR --> ToD clock is LATCHed - ToD continues to count - discard hours
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TO2HR                       ; CIA2($DD0B) Time of Day Clock Hours - LATCH ToD           .hbu011.
                            
                            ldx TO2MIN                      ; CIA2($DD0A) Time of Day Clock - get elapsed minutes       .hbu011.
                            stx HL_Timer_BCD_Mins           ;                                                           .hbu011.
                            
                            ldx TO2SEC                      ; CIA2($DD09) Time of Day Clock - get elapsed seconds       .hbu011.
                            stx HL_Timer_BCD_Secs           ;                                                           .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; get elapsed tenth of seconds - read TODTEN --> disable ToD registers LATCH
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TO210TH                     ; CIA2($DD08) Time of Day Clock Tenths - disable latch      .hbu011.
                            stx HL_Timer_BCD_10th           ;                                                           .hbu011.
                            
                            rts                             ;                                                           .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartGraficOut            Does    : color the start grafic hires screen
;                                   : expand the compressed start grafic
;                           Expects : 
;                           Returns : 
;                           Remark  : each data block has 2 bytes - 1st=length / 2nd=data
; --------------------------------------------------------------------------------------------------------------------- ;
StartGraficOut             .block                           ; 
;                           jsr ScreenDisplayClear          ; clear display grafic screen                               .hbu032. removed
                            
;                           jsr ColorLevel                  ; fill game level screen with the selected colors           .hbu032. removed
                            jsr IRQ_TitleSet                ; set title display IRQ                                     .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1)
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)      .hbu032. removed
;                           ora #SCROLY_BMM_ON              ; switch on Bitmap Mode (BMM)                               .hbu032. removed
;                           sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)      .hbu032. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; set charset location
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda VMCSB                       ; VIC($D018) VIC Chip Memory Control                        .hbu032. removed
;                           and #~(VMCSB_CB_MASK | %00000001) ; clear char set location part                            .hbu032. removed
;                           ora #VMCSB_CB_2000              ; chr generator to video base + $2000-$3fff                 .hbu032. removed
;                           sta VMCSB                       ; VIC($D018) VIC Chip Memory Control                        .hbu032. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; set start grafic hires colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$4f                        ; get color byte count                                      .hbu001.
SetNextMultiColorByte       lda #HR_LT_BLUE_BLACK           ;                                                           .hbu001.
                            sta HL_MemScreenMC + $0000,y    ; "Broderbund Software"                                     .hbu001.
                            sta HL_MemScreenMC + $0050,y    ;                                                           .hbu001.
                            sta HL_MemScreenMC + $00a0,y    ;                                                           .hbu001.
                            sta HL_MemScreenMC + $00f0,y    ;                                                           .hbu001.
                            
                            sta HL_MemScreenMC + $02f8,y    ; "Dough Smith, "                                           .hbu001.
                            
                            lda #HR_WHITE_BLACK             ;                                                           .hbu001.
                            sta HL_MemScreenMC + $0118,y    ; "Hansmanns"                                               .hbu001.
                            sta HL_MemScreenMC + $0168,y    ; "Lode Runner"                                             .hbu001.
                            sta HL_MemScreenMC + $0190,y    ;                                                           .hbu001.
                            sta HL_MemScreenMC + $01e0,y    ;                                                           .hbu001.
                            sta HL_MemScreenMC + $0230,y    ;                                                           .hbu001.
                            
                            lda #HR_RED_BLACK               ;                                                           .hbu001.
                            sta HL_MemScreenMC + $0280,y    ; "By"                                                      .hbu001.
                            sta HL_MemScreenMC + $02d0,y    ;                                                           .hbu001.
                            
                            lda #HR_LT_GREY_BLACK           ;                                                           .hbu001.
                            sta HL_MemScreenMC + $0348,y    ; "(C) 1983, 1982, 2007, 2024"                              .hbu001.
                            sta HL_MemScreenMC + $0398,y    ;                                                           .hbu001.
                            
                            dey                             ; dec color byte count                                      .hbu001.
                            bpl SetNextMultiColorByte       ; check: min - no: continue                                 .hbu001.
; --------------------------------------------------------------------------------------------------------------------- ;
; set Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1)
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032. removed
;                           and #SCROLX_MCM_OFF             ; Multi Color Mode (MCM) off                                .hbu032. removed
;                           sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; init start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<HL_StartGfxData           ; get start gfx in memory LO
                            sta HLZ_ScreenGfxPtr_Lo         ; set start gfx in ptr LO
                            lda #>HL_StartGfxData           ; get start gfx in memory HI
                            sta HLZ_ScreenGfxPtr_Hi         ; set start gfx in ptr HI
                            
                            lda #<HL_ScreenGfxDisplay - $01 ; get display screen address LO
                            sta HLZ_StartGfxDisplay_Lo      ; set start gfx output ptr LO
                            
                            lda #>HL_ScreenGfxDisplay - $01 ; get display screen address HI
                            sta HLZ_StartGfxDisplay_Hi      ; set start gfx output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextGfxDataInPair        ldy #$00                        ; get offset to gfx data byte count
                            lda (HLZ_ScreenGfxPtr),y        ; get gfx data byte count
                            sta HLZ_WorkStartGfxDataCount   ; set gfx data byte count
                            
                            iny                             ; set offset to gfx data byte
                            lda (HLZ_ScreenGfxPtr),y        ; get gfx data byte
                            sta HLZ_WorkStartGfxData        ; set gfx data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance gfx data pointer to next gfx data pair
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_ScreenGfxPtr_Lo         ; get grafic output ptr LO
                            clc                             ; 
                            adc #HL_StartGfxDataPtr_Len     ; add compressed data length
                            sta HLZ_ScreenGfxPtr_Lo         ; set grafic output ptr LO
                            bcc GetGfxCountAndDataByte      ; check: overflow - no
                            inc HLZ_ScreenGfxPtr_Hi         ; inc grafic output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
; output the next start grafic data bytes
; --------------------------------------------------------------------------------------------------------------------- ;
GetGfxCountAndDataByte      lda HLZ_WorkStartGfxDataCount   ; get gfx data byte count
                            tay                             ; set gfx data byte count as offset
                            lda HLZ_WorkStartGfxData        ; get gfx data byte
                            
SetNextStartGfxDataByte     sta (HLZ_StartGfxDisplay),y     ; set start grafic data
                            dey                             ; dec gfx data byte count
                            bne SetNextStartGfxDataByte     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; advance start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_StartGfxDisplay_Lo      ; get next start grafic pos LO
                            clc                             ; 
                            adc HLZ_WorkStartGfxDataCount   ; add old offset
                            sta HLZ_StartGfxDisplay_Lo      ; set next start grafic pos LO
                            bcc ChkEndOfCopy                ; check: overflow - no
                            inc HLZ_StartGfxDisplay_Hi      ; inc next start grafic pos HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check end of start grafic expand
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfCopy                lda HLZ_StartGfxDisplay_Hi      ; get start grafic pos HI
                            cmp #>HL_ScreenGfxDisplayEnd    ; test maximum
                            bcc GetNextGfxDataInPair        ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a high score top entry already exists 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ScoreBufName             ; get 1st name char                                         .hbu032.
                            beq StartGraficOutX             ; check: filled - no: do not display a message              .hbu032.
                            
                            jsr StartGraficMsgOut           ; display the current top scorer                            .hbu032.
                            
                            sec                             ; .C=1 - bypass new key reset                               .hbu032.
StartGraficOutX             jmp DemoWaitInit                ; init wait for demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartGraficMsgOut         Does    : display the top scorers name and scores on the grafic screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartGraficMsgOut          .block                           ; 
                            tax                             ; save the first chr                                        .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; color the message area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$27                        ; get amount                                                .hbu032.
                            lda #HR_YELLOW_CYAN             ; get color scores                                          .hbu032.
ColorNextTop_Score          sta HL_ScreenMC_Title,y         ; set color scores                                          .hbu032.
                            
                            dey                             ; dec amount                                                .hbu032.
                            bpl ColorNextTop_Score          ; check: min - no: continue                                 .hbu032.
                            
                            ldy #$0c                        ; get amount                                                .hbu032.
                            lda #HR_LT_RED_LT_RED           ; get color name                                            .hbu032.
ColorNextTop_Name           sta HL_ScreenMC_Title,y         ; set color name                                            .hbu032.
                            
                            dey                             ; dec amount                                                .hbu032.
                            bpl ColorNextTop_Name           ; check: min - no: continue                                 .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor for message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_StatusRowNum            ;                                                           .hbu032.
                            sta HLZ_ScreenRow               ; screen row  (00-0f)                                       .hbu032.
                            lda #$00                        ;                                                           .hbu032.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in top scorers name
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; restore the first character                               .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char2       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char3       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char4       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char5       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char6       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char7       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
                            lda HL_ScoreBufName_Char8       ;                                                           .hbu032.
                            jsr TextOutCharHandler          ; control the output of a single char                       .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in top scorers score
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu032.
                            .byte "s" | $80 ;               ; SCORE                                                     .hbu032.
                            .byte "c" | $80 ;               ;                                                           .hbu032.
                            .byte "o" | $80 ;               ;                                                           .hbu032.
                            .byte "r" | $80 ;               ;                                                           .hbu032.
                            .byte "e" | $80 ;               ;                                                           .hbu032.
                            
                            .byte $00 ; EndOfText                                                                       .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ScoreBufValue_Hi         ; get 1st score byte                                        .hbu032.
;                           jsr StatusOutDigitBCD           ; ouput the 1st two score digits                            .hbu032.
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output               .hbu032.
                            
                            lda HL_Digit_1                  ; get digit 1 part - use only right nibble discard left     .hbu032.
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu032.
                            
                            lda HL_ScoreBufValue_Mid_Hi     ; get 2nd score byte                                        .hbu032.
                            jsr StatusOutDigitBCD           ; ouput the 1st two score digits                            .hbu032.
                            
                            lda HL_ScoreBufValue_Mid_Lo     ; get 3rd score byte                                        .hbu032.
                            jsr StatusOutDigitBCD           ; ouput the 1st two score digits                            .hbu032.
                            
                            lda HL_ScoreBufValue_Lo         ; get 4th score byte                                        .hbu032.
                            jsr StatusOutDigitBCD           ; ouput the 1st two score digits                            .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in top scorers level
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu032.
                            .byte "l" | $80 ;               ; LVL                                                       .hbu032.
                            .byte "v" | $80 ;               ;                                                           .hbu032.
                            .byte "l" | $80 ;               ;                                                           .hbu032.
                            
                            .byte $00 ; EndOfText                                                                       .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ScoreBufLevel            ; level byte                                                .hbu032.
                            jmp StatusOutDigitBin           ; output a binary digit to status row                       .hbu032.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_TitleSet              Does    : set title display IRQ to combine the 2 diiferent GFX modes
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_TitleSet               .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen                               .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare Standard BitMap Mode (ECM=0 BMM=1 MCM=0)
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)      .hbu032.
                            and #~SCROLY_RST8               ; clear bit7: no bit8 (high bit) of raster compare register .hbu032.
                            ora #SCROLY_BMM_ON              ; switch on Bitmap Mode (BMM)                               .hbu032.
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)      .hbu032.
                            
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
                            and #SCROLX_MCM_OFF             ; switch off Multi Color Mode (MCM)                         .hbu032.
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set charset location
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda VMCSB                       ; VIC($D018) VIC Chip Memory Control                        .hbu032.
                            and #~(VMCSB_CB_MASK | %00000001) ; clear char set location part                            .hbu032.
                            ora #VMCSB_CB_2000              ; chr generator to video base + 2000-3fff                   .hbu032.
                            sta VMCSB                       ; VIC($D018) VIC Chip Memory Control                        .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set raster IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
                            sei                             ; do not get interrupted                                    .hbu032.
                            
TitleIRQ                    lda #<IRQ_TitleDisplayHandler   ; set Title IRQ routine                                     .hbu032.
                            sta CINV_LO                     ; Vector($0314/$0315): Hardware IRQ Interrupt adr ($EA31)   .hbu032.
                            lda #>IRQ_TitleDisplayHandler   ;                                                           .hbu032.
                            sta CINV_HI                     ; Vector($0314/$0315): Hardware IRQ Interrupt adr ($EA31)   .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; allow raster interupts
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_IRQ_TitleRasterLine_Top ; 1st raster line for interrupt                             .hbu032.
                            sta RASTER                      ; VIC($D012) Current Raster Scan Line (Bit8 in SCROLY)      .hbu032.
                            
                            lda #IRQMASK_ERST               ; allow raster IRQs                                         .hbu032.
                            sta IRQMASK                     ; VIC($D01A) IRQ Mask Register                              .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset pending interupts
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - cleared on read           .hbu032.
                            lda CI2ICR                      ; CIA2($DD0D) Interrupt Control Register - cleared on read  .hbu032.
                            
                            lda VICIRQ                      ; VIC($D019) Interrupt Flags - get inzerrupt flags          .hbu032.
                            sta VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1 .hbu032.
                            
                            cli                             ; reallow interrupts                                        .hbu032.
                            rts                             ;                                                           .hbu032.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_GameSet               Does    : switch back to game IRQ
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_GameSet                .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen                               .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset raster IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
                            sei                             ; do not get interrupted                                    .hbu032.
                            
                            lda #<IRQ                       ; the 60 times a second action                              .hbu032.
                            sta CINV_LO                     ; Vector($0314/$0315): Hardware IRQ Interrupt adr ($EA31)   .hbu032.
                            lda #>IRQ                       ;                                                           .hbu032.
                            sta CINV_HI                     ; Vector($0314/$0315): Hardware IRQ Interrupt adr ($EA31)   .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; disallow all IRQs
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #~IRQMASK_ALL_ENA           ; disallow raster IRQs                                      .hbu032.
                            sta IRQMASK                     ; VIC($D01A) IRQ Mask Register                              .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset pending interupts
; --------------------------------------------------------------------------------------------------------------------- ;
ResetPending                lda CIAICR                      ; CIA1($DC0D) Interrupt Control - cleared on read           .hbu032.
                            lda CI2ICR                      ; CIA2($DD0D) Interrupt Control Register - cleared on read  .hbu032.
                            
                            lda VICIRQ                      ; VIC($D019) Interrupt Flags - get interrupt flags          .hbu032.
                            sta VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1 .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; switch on Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1)
; --------------------------------------------------------------------------------------------------------------------- ;
MultiColorOn                lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
                            ora #SCROLX_MCM_ON              ; set bit4: enable Multicolor Bitmap Mode                   .hbu032.
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
                            
                            cli                             ; reallow interrupts                                        .hbu032.
                            rts                             ;                                                           .hbu032.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_PlayTunes             Does    : play the tune available in IRQ tune buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunes              .block                           ; 
                            ldx HL_TuneToPlayOff            ; get tune buffer offset
                            cpx HL_TuneFreeBufferPosOff     ; test with next free tune buffer offset
                            beq IRQ_PlayTunesOff            ; check: EQ - yes: all tunes completed - exit
                            
                            lda #CNTRL3_GATE_ADS | CNTRL3_TRI ; get start attack decay sustain/triangle wave
                            sta HL_WaveVoice2               ; set wave form voice 2
                            sta HL_WaveVoice3               ; set wave form voice 3
                            
                            lda HL_TuneSuReVol,x            ; get tune s/r/volume - not used
                            
                            lda #STNRIS2_STN_MASK           ; get sustain voice 2
                            and HL_Volume                   ; isolate sustain volume level
                            sta SUREL2                      ; SID($D40D) Oscillator 2 Sustain/Release
                            sta SUREL3                      ; SID($D414) Oscillator 3 Sustain/Release
                            
                            lda HL_TuneDataPtrVoice2,x      ; get new tab tune data pointer voice 2
                            bne SetFreqCtrlDataTableOff     ; check: none - yes
                            
                            sta HL_WaveVoice2               ; set new tab tune data pointer voice 2
                            
SetFreqCtrlDataTableOff     tay                             ; set as offset
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sta FRELO2                      ; SID($D407) Oscillator 2 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sta FREHI2                      ; SID($D408) Oscillator 2 Freq Ctrl (HI byte)
                            
                            lda HL_TuneDataPtrVoice3,x      ; get tab tune data pointer voice 3
                            bpl ChkTuneDataPtrZero          ; check: positive - yes
                            
                            lda HL_TuneDataPtrVoice2,x      ; get tab tune data pointer voice 2
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set decreased freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sbc #$80                        ; decrease
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sbc #$00                        ; subtract .C
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
                            
                            jmp SetVoiceCtrlData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTuneDataPtrZero          bne SetAsOffset                 ; check: zero - no
                            
                            sta HL_WaveVoice3               ; set tune data for voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; set freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
SetAsOffset                 tay                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq ctrl data LO
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq ctrl data HI
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice control data for voice 2/voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
SetVoiceCtrlData            lda HL_WaveVoice2               ; get tune control data for voice 2
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            
                            lda HL_WaveVoice3               ; get tune control data for voice 3
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; dec playtime
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_TunePlayTime,x           ; dec tune play time
                            bne IRQ_PlayTunesX              ; check: end of tune - no: exit - continue this one
; --------------------------------------------------------------------------------------------------------------------- ;
; set next tune to play
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_TuneToPlayOff            ; set offest to next tune to play
                            
IRQ_PlayTunesX              rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunesOff            lda #$00                        ; get reset value
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuSetGetGoldJingle    Does    : fill the IRQ tune buffer with get gold jingle
;                           Expects : 
;                           Returns : 
;                           Remark  : jingle is played with IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuSetGetGoldJingle     .block                           ; 
                            pla                             ; 
                            sta HLZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            pla                             ; 
                            sta HLZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne IncJingleDataPtr            ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; copy next jingle part value to tune buffers
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBuf      sei                             ; disable interrupts - do not play any jingle now
; --------------------------------------------------------------------------------------------------------------------- ;
; a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial offset
                            lda (HLZ_JingleDataPtr),y       ; get 1st jingle data block byte
                            beq PutNextJingleByteToBufX     ; check: EoD - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st byte: fill time buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta HL_TunePlayTime,x           ; set tab jingle time
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd byte: fill voice 2 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (HLZ_JingleDataPtr),y       ; get 2nd jingle data block byte
                            sta HL_TuneDataPtrVoice2,x      ; set tab jingle data pointer voice 2
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd byte: fill voice 3 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (HLZ_JingleDataPtr),y       ; get 3rd jingle data block byte
                            sta HL_TuneDataPtrVoice3,x      ; set tab jingle data pointer voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; 4th byte: fill sustain/release/volume buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (HLZ_JingleDataPtr),y       ; get 4th jingle data block byte
                            sta HL_TuneSuReVol,x            ; set tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next jingle block of data
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_TuneFreeBufferPosOff     ; inc offset next free tune buffer byte
                            lda HLZ_JingleDataPtr_Lo        ; get jingle data pointer LO
                            clc                             ; 
                            adc #LodeRuGetGold.TabGoldJinglePart_Len ; add tune part table length
                            sta HLZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            
                            lda HLZ_JingleDataPtr_Hi        ; get jingle data pointer HI
                            adc #$00                        ; add .C
                            sta HLZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
IncJingleDataPtr            inc HLZ_JingleDataPtr_Lo        ; inc jingle data pointer LO
                            bne PutNextJingleByteToBuf      ; check: overflow - no
                            inc HLZ_JingleDataPtr_Hi        ; inc jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push jingle data pointer to stack - thus return to code directly following jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBufX     lda HLZ_JingleDataPtr_Hi        ; get pointer jingle data end HI
                            pha                             ; push as return address
                            
                            lda HLZ_JingleDataPtr_Lo        ; get pointer jingle data end LO
                            pha                             ; push as return address
                            
                            cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; return to instruction directly after end of jingle data
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGoldJingleVal    Does   : return RND raster beam position within given limits
;                           Expects : .A=bottom limit
;                                   : .X=lower limit
;                                   : .Y=upper limit
;                           Returns : .A=raster beam position within limits
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGoldJingleVal     .block                           ; 
                            sta HL_GoldJingleBeamLimit      ; save bottom limit
                            
GetNextRasterBeamPos        lda RASTER                      ; VIC($D012) Read: Current Raster Scan Line (Bit 8 in SCROLY = $D011)
                            sta HL_GoldJingleBeamPos        ; set beam pos
                            
                            cpx HL_GoldJingleBeamPos        ; test beam pos lower limit
                            bcc ChkUpperLimit               ; check: LT - yes
                            beq ChkUpperLimit               ; check: EQ - yes
                            
                            jmp GetNextRasterBeamPos        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpy HL_GoldJingleBeamPos        ; test beam pos upper limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; raster beam value is between upper and lower limit
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc HL_GoldJingleRndSeed        ; 
                            bcs ChkBottomLimit              ; check: underflow - no
                            
                            eor #$ff                        ; set ones complement - make positive
                            adc #$01                        ; 
                            
ChkBottomLimit              cmp HL_GoldJingleBeamLimit      ; test limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes: get next beam pos
                            
                            lda HL_GoldJingleBeamPos        ; get correct beam pos
                            sta HL_GoldJingleRndSeed        ; set new seed
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldInit      Does    : initialize the jingle control data
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldInit       .block                           ; 
                            lda TabJingleMaxNum             ; get initial value
                            sta HL_JingleNum                ; set jingle count
                            
                            lda TabJingleHeight_Min         ; get initial value
                            sta HL_JingleHeight             ; ini jingle height
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldNext      Does    : set the next got all gold jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldNext       .block                           ; 
                            dec HL_JingleNum                ; set next Jingle number
                            bpl JingleGotAllGoldNextX       ; check: underflow - no: exit
                            
                            inc HL_JingleHeight             ; inc Jingle height
                            
                            lda HL_JingleHeight             ; get Jingle height
                            cmp TabJingleHeight_Max         ; test max
                            bcc SetJingleMaxNum             ; check: LT - no: set Jingle to max
                            
                            lda TabJingleHeight_Min         ; get min height
                            sta HL_JingleHeight             ; set height to min again
                            
SetJingleMaxNum             lda TabJingleMaxNum             ; get initial value
                            sta HL_JingleNum                ; ini jingle number
                            
JingleGotAllGoldNextX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldCopy      Does    : fill the tune buffers with the data for the all gold collected jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldCopy       .block                           ; 
                            lda HL_JingleNum                ; get Jingle number
                            asl a                           ; *2 for pointer length
                            tax                             ; set Jingle data pointer table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set jingle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabJingleDataPtr_Lo,x       ; get pointer to Jingle data LO
                            sta HLZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            lda TabJingleDataPtr_Hi,x       ; get pointer to Jingle data HI
                            sta HLZ_JingleDataPtr_Hi        ; set Jingle data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextJingleDataBlock      sei                             ; disable interrupts - do not play any jingle now
                            
                            ldy #$00                        ; get offset Jingle data
                            lda (HLZ_JingleDataPtr),y       ; get Jingle data for play time
                            beq JingleGotAllGoldCopyX   ; check: end of data - yes: exit
                            
                            ldx HL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta HL_TunePlayTime,x           ; set tune play time
                            
                            iny                             ; advance offset Jingle data
                            lda (HLZ_JingleDataPtr),y       ; get Jingle data for voice 2
                            beq SetTuneDataVoice2           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc HL_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice2           sta HL_TuneDataPtrVoice2,x      ; set tab tune data pointer voice 2
                            
                            iny                             ; advance offset Jingle data
                            lda (HLZ_JingleDataPtr),y       ; get Jingle data for voice 3
                            beq SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            bmi SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc HL_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice3           sta HL_TuneDataPtrVoice3,x      ; set tab tune data pointer voice 3
                            
                            iny                             ; advance offset Jingle data
                            lda (HLZ_JingleDataPtr),y       ; get Jingle data for sustain/release/volume
                            sta HL_TuneSuReVol,x            ; set tune s/r/volume  (not used)
                            
                            inc HL_TuneFreeBufferPosOff     ; inc offset to next free tune buffer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance jingle data pointer - a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_JingleDataPtr_Lo        ; get Jingle data pointer LO
                            clc                             ; 
                            adc #TabJingleDataBlock_Len     ; add entry block length
                            sta HLZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            
                            lda HLZ_JingleDataPtr_Hi        ; get data pointer HI
                            adc #$00                        ; add .C
                            sta HLZ_JingleDataPtr_Hi        ; set data pointer HI
                            
                            bne GetNextJingleDataBlock      ; always (hopefully)
                            
JingleGotAllGoldCopyX       cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ                       Does    : game IRQ routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ                        .block                           ; 
                            inc HL_CountIRQs                ; 
                            
                            lda #$00                        ; get initial value
                            sta HLZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            lda HL_Volume                   ; get volume
                            and #MODEVOL_VOL_MASK           ; isolate volume
                            sta SIGVOL                      ; SID($D418) Volume/Filter Select
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
                            bne InitFallBeep                ; check: not falling - yes
                            
                            ldx HL_TuneBeepFall             ; get fall beep
                            stx HLZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            jmp CheckLodeRuShoot            ; check for shooting
; --------------------------------------------------------------------------------------------------------------------- ;
InitFallBeep                lda #HL_TuneBeepFall_Start      ; get initial value
                            sta HL_TuneBeepFall             ; set fall beep start value
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is shooting
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuShoot            lda HL_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq InitShootTune               ; check: no shoot - yes
                            
                            lda HL_TuneShoot                ; get actual shoot tune value
                            sec                             ; 
                            sbc #HL_TuneShoot_Step          ; step tune value down
                            sta HL_TuneShoot                ; set actual shoot tune value
                            sta HLZ_TuneValueVoice_01       ; set tune value voice 1
                            beq InitShootTune               ; check: zero - yes: reinit
                            
                            jmp CheckLodeRuDeath            ; check for death
; --------------------------------------------------------------------------------------------------------------------- ;
InitShootTune               lda #HL_TuneShoot_Start         ; get 
                            sta HL_TuneShoot                ; set 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has died
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuDeath            lda HL_TuneDeath                ; get actual death tune
                            beq GetTuneValueToPlay          ; check: death - no
                            
                            sec                             ; 
                            sbc #HL_TuneDeath_Step          ; step tune value down
                            sta HLZ_TuneValueVoice_01       ; set tune value voice 1
                            sta HL_TuneDeath                ; set actual death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; play tune
; --------------------------------------------------------------------------------------------------------------------- ;
GetTuneValueToPlay          lda HLZ_TuneValueVoice_01       ; get tune value voice 1
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            jsr IRQ_PlayTunes               ; play the tune available in IRQ tune buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard input
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr IRQ_GetKey                  ; handle keyboard                                           .hbu032.
                            jsr IRQ_GetJoystick             ; handle joystick                                           .hbu027.
                            jmp KEY                         ; continue with main KERNAL IRQ entry point
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_GetKey                Does    : store a pressed key code
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_GetKey                 .block                           ; 
                            lda LSTX                        ; Kernal: keyboard matrix value last key pressed
                            bne CheckKey_None               ; check: pressed
                            
                            lda #$07                        ; DELETE substitution - get <CURSOR DOWN>
                            
CheckKey_None               cmp #LSTX_NONE                  ; test no key pressed
                            bne CheckKey_Shift              ; check: EQ - no
                            
                            lda #HL_KeyOld_None             ; get initial value
                            sta HL_KeyOld                   ; ini pressed key store
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; a key was pressed - check <SHIFT> flag
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Shift              ldx SHFLAG                      ; <SHIFT> key indicator - $01=shift $02=commodore $04=ctrl
                            beq CheckKey_Old                ; check: none - yes: debounce
; --------------------------------------------------------------------------------------------------------------------- ;
; treat all <SHIFT> <C=> <CTRL> as <SHIFT>
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora #$80                        ; set <SHIFT> flag
; --------------------------------------------------------------------------------------------------------------------- ;
; debounce
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Old                cmp HL_KeyOld                   ; 
                            beq IRQ_GetKeyX                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store keyboard values
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HL_KeyOld                   ; 
                            sta HL_KeyNew                   ; 
                            
IRQ_GetKeyX                 rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_GetJoystick           Does    : store a joystick action
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_GetJoystick            .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A                          .hbu027.
                            and #CIAPRA_JOY_ALL             ; isolate action bits                                       .hbu027.
                            eor #CIAPRA_JOY_ALL             ; flip action bits                                          .hbu027.
                            bne CheckJoystick_Old           ; check: action - yes                                       .hbu027.
                            
                            sta HL_JoystickOld              ; reset old value                                           .hbu027.
                            
                            rts                             ;                                                           .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; something was pressed on the joystick - debounce
; --------------------------------------------------------------------------------------------------------------------- ;
CheckJoystick_Old           cmp HL_JoystickOld              ;                                                           .hbu027
                            beq IRQ_GetJoystickX            ;                                                           .hbu027
; --------------------------------------------------------------------------------------------------------------------- ;
; store joystick values
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HL_JoystickOld              ;                                                           .hbu027.
                            sta HL_JoystickNew              ;                                                           .hbu027.
                            
IRQ_GetJoystickX            rts                             ;                                                           .hbu027.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_TitleDisplayHandler   Does    : control the normal/top scorer line title screen display modes
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_TitleDisplayHandler    .block                           ; 
                            lda VICIRQ                      ; VIC($D019) Interrupt Flags - get interrupt flags          .hbu032.
                            sta VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1 .hbu032.
                            bmi GetRaster                   ; check: Bit7 set - yes: At least one VIC IRQ has happened  .hbu032.
                            
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - cleared on read           .hbu032.
                            
                            cli                             ; still allow VIC IRQs                                      .hbu032.
                            jmp KEY                         ; continue with main KERNAL IRQ entry point                 .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; got an VIC IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
GetRaster                   lda RASTER                      ; VIC($D012) Read : Current Raster Scan Line (Bit 8 in SCROLY) .hbu032.
                            cmp #HL_IRQ_TitleRasterLine_Bot ; test 2nd raster line for interrupt                        .hbu032.
                            bcs StdBitmapMode               ; Check: GE - yes                                           .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set Multicolor Bitmap Mode (ECM=0 BMM=1 MCM=1)
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
                            ora #SCROLX_MCM_ON              ; set bit4: enable Multicolor Bitmap Mode                   .hbu032.
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set next raster interrupt line bottom
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_IRQ_TitleRasterLine_Bot ; set 2nd raster line for interrupt                         .hbu032.
                            jmp SetNextRasterLine           ;                                                           .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set Standard BitMap Mode (ECM=0 BMM=1 MCM=0)
; --------------------------------------------------------------------------------------------------------------------- ;
StdBitmapMode               lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
                            and #SCROLX_MCM_OFF             ; clear bit4: disable Multicolor Bitmap Mode                .hbu032.
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; set next raster interrupt line top
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_IRQ_TitleRasterLine_Top ; set 1st raster line for interrupt                         .hbu032.
                            
SetNextRasterLine           sta RASTER                      ; VIC($D012) Read : Current Raster Scan Line (Bit 8 in SCROLY) .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle keyboard input
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr IRQ_GetKey                  ; handle keyboard                                           .hbu032.
; --------------------------------------------------------------------------------------------------------------------- ;
; to main IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp KEYRTI                      ; continue with main IRQ exit point - clear interupt flags  .hbu032.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartInitMachine          Does    : initially prepare the machine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartInitMachine           .block                           ; 
                            lda R6510                       ; 6510 On-Chip I/O Data
                            and #%11000000 | LORAM_BASIC_OFF; switch basic off
                            sta R6510                       ; 6510 On-Chip I/O Data
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner bit-mapped memory
;   $19 blocks ($00-$18)
;     each block contains $140 (320) bytes and controls $08 horizontal pixel rows
;     every 8th Y-value starts a new block of $140 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
;   byte number of the 1st byte in any block (X=pixel col number/Y=row number)
;     320*(INT(Y/8))
;   byte number contaning the requested hires bit
;     320*(INT(Y/8)) + (Y AND 7) + 8*(INT(X/8))
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
;       X !  Column $00  !  column $01  !  column $02  !     !  column $26  !  column $27  ! 
; Y       ! byte  number ! byte  number ! byte  number !     ! byte  number ! byte  number ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $00 !     0000     !     0008     !    0010      ! ... !     0130     !     0138     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $00
; row $07 !     0007     !     000f     !    0017      ! ... !     0137     !     013f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $08 !     0140     !     0148     !    0150      ! ... !     0282     !     0278     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $01
; row $0f !     0147     !     014f     !    0157      ! ... !     0277     !     027f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; ...     !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! 
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c0 !     1e00     !     1e08     !    1e10      ! ... !     1f30     !     1f38     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $18
; row $c7 !     1e07     !     1e0f     !    1e17      ! ... !     1f37     !     1f3f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; block $19 not used
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c8 !     1f40     !     1f48     !    1f50      ! ... !     1f00     !     1f08     !  
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $19
; row $cf !     1f47     !     1f4f     !    1f57      ! ... !     1f07     !     1fff     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
; init values of the tables containing the HiRes pixel row start addresses
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get intial value LO
                            sta HLZ_WorkHiresRowStartAdr_Lo ; ini work grafic row start address LO
;                           lda #$00                        ; get initial value HI <obsolete>                           .hbu001.
                            sta HLZ_WorkHiresRowStartAdr_Hi ; ini work grafic row start address HI
                            
                            ldy #$00                        ; ini offset tab grafic row start pointer tab
                            
                            lda #VICSCN_NLINES              ; get hires block count (25)
                            sta HL_HiresBlockCount          ; ini hires block count (25*320 bytes)
; --------------------------------------------------------------------------------------------------------------------- ;
; create tables with HI/LO start addresses of $c8 HiRes rows forming $19 blocks of $08 stacked pixel rows
; --------------------------------------------------------------------------------------------------------------------- ;
; $0e00: block $00 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $00
; $0e08: block $01 LO - $40 $41 $42 $43 $44 $45 $46 $47 - start address LO - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0ec0: block $18 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
; $0f00: block $00 HI - $00 $00 $00 $00 $00 $00 $00 $00 - start address HI - $08 pixel rows of block $00
; $0f08: block $01 HI - $01 $01 $01 $01 $01 $01 $01 $01 - start address HI - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0fc0: block $18 HI - $1e $1e $1e $1e $1e $1e $1e $1e - start address HI - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextBlockRowCount        ldx #$08                        ; ini count stacked bytes per block
GetNextTabPairValue         lda HLZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            sta HL_HiresRowStartPtrTab_Hi,y ; set tab grafic row start address HI
                            
                            lda HLZ_WorkHiresRowStartAdr_Lo ; get work grafic row start address LO
                            sta HL_HiresRowStartPtrTab_Lo,y ; set tab grafic row start address LO
                            
                            inc HLZ_WorkHiresRowStartAdr_Lo ; inc work grafic row start address LO
                            
                            iny                             ; inc offset tab grafic row start pointer tab
                            dex                             ; dec count stacked bytes per block
                            bne GetNextTabPairValue         ; check: count stacked bytes per block min - no: contiinue
                            
                            clc                             ; .A=work grafic row start pointer LO
                            adc #<$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta HLZ_WorkHiresRowStartAdr_Lo ; set work grafic row start address LO
                            
                            lda HLZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            adc #>$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta HLZ_WorkHiresRowStartAdr_Hi ; set work grafic row start address HI
                            
                            dec HL_HiresBlockCount          ; dec hires block count
                            bne GetNextBlockRowCount        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; create tables containing the HI/LO pointers to the start of each image data
; --------------------------------------------------------------------------------------------------------------------- ;
CreateImageAdrTab           lda #<TabImageData              ; set start address                                         .hbu000.
                            sta HLZ_WorkImageDataAdr_Lo     ;                                                           .hbu000.
                            lda #>TabImageData              ;                                                           .hbu000.
                            sta HLZ_WorkImageDataAdr_Hi     ;                                                           .hbu000.
                            
                            ldx #$00                        ; init counter                                              .hbu000.
GetNextImageAdr             lda HLZ_WorkImageDataAdr_Hi     ;                                                           .hbu000.
                            sta HL_ImageAdr_Hi,x            ; set image address table high byte                         .hbu000.
                            lda HLZ_WorkImageDataAdr_Lo     ;                                                           .hbu000.
                            sta HL_ImageAdr_Lo,x            ; set image address table low  byte                         .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next image data address
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ;                                                           .hbu000.
                            adc #(HL_ImageHeight * $03)     ; $21 image bytes                                           .hbu000.
                            sta HLZ_WorkImageDataAdr_Lo     ;                                                           .hbu000.
                            bcc SetNextTabPos               ;                                                           .hbu000.
                            inc HLZ_WorkImageDataAdr_Hi     ;                                                           .hbu000.
                            
SetNextTabPos               inx                             ; inc counter - fill in $ff image addresses                 .hbu000.
                            bne GetNextImageAdr             ; check: max - no: continue                                 .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; set NMI vector to a simple RTI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<NMI                       ; get start of NMI routine LO
                            sta NMINV_LO                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)
                            lda #>NMI                       ; get start of NMI routine HI
                            sta NMINV_HI                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)

                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #BLACK                      ; get color
                            sta BGCOL0                      ; VIC($D021) Background Color 0
                            sta EXTCOL                      ; VIC($D020) Border Color
; --------------------------------------------------------------------------------------------------------------------- ;
; set IRQ vector - handles all ingame tunes
; --------------------------------------------------------------------------------------------------------------------- ;
                            sei                             ; 
                            lda #<IRQ                       ; get start of IRQ routine LO
                            sta CINV_LO                     ; set Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31)
                            lda #>IRQ                       ; get start of IRQ routine HI
                            sta CINV_HI                     ; set Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31); IRQ vector
                            cli                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; ini SID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$b0                        ; get initial value
                            sta SUREL1                      ; SID($D406) Oscillator 1 Sustain/Release
                            
                            lda #CNTRL1_TRI | CNTRL1_GATE_ADS ; get initial value
                            sta VCREG1                      ; SID($D404) Oscillator 1 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; ini sprites
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_SpriteData / SPRT_BLK_LEN ; get sprite storage pointer
                            stx HL_SpritePtr_00             ; set sprite 0 data pointer to HL_SpriteData + $00
                            inx                             ; 
                            stx HL_SpritePtr_02             ; set sprite 2 data pointer to HL_SpriteData + $40
                            inx                             ; 
                            stx HL_SpritePtr_03             ; set sprite 3 data pointer to HL_SpriteData + $80
                            inx                             ; 
                            stx HL_SpritePtr_04             ; set sprite 4 data pointer to HL_SpriteData + $c0
                            inx                             ; 
                            stx HL_SpritePtr_06             ; set sprite 6 data pointer to HL_SpriteData + $00
                            inx                             ; 
                            stx HL_SpritePtr_07             ; set sprite 7 data pointer to HL_SpriteData + $40
                            
                            lda #CYAN                       ; get color
                            ldy #$07                        ; ini enemy sprite count
SetNextEnemyColor           sta SP0COL,y                    ; VIC($D027) Color Sprite 0
                            
                            dey                             ; dec enemy sprite count
                            bne SetNextEnemyColor           ; check: enemy sprite count min - no: continue
                            
                            iny                             ; get Loderunner sprite color WHITE
                            sty SP0COL                      ; VIC($D027) Color Sprite 0
                            
                            lda #SPBGPR_ALL_FG              ; get all Sprites display priority in front of background
                            sta SPBGPR                      ; set VIC($D01B) Sprite to Foreground Display Priority
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite buffers
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; init buffer page offset to $00
ClrNextSpriteBufferByte     sta ZP_START + $02,y            ; set zero page
                            sta HL_SpriteDataPage_01,y      ; set sprite data store at $0c00 to $00
                            sta HL_SpriteDataPage_02,y      ; set sprite data store at $0d00 to $00
                            
                            iny                             ; inc buffer page offset
                            bne ClrNextSpriteBufferByte     ; check: buffer page offset max - no: continue
                            
                            lda #SPENA_ALL_ON               ; get switch on all sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; ColorLevelHandler         Does    : set the color pointer for level and status row
;                           Expects : .A=hires color level
;                                   : .X=hires color status line
;                                   : .Y=COLORAM color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevelHandler          .block                           ; 
                            sta HL_ColorLevel               ;                                                           .hbu006.
                            stx HL_ColorStatus              ;                                                           .hbu006.
;                           stx HL_ColorStatusMsg           ;                                                           .hbu006.
                            sty HL_ColorColorRam            ;                                                           .hbu006.
                            
                            jsr ColorLevel                  ; color level                                               .hbu006.
                            jmp ColorStatus                 ; fill the status row with the selected colors              .hbu006.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorLevelSelect          Does    : select a new color combination every 10th level
;                                   : do not select the RED/RED one again
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevelSelect           .block                           ; 
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu006.
                            lsr a                           ; shift out demo flag                                       .hbu006.
                            bne GetLevelNumGame             ; check: demo - no                                          .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; set fix demo level colors
; --------------------------------------------------------------------------------------------------------------------- ;
GetDemoColors               ldx #$00                        ; get demo color tables offset                              .hbu006.
                            lda TabStatusMsgColor,x         ; get status message color                                  .hbu006.
                            
                            ldy #GREY                       ; get fix demo background color                             .hbu006.
                            bne SetColorPtrs                ; always                                                    .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; set variable game level colors
; --------------------------------------------------------------------------------------------------------------------- ;
GetLevelNumGame             lda HL_LevelNumGame             ; get game level number (001-250)                           .hbu006.
                            
                            ldx #TabLevelColor_Max          ; preset last color table offset                            .hbu006.
                            cmp #HL_LevelNumGame_Max        ; test last level                                           .hbu006.
                            beq GetLevelColor               ; check: .EQ. - yes: keep previous colors                   .hbu006.
                            
                            ldx #$01                        ; preset initial color table offset                         .hbu006.
                            cmp #$01                        ; test level one                                            .hbu006.
                            beq GetLevelColor               ; check: .EQ. - yes: RED/RED only once                      .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; set a new color tab pointer any 10 levels
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ;                                                           .hbu006.
CalcNextColorTabPtr         inx                             ; inc color table offset for every 10th level               .hbu006.
                            sbc #$0a                        ; discount 10 levels                                        .hbu006.
                            bcs CalcNextColorTabPtr         ; check: .GE. 10 - yes: continue counting                   .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; modify the level color pointers
; --------------------------------------------------------------------------------------------------------------------- ;
GetLevelColor               ldy #WHITE                      ; get fix level background color                            .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
SetColorPtrs                lda TabLevelColor,x             ; get level color                                           .hbu006.
                            sta HL_ColorLevel               ;                                                           .hbu006.
                            
                            lda TabStatusMsgColor,x         ; get status message color                                  .hbu006.
                            sta HL_ColorStatusMsg           ;                                                           .hbu006.
                            
                            lda TabStatusColor,x            ; get status color                                          .hbu006.
                            sta HL_ColorStatus              ;                                                           .hbu006.
                            
                            sty HL_ColorColorRam            ;                                                           .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; recolor all sprites
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameColorSprites            ; set the sprite colors for this level                      .hbu005.
                            
                            rts                             ;                                                           .hbu007.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorLevel                Does    : fill game level screen with the selected colors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevel                 .block                           ; 
;                           lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu006. removed
;                           ora #SCROLX_MCM_ON              ; switch on Multi Color Mode (MCM)                          .hbu006. removed
;                           sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)     .hbu006. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; init color pointers
; --------------------------------------------------------------------------------------------------------------------- ;
SetScreenColorPtr           lda #<HL_ScreenMC + $02         ;                                                           .hbu006.
                            sta smScreenColorPtr_Lo         ;                                                           .hbu006.
                            lda #>HL_ScreenMC + $02         ;                                                           .hbu006.
                            sta smScreenColorPtr_Hi         ;                                                           .hbu006.
                            
SetRamColorPtr              lda #<COLORAM + $02             ;                                                           .hbu006.
                            sta smRamColorPtr_Lo            ;                                                           .hbu006.
                            lda #>COLORAM + $02             ;                                                           .hbu006.
                            sta smRamColorPtr_Hi            ;                                                           .hbu006.
                            
                            ldy #$00                        ; get offset                                                .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in $24 hires color bytes - ignore the first two bytes of each row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextColorByteCount       ldx #$24                        ; color byte count                                          .hbu006.
                            
GetNextHiresColor           lda HL_ColorLevel               ; 
smScreenColorPtr_Lo         = * + $01                       ; self mod: adr level color hires lo                        .hbu006.
smScreenColorPtr_Hi         = * + $02                       ; self mod: adr level color hires hi                        .hbu006.
                            sta HL_ScreenMC,y               ; set next level hires color byte                           .hbu006.
                            
                            lda HL_ColorColorRam            ; 
smRamColorPtr_Lo            = * + $01                       ; self mod: adr coloram lo                                  .hbu006.
smRamColorPtr_Hi            = * + $02                       ; self mod: adr coloram hi                                  .hbu006.
                            sta COLORAM,y                   ; set next COLORAM color                                    .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance color pointers
; --------------------------------------------------------------------------------------------------------------------- ;
IncScreenColorPtr           inc smScreenColorPtr_Lo         ;                                                           .hbu006.
                            bne IncRamColorPtr              ;                                                           .hbu006.
                            inc smScreenColorPtr_Hi         ;                                                           .hbu006.
                            
IncRamColorPtr              inc smRamColorPtr_Lo            ;                                                           .hbu006.
                            bne DecHiresColorByteCount      ;                                                           .hbu006.
                            inc smRamColorPtr_Hi            ;                                                           .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; discount color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
DecHiresColorByteCount      dex                             ; color byte count                                          .hbu006.
                            bne GetNextHiresColor           ; check: min - no: continue                                 .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance color pointers to start of next row
; --------------------------------------------------------------------------------------------------------------------- ;
IncScreenColorPtrRow        lda smScreenColorPtr_Lo         ;                                                           .hbu006.
                            clc                             ;                                                           .hbu006.
                            adc #$04                        ; bypass the first and the last two row bytes               .hbu006.
                            sta smScreenColorPtr_Lo         ;                                                           .hbu006.
                            bcc IncRamColorPtrRow           ;                                                           .hbu006.
                            inc smScreenColorPtr_Hi         ;                                                           .hbu006.
                            
IncRamColorPtrRow           lda smRamColorPtr_Lo            ;                                                           .hbu006.
                            clc                             ;                                                           .hbu006.
                            adc #$04                        ; bypass the first and the last two row bytes               .hbu006.
                            sta smRamColorPtr_Lo            ;                                                           .hbu006.
                            bcc ChkScreenColorPtrMax        ;                                                           .hbu006.
                            inc smRamColorPtr_Hi            ;                                                           .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
; done if first status color row is reached
; --------------------------------------------------------------------------------------------------------------------- ;
ChkScreenColorPtrMax        ldx smScreenColorPtr_Hi         ;                                                           .hbu006.
                            cpx #>HL_ScreenMC_Status        ; test ptr HI first                                         .hbu006.
                            bne GetNextColorByteCount       ; check: .EQ. - no: continue                                .hbu006.
                            
                            ldx smScreenColorPtr_Lo         ;                                                           .hbu006.
                            cpx #<HL_ScreenMC_Status - $01  ; test ptr LO last                                          .hbu006.
                            bcc GetNextColorByteCount       ; check: .LE. - yes: continue                               .hbu006.
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorGameStorageHeader    Does    : fill the game storage list header rows with a fix color
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorGameStorageHeader     .block                           ; 
                            ldy #VICSCN_LLEN * $05 - $01    ; get offset of $03*$28 columns                             .hbu028.
GetNextTopColor             lda #HR_YELLOW_CYAN             ; get actual hires color                                    .hbu028.
                            sta HL_ScreenMC_Top,y           ; set actual hires color                                    .hbu028.
                                                                                                                        
                            dey                             ; dec offset                                                .hbu028.
                            bne GetNextTopColor             ; check: min - no: continue                                 .hbu028.
                            
                            sta HL_ScreenMC_Header,y        ; write the 1st position                                    .hbu028.
                            
                            ldy #VICSCN_LLEN * $03 - $01    ; get offset of $03*$28 columns                             .hbu028.
GetNextHiresColor           lda #HR_YELLOW_WHITE            ; get actual hires color                                    .hbu028.
                            sta HL_ScreenMC_Header,y        ; set actual hires color                                    .hbu028.
                                                                                                                        
                            dey                             ; dec offset                                                .hbu028.
                            bne GetNextHiresColor           ; check: min - no: continue                                 .hbu028.
                            
                            rts                             ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorStatus               Does    : fill both status rows with the selected colors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorStatus                .block                           ; 
                            ldy #VICSCN_LLEN2 - $01         ; get offset of $02*$28 columns                             .hbu006.
GetNextHiresColor           lda HL_ColorStatus              ;                                                           .hbu006.
                            sta HL_ScreenMC_Status,y        ; set actual hires color                                    .hbu006.
                                                                                                                        
                            lda HL_ColorColorRam            ;                                                           .hbu006.
                            sta HL_ColorRam_Status,y        ; set actual coloram color                                  .hbu006.
                                                                                                                        
                            dey                             ; dec offset                                                .hbu006.
                            bpl GetNextHiresColor           ; check: min - no: continue                                 .hbu006.
                            
                            rts                             ;                                                           .hbu006.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusMsgTextColor        Does    : fill the status row message area with the selected colors
;                           Expects : .A=message color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusMsgTextColor         .block                           ; 
                            ldy #HL_ScreenMC_MsgColor_Len - $01 ; get msg color area length                             .hbu006.
ColorNextMsgAreaByte        sta HL_ScreenMC_MsgColor,y      ; quick recolor after ClearMsg                              .hbu006.
                            dey                             ;                                                           .hbu006.
                            bpl ColorNextMsgAreaByte        ;                                                           .hbu006.
                            
                            rts                             ;                                                           .hbu006.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelClearMsgOutArea  Does    : clear the message area by setting its color to black
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelClearMsgOutArea   .block                           ; 
                            ldy #HL_ScreenMC_MsgColor_Len - $01 ; get msg color area length                             .hbu009.
                            lda #HR_BLACK_BLACK             ; quick clear by setting both colors to black               .hbu009.
ClearNextMsgAreaByte        sta HL_ScreenMC_MsgColor,y      ; recolor message part of status row                        .hbu009.
                            dey                             ; dec msg area length                                       .hbu009.
                            bpl ClearNextMsgAreaByte        ; check: min - no: continue                                 .hbu009.
                            
                            rts                             ;                                                           .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelColor               = *                             ; 
TabLevelColor_Demo          .byte HR_WHITE_LT_GREY          ; $00 - demo                                                .hbu006.
                            
TabLevelColor_001           .byte HR_CYAN_RED               ; $01 - 001                                                 .hbu006.
TabLevelColor_002           .byte HR_CYAN_PURPLE            ; $02 - 002-009                                             .hbu006.
TabLevelColor_003           .byte HR_CYAN_GREEN             ; $03 - 010-019                                             .hbu006.
TabLevelColor_004           .byte HR_CYAN_LT_RED            ; $04 - 020-029                                             .hbu006.
TabLevelColor_005           .byte HR_CYAN_ORANGE            ; $05 - 030-039                                             .hbu006.
TabLevelColor_006           .byte HR_CYAN_LT_BLUE           ; $06 - 040-049                                             .hbu006.
TabLevelColor_007           .byte HR_CYAN_PURPLE            ; $07 - 050-059                                             .hbu006.
TabLevelColor_008           .byte HR_CYAN_GREEN             ; $08 - 060-069                                             .hbu006.
TabLevelColor_009           .byte HR_CYAN_LT_RED            ; $09 - 070-079                                             .hbu006.
TabLevelColor_010           .byte HR_CYAN_LT_BLUE           ; $0a - 080-089                                             .hbu006.
TabLevelColor_011           .byte HR_CYAN_ORANGE            ; $0b - 090-099                                             .hbu006.
TabLevelColor_012           .byte HR_CYAN_PURPLE            ; $0c - 100-109                                             .hbu006.
TabLevelColor_013           .byte HR_CYAN_BLUE              ; $0d - 110-119                                             .hbu006.
TabLevelColor_014           .byte HR_CYAN_ORANGE            ; $0e - 120-129                                             .hbu006.
TabLevelColor_015           .byte HR_CYAN_LT_RED            ; $0f - 130-139                                             .hbu006.
TabLevelColor_016           .byte HR_CYAN_PURPLE            ; $10 - 140-149                                             .hbu006.
TabLevelColor_017           .byte HR_CYAN_LT_BLUE           ; $11 - 150-159                                             .hbu006.
TabLevelColor_018           .byte HR_CYAN_GREEN             ; $12 - 160-169                                             .hbu006.
TabLevelColor_019           .byte HR_CYAN_LT_RED            ; $13 - 170-179                                             .hbu006.
TabLevelColor_020           .byte HR_CYAN_ORANGE            ; $14 - 180-189                                             .hbu006.
TabLevelColor_021           .byte HR_CYAN_GREEN             ; $15 - 190-199                                             .hbu006.
TabLevelColor_022           .byte HR_CYAN_LT_BLUE           ; $16 - 200-209                                             .hbu006.
TabLevelColor_023           .byte HR_CYAN_LT_RED            ; $17 - 210-219                                             .hbu006.
TabLevelColor_024           .byte HR_CYAN_PURPLE            ; $18 - 220-229                                             .hbu006.
TabLevelColor_025           .byte HR_CYAN_ORANGE            ; $19 - 230-239                                             .hbu006.
TabLevelColor_026           .byte HR_CYAN_BLUE              ; $1a - 240-250                                             .hbu006.
                            
TabLevelColor_Max           = * - TabLevelColor_001         ; number of table entries                                   .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
TabStatusColor              = *                             ; 
TabStatusColor_Demo         .byte HR_GREY_DK_GREY           ; $00 - demo                                                .hbu006.
                            
TabStatusColor_001          .byte HR_CYAN_RED               ; $01 - 001                                                 .hbu006.
TabStatusColor_002          .byte HR_CYAN_ORANGE            ; $02 - 002-009                                             .hbu006.
TabStatusColor_003          .byte HR_CYAN_LT_BLUE           ; $03 - 010-019                                             .hbu006.
TabStatusColor_004          .byte HR_CYAN_YELLOW            ; $04 - 020-029                                             .hbu006.
TabStatusColor_005          .byte HR_CYAN_PURPLE            ; $05 - 030-039                                             .hbu006.
TabStatusColor_006          .byte HR_CYAN_GREEN             ; $06 - 040-049                                             .hbu006.
TabStatusColor_007          .byte HR_CYAN_LT_BLUE           ; $07 - 050-059                                             .hbu006.
TabStatusColor_008          .byte HR_CYAN_ORANGE            ; $08 - 060-069                                             .hbu006.
TabStatusColor_009          .byte HR_CYAN_PURPLE            ; $09 - 070-079                                             .hbu006.
TabStatusColor_010          .byte HR_CYAN_GREEN             ; $0a - 080-089                                             .hbu006.
TabStatusColor_011          .byte HR_CYAN_YELLOW            ; $0b - 090-099                                             .hbu006.
TabStatusColor_012          .byte HR_CYAN_LT_RED            ; $0c - 100-109                                             .hbu006.
TabStatusColor_013          .byte HR_CYAN_ORANGE            ; $0d - 110-119                                             .hbu006.
TabStatusColor_014          .byte HR_CYAN_LT_BLUE           ; $0e - 120-129                                             .hbu006.
TabStatusColor_015          .byte HR_CYAN_GREEN             ; $0f - 130-139                                             .hbu006.
TabStatusColor_016          .byte HR_CYAN_YELLOW            ; $10 - 140-149                                             .hbu006.
TabStatusColor_017          .byte HR_CYAN_ORANGE            ; $11 - 150-159                                             .hbu006.
TabStatusColor_018          .byte HR_CYAN_PURPLE            ; $12 - 160-169                                             .hbu006.
TabStatusColor_019          .byte HR_CYAN_LT_BLUE           ; $13 - 170-179                                             .hbu006.
TabStatusColor_020          .byte HR_CYAN_GREEN             ; $14 - 180-189                                             .hbu006.
TabStatusColor_021          .byte HR_CYAN_YELLOW            ; $15 - 190-199                                             .hbu006.
TabStatusColor_022          .byte HR_CYAN_PURPLE            ; $16 - 200-209                                             .hbu006.
TabStatusColor_023          .byte HR_CYAN_ORANGE            ; $17 - 210-219                                             .hbu006.
TabStatusColor_024          .byte HR_CYAN_GREEN             ; $18 - 220-229                                             .hbu006.
TabStatusColor_025          .byte HR_CYAN_LT_RED            ; $19 - 230-239                                             .hbu006.
TabStatusColor_026          .byte HR_CYAN_PURPLE            ; $1a - 240-250                                             .hbu006.
; ---------------------------------------------------------------------------------------------------------------------------- ;
TabStatusMsgColor            = *                            ; 
TabStatusMsgColor_Demo      .byte HR_WHITE_WHITE            ; $00 - demo                                                .hbu006.

TabStatusMsgColor_001       .byte HR_YELLOW_YELLOW          ; $01 - 001                                                 .hbu006.
TabStatusMsgColor_002       .byte HR_YELLOW_YELLOW          ; $02 - 002-009                                             .hbu006.
TabStatusMsgColor_003       .byte HR_YELLOW_YELLOW          ; $03 - 010-019                                             .hbu006.
TabStatusMsgColor_004       .byte HR_LT_BLUE_LT_BLUE        ; $04 - 020-029                                             .hbu006.
TabStatusMsgColor_005       .byte HR_YELLOW_YELLOW          ; $05 - 030-039                                             .hbu006.
TabStatusMsgColor_006       .byte HR_LT_RED_LT_RED          ; $06 - 040-049                                             .hbu006.
TabStatusMsgColor_007       .byte HR_YELLOW_YELLOW          ; $07 - 050-059                                             .hbu006.
TabStatusMsgColor_008       .byte HR_YELLOW_YELLOW          ; $08 - 060-069                                             .hbu006.
TabStatusMsgColor_009       .byte HR_YELLOW_YELLOW          ; $09 - 070-079                                             .hbu006.
TabStatusMsgColor_010       .byte HR_YELLOW_YELLOW          ; $0a - 080-089                                             .hbu006.
TabStatusMsgColor_011       .byte HR_LT_RED_LT_RED          ; $0b - 090-099                                             .hbu006.
TabStatusMsgColor_012       .byte HR_YELLOW_YELLOW          ; $0c - 100-109                                             .hbu006.
TabStatusMsgColor_013       .byte HR_YELLOW_YELLOW          ; $0d - 110-119                                             .hbu006.
TabStatusMsgColor_014       .byte HR_YELLOW_YELLOW          ; $0e - 120-129                                             .hbu006.
TabStatusMsgColor_015       .byte HR_YELLOW_YELLOW          ; $0f - 130-139                                             .hbu006.
TabStatusMsgColor_016       .byte HR_LT_RED_LT_RED          ; $10 - 140-149                                             .hbu006.
TabStatusMsgColor_017       .byte HR_YELLOW_YELLOW          ; $11 - 150-159                                             .hbu006.
TabStatusMsgColor_018       .byte HR_YELLOW_YELLOW          ; $12 - 160-169                                             .hbu006.
TabStatusMsgColor_019       .byte HR_YELLOW_YELLOW          ; $13 - 170-179                                             .hbu006.
TabStatusMsgColor_020       .byte HR_YELLOW_YELLOW          ; $14 - 180-189                                             .hbu006.
TabStatusMsgColor_021       .byte HR_LT_RED_LT_RED          ; $15 - 190-199                                             .hbu006.
TabStatusMsgColor_022       .byte HR_YELLOW_YELLOW          ; $16 - 200-209                                             .hbu006.
TabStatusMsgColor_023       .byte HR_YELLOW_YELLOW          ; $17 - 210-219                                             .hbu006.
TabStatusMsgColor_024       .byte HR_YELLOW_YELLOW          ; $18 - 220-229                                             .hbu006.
TabStatusMsgColor_025       .byte HR_YELLOW_YELLOW          ; $19 - 230-239                                             .hbu006.
TabStatusMsgColor_026       .byte HR_YELLOW_YELLOW          ; $1a - 240-250                                             .hbu006.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteColorSets          = *                            ; 1st entry is loderunner - will not be selected
; -------------------------------+------+-------+----------+----------+----------+-------+----------+----------+------- ;
;                                ! LR   ! ----- ! Enemy 1  ! Enemy 2  ! Enemy 3  ! ----- ! Enemy 4  ! Enemy 5  ! 
; -------------------------------+------+-------+----------+----------+----------+-------+----------+----------+------- ;
TabSpriteColorSet_Demo      .byte WHITE , BLACK , YELLOW   , LT_GREEN , LT_RED   , BLACK , LT_BLUE  , PURPLE   ; demo   .hbu007.
                            
TabSpriteColorSet_001       .byte WHITE , BLACK , CYAN     , CYAN     , CYAN     , BLACK , CYAN     , CYAN     ; 001    .hbu007.
TabSpriteColorSet_002       .byte WHITE , BLACK , YELLOW   , LT_GREEN , LT_RED   , BLACK , LT_BLUE  , CYAN     ; 002-009.hbu007.
TabSpriteColorSet_003       .byte WHITE , BLACK , CYAN     , YELLOW   , PURPLE   , BLACK , LT_BLUE  , ORANGE   ; 010-019.hbu007.
TabSpriteColorSet_004       .byte WHITE , BLACK , CYAN     , PURPLE   , LT_BLUE  , BLACK , LT_GREEN , GREY     ; 020-029.hbu007.
TabSpriteColorSet_005       .byte WHITE , BLACK , YELLOW   , LT_BLUE  , LT_RED   , BLACK , LT_GREEN , CYAN     ; 030-039.hbu007.
TabSpriteColorSet_006       .byte WHITE , BLACK , PURPLE   , YELLOW   , CYAN     , BLACK , ORANGE   , GREY     ; 040-049.hbu007.
TabSpriteColorSet_007       .byte WHITE , BLACK , ORANGE   , LT_GREEN , YELLOW   , BLACK , CYAN     , GREY     ; 050-059.hbu007.
TabSpriteColorSet_008       .byte WHITE , BLACK , YELLOW   , PURPLE   , LT_RED   , BLACK , CYAN     , LT_BLUE  ; 060-069.hbu007.
TabSpriteColorSet_009       .byte WHITE , BLACK , LT_BLUE  , YELLOW   , PURPLE   , BLACK , LT_GREEN , CYAN     ; 070-079.hbu007.
TabSpriteColorSet_010       .byte WHITE , BLACK , LT_RED   , CYAN     , YELLOW   , BLACK , PURPLE   , GREY     ; 080-089.hbu007.
TabSpriteColorSet_011       .byte WHITE , BLACK , LT_RED   , LT_BLUE  , PURPLE   , BLACK , CYAN     , LT_GREEN ; 090-099.hbu007.
TabSpriteColorSet_012       .byte WHITE , BLACK , LT_GREEN , YELLOW   , LT_BLUE  , BLACK , CYAN     , ORANGE   ; 100-109.hbu007.
TabSpriteColorSet_013       .byte WHITE , BLACK , PURPLE   , LT_GREEN , CYAN     , BLACK , LT_RED   , YELLOW   ; 110-119.hbu007.
TabSpriteColorSet_014       .byte WHITE , BLACK , CYAN     , PURPLE   , LT_GREEN , BLACK , YELLOW   , GREY     ; 120-129.hbu007.
TabSpriteColorSet_015       .byte WHITE , BLACK , YELLOW   , LT_BLUE  , PURPLE   , BLACK , CYAN     , ORANGE   ; 130-139.hbu007.
TabSpriteColorSet_016       .byte WHITE , BLACK , LT_BLUE  , LT_GREEN , LT_RED   , BLACK , CYAN     , GREY     ; 140-149.hbu007.
TabSpriteColorSet_017       .byte WHITE , BLACK , PURPLE   , LT_RED   , YELLOW   , BLACK , CYAN     , LT_GREEN ; 150-159.hbu007.
TabSpriteColorSet_018       .byte WHITE , BLACK , CYAN     , YELLOW   , LT_BLUE  , BLACK , ORANGE   , GREY     ; 160-169.hbu007.
TabSpriteColorSet_019       .byte WHITE , BLACK , YELLOW   , CYAN     , PURPLE   , BLACK , LT_GREEN , ORANGE   ; 170-179.hbu007.
TabSpriteColorSet_020       .byte WHITE , BLACK , YELLOW   , CYAN     , LT_BLUE  , BLACK , PURPLE   , LT_RED   ; 180-189.hbu007.
TabSpriteColorSet_021       .byte WHITE , BLACK , LT_BLUE  , CYAN     , LT_RED   , BLACK , PURPLE   , GREY     ; 190-199.hbu007.
TabSpriteColorSet_022       .byte WHITE , BLACK , YELLOW   , LT_RED   , LT_GREEN , BLACK , CYAN     , ORANGE   ; 200-209.hbu007.
TabSpriteColorSet_023       .byte WHITE , BLACK , CYAN     , YELLOW   , PURPLE   , BLACK , LT_GREEN , LT_BLUE  ; 210-219.hbu007.
TabSpriteColorSet_024       .byte WHITE , BLACK , CYAN     , YELLOW   , LT_RED   , BLACK , LT_BLUE  , CYAN     ; 220-229.hbu007.
TabSpriteColorSet_025       .byte WHITE , BLACK , LT_BLUE  , LT_GREEN , YELLOW   , BLACK , CYAN     , PURPLE   ; 230-239.hbu007.
TabSpriteColorSet_026       .byte WHITE , BLACK , LT_RED   , LT_GREEN , YELLOW   , BLACK , CYAN     , ORANGE   ; 240-250.hbu007.

TabSpriteColorSets_Entries  = * - TabSpriteColorSet_026 - $01 ; number of sprite colors per row                ;        .hbu007.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameColorSprites          Does    : set the sprite colors for this level
;                           Expects : .X=color table offset 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameColorSprites           .block                           ; 
                            txa                             ; get table offset                                          .hbu007.
                            asl                             ; *2                                                        .hbu007.
                            asl                             ; *4                                                        .hbu007.
                            asl                             ; *8 - 8 sprite entries per table row                       .hbu007.
                            sta HL_EnemyColorTabRowNum      ; save actual enemy color set number for rebirth            .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; set offset to end of sprite color set
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ;                                                           .hbu007.
                            adc #TabSpriteColorSets_Entries ; add max nmber of sprite color row entries                 .hbu007.
                            tax                             ; set table offset to end of table row                      .hbu007.
                            
                            ldy #TabSpriteColorSets_Entries ; get max sprite count                                      .hbu007.
GetNextSpriteColor          lda TabSpriteColorSets,x        ; get an sprite color table entry                           .hbu007.
                            sta SP0COL,y                    ; recolor next sprite                                       .hbu007.
                            
                            dex                             ; set offset next enemy color tab entry                     .hbu007.
                            
                            dey                             ; dec enemy sprite count                                    .hbu007.
                            bpl GetNextSpriteColor          ; check: min - no: continue                                 .hbu007.
                            
                            rts                             ;                                                           .hbu007.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; NMI                       Does    : NMI interrupt
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
NMI                        .block                           ; 
                            rti                             ; nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteNum           = *       ; 
                            .byte $01 ; .......# - $00 - bit0 = loderunner
                            .byte $05 ; .....#.# - $01
                            .byte $0d ; ....##.# - $02
                            .byte $1d ; ...###.# - $03
                            .byte $5d ; .#.###.# - $04
                            .byte $dd ; ##.###.# - $05
; --------------------------------------------------------------------------------------------------------------------- ;
TabLodeRuWaitShade          = *           ;                                                                             .hbu013.
                            .byte WHITE   ;                                                                             .hbu013.
                            .byte WHITE   ;                                                                             .hbu013.
                            .byte LT_GREY ;                                                                             .hbu013.
                            .byte GREY    ;                                                                             .hbu013.
                            .byte DK_GREY ;                                                                             .hbu013.
                            .byte DK_GREY ;                                                                             .hbu013.
                            .byte GREY    ;                                                                             .hbu013.
                            .byte LT_GREY ;                                                                             .hbu013.
                            .byte WHITE   ;                                                                             .hbu013.
TabLodeRuWaitShade_Len       = * - TabLodeRuWaitShade ;                                                                 .hbu013. 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_Start                 Does    : board editor: start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_Start                  .block                           ; 
                            lda #$00                        ; get initial value
                            sta HL_Score_Lo                 ; ini score 
                            sta HL_Score_Mid_Lo             ; 
                            sta HL_Score_Mid_Hi             ; 
                            sta HL_Score_Hi                 ; 
                            
                            sta HL_ModeDebug                ; ini HL_ModeDebug_Off                                      .hbu022.
                            sta EXTCOL                      ; VIC($D020) Border Color - revert a possible Debug color   .hbu022.
                            
                            lda #HL_LevelReload_Force       ; get flag force level reload
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk
                            
                            lda #$05                        ; get initial value
                            sta HL_NumLives                 ; ini live count ($05) 
                            sta HL_GameMode                 ; ini game mode - $00=start $01=demo $02=play $05=edit
                            sta HL_SpriteShow               ; ini HL_SpriteShow_Off
                            
;                           lda HL_ControllerType           ; get controller type                                       .hbu012. removed
;                           sta BED_PlayLevel.smControllerType ; set tpye                                               .hbu012. removed
                            
;                           lda #HL_ControllerType_Keyboard ; get keyboard                                              .hbu012. removed
;                           sta HL_ControllerType           ; set keyboard                                              .hbu012. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; switch off special modes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ModeRnd_Off             ; get intial value                                          .hbu021.
                            sta HL_ModeRnd                  ; set HL_ModeRnd_Off                                        .hbu021.
                            
                            lda #HL_ModeMirror_Off          ; get intial value                                          .hbu018.
                            sta HL_ModeMirror               ; set HL_ModeMirror_Off                                     .hbu018.
                            
ChckLevelNum                lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            cmp #HL_LevelNumDisk_Max + $01  ; test max level number passed
                            bcc BED_Init                    ; check: LT - no: bypass level number reset
                            
ResetLevelNum               lda #HL_LevelNumDisk_Min        ; get initial value
                            sta HL_LevelNumDisk             ; ini disk level num (000-249)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_InitScreen            Does    : board editor: clear screen and init
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_InitScreen             .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; get editor hires color
                            ldx #HR_CYAN_RED                ; hires color status line                                   .hbu002.
                            ldy #WHITE                      ; COLORAM color                                             .hbu002.
                            jsr ColorLevelHandler           ; fill game level screen with the selected colors           .hbu002.
                            
                            lda #>HL_ScreenGfxDisplay       ; get address display screen HI
                            sta HLZ_TargetGfxOutput         ; set target output indicator $20=$2000 $40=$4000
                            
                            lda #$00                        ; get initial value
                            sta HL_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosHome           ;                                                           .hbu010.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;   LODE RUNNER BOARD EDITOR
                            .byte " " | $80 ; <SHIFT_SPACE> ; ----------------------------
                            .byte "l" | $80 ;               ;  R/S KEY ABORTS ANY COMMAND
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ;                                                           .hbu020.
                           .bend                            ;                                                           .hbu020.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_Init                  Does    : board editor: clear screen and init
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_Init                   .block                           ; 
                            jsr BED_InitScreen              ; initialize the board editor command input screen          .hbu020.
                           .bend                            ;                                                           .hbu020.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandCheck          Does    : board editor: care for a valid command input and exec the appropriate routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandCheck           .block                           ; 
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #HLZ_ScreenRow_BED_Input_Max; test max input row                                        .hbu020.
;                           bcs BED_Init                    ; check: GE - yes: clear screen and init the board editor   .hbu020. removed
                            bcc OutCmdPrompt                ; check: LT - yes: ouput next cmd prompt                    .hbu020.
                            
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu020.
                            lda #$03                        ;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu020.
                            lda #$00                        ;                                                           .hbu020.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu020.
                            
OutCmdPrompt                jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "c" | $80 ;               ; COMMAND>
                            .byte "o" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
GetNextCmdTabEntry          ldy TabBED_CmdChar,x            ; get next command table entry
                            beq BED_CommandError            ; check: EoT - yes: command invalid - error beep and wait for next command
                            
                            cmp TabBED_CmdChar,x            ; test valid command table entry
                            beq BED_CommandExec             ; check: EQ - yes: found one
                            
                            inx                             ; inc command table offset
                            bne GetNextCmdTabEntry          ; always (hopefully)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandError          Does    : board editor: error beep and wait for next command
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandError           .block                           ; 
                            jsr EditorErrorBeep             ; output an error beep signal
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandExec           Does    : board editor: dispatch the selected command routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandExec            .block                           ; 
                            txa                             ; 
                            asl a                           ; *2
                            tax                             ; 
                            
                            lda TabBED_CmdAddress + $01,x   ; get adr board editor cmd HI
                            pha                             ; push on stack
                            lda TabBED_CmdAddress + $00,x   ; get adr board editor cmd LO
                            pha                             ; push on stack
                            
                            rts                             ; call edit command routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; board editor commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_CmdChar              = *       ; 
                            .byte $29 ; p - Play  a level
;                           .byte $14 ; c - Clear a level                                                               .hbu039. removed
                            .byte $0e ; e - Edit  a level
                            .byte $24 ; m - Move  a level
                            .byte $17 ; x - Swap  a level                                                               .hbu017.
;                           .byte $21 ; i - Init disk                                                                   .hbu039. removed
                            .byte $0d ; s - Show  scores                                                                .hbu014.
                            
                            .byte $a1 ; I - Init a disk                                                                 .hbu039.
                            .byte $94 ; C - Clear a disk level                                                          .hbu039.
                            .byte $8d ; S - Clear the disk save games                                                   .hbu039.
                            .byte $aa ; L - Clear the disk leaderboard                                                  .hbu039.
                            .byte $96 ; T - Clear the disk best times                                                   .hbu039.
                            
                            .byte $00 ; end of edit commands marker
; --------------------------------------------------------------------------------------------------------------------- ;
; board editor command routines
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_CmdAddress           = * ; 
                            .word BED_LevelPlay  - $01 ; play a selected game level from editor
                            .word BED_LevelEdit  - $01 ; edit a selected game level
                            .word BED_LevelMove  - $01 ; move a selected game level
                            .word BED_LevelSwap  - $01 ; swap two selected game levels                                  .hbu017.
                            .word BED_ScoreShow  - $01 ; show leaderboard from disk                                     .hbu014.
                            
                            .word BED_DiskInit   - $01 ; init all level data/high score data/time data on disk          .hbu039.
                            .word BED_LevelClear - $01 ; clear a selected disk level                                    .hbu039.
                            .word BED_SavesClear - $01 ; clear level save entries on disk                               .hbu039.
                            .word BED_ScoreClear - $01 ; clear leaderboard on disk                                      .hbu039.
                            .word BED_TimesClear - $01 ; clear level best times on disk                                 .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelPlay             Does    : board editor: play a selected game level from editor
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelPlay              .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>PLAY LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelPlayX_Bad          ; check: error - yes: beep and get next command
                            
;smControllerType           = * + $01                       ;                                                           .hbu012. removed 
                            lda #HL_ControllerType_Joystick ; get controller                                            .hbu012.
                            sta HL_ControllerType           ; set controller
                            
                            lda #HL_GameMode_PlayFromEdit   ; get play from edit mode
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit
                            
;                           lda #HL_Cheated_No              ; get flag not cheated                                      .hbu022. removed
;                           sta HL_Cheated                  ; set flag not cheated                                      .hbu022. removed
                            
                            lda #HL_SpriteShow_On           ; get show sprites
                            sta HL_SpriteShow               ; set show sprites
; --------------------------------------------------------------------------------------------------------------------- ;
; check for 1st level
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            beq BED_LevelPlayX_Good         ; check: 1st level - yes: no cheating
; --------------------------------------------------------------------------------------------------------------------- ;
; set cheat flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_Cheated_Yes             ; get flag not cheated
                            sta HL_Cheated                  ; set flag not cheated
                            beq BED_LevelPlayX              ; always                                                    .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset debug flag
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelPlayX_Good         lda #HL_ModeDebugUsed_No        ; get initial value                                         .hbu022.
                            sta HL_ModeDebugUsed            ; set flag no debug mode used                               .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset cheat flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_Cheated_No              ; get flag not cheated                                      .hbu022.
                            sta HL_Cheated                  ; set flag not cheated                                      .hbu022.
                            
BED_LevelPlayX              jmp GameStart                   ; start game preparations and play selected level
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelPlayX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelClear            Does    : board editor: clear a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelClear             .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>CLEAR LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ;
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelClearX_Bad         ; check: error - yes: beep and get next command
                            
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            ldy #$00                        ; ini offset to level data
                            tya                             ; get NumTile_Empty        
ClearNextLevelDataByte      sta HL_LevelDataBuf,y           ; set get clear level store
                            
                            iny                             ; inc offset to level data
                            bne ClearNextLevelDataByte      ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init level data with a loderunner tile to ease the Board Editor start
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty | HL_TileNum_LodeRunner ;  get a loderunner tile                      .hbu037.
                            sta HL_LevelDataBuf             ; fill in the loderunner tile - allows an easy edit start   .hbu037.
                            
                            lda #HL_DiskWrite               ; get flag disk write
                            jsr DiskOperationHandler        ; write cleared level to disk
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelClearX_Bad         jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelEdit             Does    : board editor: edit a level
;                           Expects : 
;                           Returns : honz
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelEdit              .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>EDIT LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; comment out and re-asm check to allow edit of hidden level 251
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelEditX_Bad          ; check: error - yes: beep and get next command
                            
                            jsr BED_CheckDiskType           ; check loderunner user data disk                           .hbu020.
                            jsr ScreenDisplayClear          ; clear display grafic screen                               .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; init the data modification flag directly at editor start
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HLZ_LevelModified_No       ; get flag level data not modified                          .hbu019.
                            stx HLZ_LevelModified           ; ini edit status                                           .hbu019.
                            
                            jmp LED_Start                   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelEditX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelMove             Does    : board editor: move a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelMove              .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>MOVE LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid source level number
                            bcs BED_LevelMoveX_Bad          ; check: error - yes: beep and get next command
                            
                            sty TabBED_SaveMoveLevelSource  ; save source level number
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;  TO LEVEL
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid target level number
                            bcs BED_LevelMoveX_Bad          ; check: error - yes: beep and get next command
                            
                            sty TabBED_SaveMoveLevelTarget  ; save target level number
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ;   SOURCE DISKETTE
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; read source level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            lda TabBED_SaveMoveLevelSource  ; get source level number
                            sta HL_LevelNumDisk             ; set disk level num (000-249) 
                            
                            lda #HL_DiskRead                ; get flag disk read
                            jsr DiskOperationHandler        ; read block from source disk location
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ;   DESTINATION DISKETTE
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; write target level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            lda TabBED_SaveMoveLevelTarget  ; get target level number
                            sta HL_LevelNumDisk             ; set disk level num (000-249) 
                            
                            lda #HL_DiskWrite               ; get flag disk write
                            jsr DiskOperationHandler        ; write block to taget disk location
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelMoveX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_DiskInit              Does    : board editor: initialize a user level disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_DiskInit               .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu020.
                            
                            lda #$06                        ;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu020.
                            lda #$09                        ;                                                           .hbu020.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu020.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "i" | $80 ;               ;          INITIALIZE                                       .hbu020.
                            .byte "n" | $80 ;               ;           PREPARES                                        .hbu020.
                            .byte "i" | $80 ;               ;  AN ALREADY FORMATTED DISK                                .hbu020.
                            .byte "t" | $80 ;               ;   FOR USER CREATED LEVELS                                 .hbu020.
                            .byte "i" | $80 ;               ; OLD DATA WILL BE DESTROYED!                               .hbu020.
                            .byte "a" | $80 ;               ;    ARE YOU SURE (Y/N)                                     .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "z" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "p" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "p" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "f" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "m" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "k" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "f" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "c" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "v" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "w" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "b" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "!" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "(" | $80 ;               ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "/" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte ")" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            
                            .byte $00 ; EndOfText                                                                       .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
                            cmp #$19                        ; test "Y"
                            bne BED_DiskInitX               ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; check master disk - not modifiable
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #HL_ScoreBufCheck_Mod_No    ; test disk is a master disk
                            bne IniDiskLevelInit            ; check: EQ - no: start initializing
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
;                           jmp BED_Init                    ; clear screen and init the board editor                    .hbu020. removed
                            jmp BED_DiskInitX               ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize disk
; --------------------------------------------------------------------------------------------------------------------- ;
IniDiskLevelInit            lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            pha                             ; save actual level number
                            
                            lda #HL_DiskInit                ; get flag disk init
                            jsr DiskOperationHandler        ; init a level disk
                            
                            pla                             ; restore actual level number
                            sta HL_LevelNumDisk             ; set disk level num (000-249) 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_DiskInitX               lda #HLZ_ScreenRow_BED_Input_Max;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu020.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu020.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu020.
                            
;                           jmp BED_Init                    ; clear screen and init the board editor                    .hbu020. removed
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu020.
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                           
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelSwap             Does    : board editor: swap two levels
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelSwap              .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu017.
                            .byte ">" | $80 ;               ; >>SWAP LEVEL                                              .hbu017.
                            .byte ">" | $80 ;               ;                                                           .hbu017.
                            .byte "s" | $80 ;               ;                                                           .hbu017.
                            .byte "w" | $80 ;               ;                                                           .hbu017.
                            .byte "a" | $80 ;               ;                                                           .hbu017.
                            .byte "p" | $80 ;               ;                                                           .hbu017.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu017.
                            .byte "l" | $80 ;               ;                                                           .hbu017.
                            .byte "e" | $80 ;               ;                                                           .hbu017.
                            .byte "v" | $80 ;               ;                                                           .hbu017.
                            .byte "e" | $80 ;               ;                                                           .hbu017.
                            .byte "l" | $80 ;               ;                                                           .hbu017.
                             
                            .byte $00 ; EndOfText                                                                       .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; get source level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid source level number                           .hbu017.
                            bcs GoSwapLevelsBeep            ; check: bad level number - yes                             .hbu017.
                            
                            sty HL_MoveLevelNumSource       ; save source level number                                  .hbu017.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu017.
                            .byte " " | $80 ; <SHIFT_SPACE> ;   WITH LEVEL                                              .hbu017.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu017.
                            .byte "w" | $80 ;               ;                                                           .hbu017.
                            .byte "i" | $80 ;               ;                                                           .hbu017.
                            .byte "t" | $80 ;               ;                                                           .hbu017.
                            .byte "h" | $80 ;               ;                                                           .hbu017.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu017.
                            .byte "l" | $80 ;               ;                                                           .hbu017.
                            .byte "e" | $80 ;               ;                                                           .hbu017.
                            .byte "v" | $80 ;               ;                                                           .hbu017.
                            .byte "e" | $80 ;               ;                                                           .hbu017.
                            .byte "l" | $80 ;               ;                                                           .hbu017.
                            
                            .byte $00 ; EndOfText                                                                       .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; get target level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid target level number                           .hbu017.
                            bcs GoSwapLevelsBeep            ; check: bad level number - yes                             .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; be sure that both numbers are not equal
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HL_MoveLevelNumSource       ; test with saved source level number                       .hbu017.
                            beq GoSwapLevelsBeep            ; check. EQ - yes: error                                    .hbu017.
                            
                            sty HL_MoveLevelNumTarget       ; save target level number                                  .hbu017.
                            jmp CheckDisk                   ;                                                           .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; wrong input number error
; --------------------------------------------------------------------------------------------------------------------- ;
GoSwapLevelsBeep            jmp BED_CommandError            ;                                                           .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDisk                   jsr BED_CheckDiskType           ; check if loderunner user data disk                        .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; read in target level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_MoveLevelNumTarget       ; get saved target level number                             .hbu017.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu017.
                            
                            lda #>HL_BufSwapWork            ; get target buffer address HI                              .hbu017.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; set buffer pointer to store target level data  .hbu017.
                            
                            lda #HL_DiskRead                ; get flag read score from disk                             .hbu017.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu017.
                            
                            lda #>HL_LevelDataBuf           ;                                                           .hbu017.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; reset buffer pointer                           .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; read in source level data                                                                                             .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_MoveLevelNumSource       ; get saved source level number                             .hbu017.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu017.
                            
                            lda #HL_DiskRead                ; get flag read score from disk                             .hbu017.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; write target level data to disk                                                                                       .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_MoveLevelNumTarget       ; saved target level number                                 .hbu017.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu017.
                            
                            lda #HL_DiskWrite               ; get flag write block to disk                              .hbu017.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
; write source level data to disk                                                                                       .hbu017.
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_MoveLevelNumSource       ; get saved source level number                             .hbu017.
                            sty HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu017.
                            dey                             ;                                                           .hbu017.
                            sty HL_LevelReload              ; force a level reload if <> HL_LevelNumDisk                .hbu017.
                            
                            lda #>HL_BufSwapWork            ;                                                           .hbu017.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; set buffer ptr to store target level data    .hbu017.
                            
                            lda #HL_DiskWrite               ; get flag write block to disk                              .hbu017.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu017.
                            
                            lda #>HL_LevelDataBuf           ;                                                           .hbu017.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; reset buffer pointer                         .hbu017.
                            
                            jmp BED_CommandCheck            ; wait for next command                                     .hbu017.
                           .bend                            ;                                                           .hbu017.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ScoreShow             Does    : board editor: show the leaderboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ScoreShow              .block                           ; 
                            jsr ScoreShowLeaderboard        ; show the leaderboard of 10 entries                        .hbu014.
                            jsr LED_CursorPosStatus         ; place cursor                                              .hbu014.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            
                            .byte $00 ; EndOfText                                                                       .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_MsgTextHitAnyKey         ; show the message text 'HIT A KEY TO CONTINUE'            .hbu014.
                            
                            jmp BED_Start                   ;                                                           .hbu014.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ScoreClear            Does    : board editor: clear the leaderboard entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ScoreClear             .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu020.
                            
                            lda #$06                        ;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu020.
                            lda #$03                        ;                                                           .hbu020.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu020.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "c" | $80 ;               ;    CLEAR THE LEADERBOARD                                  .hbu020.
                            .byte "l" | $80 ;               ;  ALL EXISTING SCORE ENTRIES                               .hbu020.
                            .byte "e" | $80 ;               ;      WILL BE DELETED!                                     .hbu020.
                            .byte "a" | $80 ;               ;    ARE YOU SURE (Y/N)                                     .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "h" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "b" | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "x" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "g" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "c" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "w" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "b" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "!" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "(" | $80 ;               ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "/" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte ")" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
                            cmp #$19                        ; test "Y"
                            bne BED_ScoreClearX             ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #HL_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            beq ErrorMsgDiskUnknown         ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; clear leaderboard buffer entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get HI scores buffer offset                               .hbu029.
                            tya                             ; get buffer init value                                     .hbu029.
ClearNextEntryByte          sta HL_ScoreBuf,y               ; set clear byte                                            .hbu029.
                            
                            iny                             ; dec leaderboard buffer offset                             .hbu029.
                            cpy #<HL_ScoreBufDiskId         ; test max                                                  .hbu029.
                            bne ClearNextEntryByte          ; check: EQ - no: continue                                  .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
; write fresh leaderboard to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskWrite | HL_DiskForce_Score ; write with flag force score processing             .hbu016.
                            jsr ScoreDiskHandler            ; write out the leaderboard block
;                           jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu020. removed
                            jmp BED_ScoreClearX             ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
ErrorMsgDiskUnknown         jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
; --------------------------------------------------------------------------------------------------------------------- ;
; force init command screen
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ScoreClearX             lda #HLZ_ScreenRow_BED_Input_Max;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu020.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu020.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu020.
                            
;                           jmp BED_Init                    ; clear screen and init the board editor                    .hbu020. removed
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_SavesClear            Does    : board editor: clear level save entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_SavesClear             .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu028.
                            
                            lda #$06                        ;                                                           .hbu028.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu028.
                            lda #$03                        ;                                                           .hbu028.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu028.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "c" | $80 ;               ;   CLEAR GAME SAVE RECORDS                                 .hbu028.
                            .byte "l" | $80 ;               ;  ALL EXISTING SAVE ENTRIES                                .hbu028.
                            .byte "e" | $80 ;               ;      WILL BE DELETED!                                     .hbu028.
                            .byte "a" | $80 ;               ;    ARE YOU SURE (Y/N)                                     .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "v" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "c" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "x" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "v" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "w" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "b" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "!" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "u" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "u" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "(" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte "/" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte ")" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player                            .hbu028.
                            
                            cmp #$19                        ; test "Y"                                                  .hbu028.
                            bne BED_SavesClearX             ; check: EQ - no                                            .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu028.
                            jsr ScoreDiskHandler            ; read in the leaderboard block                             .hbu028.
                            
                            cmp #HL_ScoreBufCheck_Bad       ; test no loderunnner disk ID found                         .hbu028.
                            bne InitSavesBlocks             ; check: NE - yes: correct disk in drive                    .hbu028.

ErrorMsgDiskUnknown         jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; init and write fresh time blocks to disk
; --------------------------------------------------------------------------------------------------------------------- ;
InitSavesBlocks             jsr GameStorageBlockClear       ; init level save entries                                   .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; force init command screen
; --------------------------------------------------------------------------------------------------------------------- ;
BED_SavesClearX             lda #HLZ_ScreenRow_BED_Input_Max;                                                           .hbu028.
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu028.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu028.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu028.
                            
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_TimesClear            Does    : board editor: clear level best times
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_TimesClear             .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu039.
                            
                            lda #$06                        ;                                                           .hbu039.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu039.
                            lda #$03                        ;                                                           .hbu039.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu039.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "c" | $80 ;               ;    CLEAR LEVEL BEST TIMES                                 .hbu039.
                            .byte "l" | $80 ;               ;  ALL EXISTING TIME ENTRIES                                .hbu039.
                            .byte "e" | $80 ;               ;      WILL BE DELETED!                                     .hbu039.
                            .byte "a" | $80 ;               ;    ARE YOU SURE (Y/N)                                     .hbu039.
                            .byte "r" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "v" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ;               ;                                                           .hbu039.
                            .byte "b" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "s" | $80 ;               ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "m" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "s" | $80 ;               ;                                                           .hbu039.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu039.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "a" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "x" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "s" | $80 ;               ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "n" | $80 ;               ;                                                           .hbu039.
                            .byte "g" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "m" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "n" | $80 ;               ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte "r" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "s" | $80 ;               ;                                                           .hbu039.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "w" | $80 ;               ;                                                           .hbu039.
                            .byte "i" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "b" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "d" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "l" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "t" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte "d" | $80 ;               ;                                                           .hbu039.
                            .byte "!" | $80 ;               ;                                                           .hbu039.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu039.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "a" | $80 ;               ;                                                           .hbu039.
                            .byte "r" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "y" | $80 ;               ;                                                           .hbu039.
                            .byte "o" | $80 ;               ;                                                           .hbu039.
                            .byte "u" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "s" | $80 ;               ;                                                           .hbu039.
                            .byte "u" | $80 ;               ;                                                           .hbu039.
                            .byte "r" | $80 ;               ;                                                           .hbu039.
                            .byte "e" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            .byte "(" | $80 ;               ;                                                           .hbu039.
                            .byte "y" | $80 ;               ;                                                           .hbu039.
                            .byte "/" | $80 ;               ;                                                           .hbu039.
                            .byte "n" | $80 ;               ;                                                           .hbu039.
                            .byte ")" | $80 ;               ;                                                           .hbu039.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu039.
                            
                            .byte $00 ; EndOfText                                                                       .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player                            .hbu039.
                            
                            cmp #$19                        ; test "Y"                                                  .hbu039.
                            bne BED_TimesClearX             ; check: EQ - no                                            .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu039.
                            jsr ScoreDiskHandler            ; read in the leaderboard block                             .hbu039.
                            
                            cmp #HL_ScoreBufCheck_Bad       ; test no loderunnner disk ID found                         .hbu039.
                            bne InitTimeBlocks              ; check: NE - yes: correct disk in drive                    .hbu039.

ErrorMsgDiskUnknown         jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
; --------------------------------------------------------------------------------------------------------------------- ;
; init and write fresh time blocks to disk
; --------------------------------------------------------------------------------------------------------------------- ;
InitTimeBlocks              jsr GameTimeBlocksClear         ; init level record times                                   .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; force init command screen
; --------------------------------------------------------------------------------------------------------------------- ;
BED_TimesClearX             lda #HLZ_ScreenRow_BED_Input_Max;                                                           .hbu039.
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu039.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu039.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu039.
                            
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu039.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelTest             Does    : level editor: test the edited level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelTest              .block                           ; 
                            jsr LED_CursorPosSave           ; save actual cursor position                               .hbu019.
                            
                            lda #HL_LevelTest_On            ; get flag test level                                       .hbu019.
                            sta HL_LevelTest                ; set test level mode                                       .hbu019.
                            
                            lsr HL_Cheated                  ; set HL_Cheated_Yes                                        .hbu019.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu019.
                            sta HLZ_TargetGfxOutput         ; target output  $20=$2000 $40=$4000                        .hbu019.
                            
                            lda #HL_GameMode_PlayFromEdit   ; get flag play from edit                                   .hbu019.
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit      .hbu019.
                            
                            lda #$00                        ; get initial value                                         .hbu019.
                            sta HL_KeyNew                   ; discard key input                                         .hbu019.
                            sta HL_ScoreShown               ; HL_ScoreShown_No                                          .hbu019.
                            sta HL_SpriteShow               ; HL_SpriteShow_On                                          .hbu019.
                            
                            lda #$00                        ; get initial value                                         .hbu019.
                            sta HL_GameSpeedCtrl            ;                                                           .hbu019.
                            sta HL_EnemyBirthCol            ; reset birth col pointer                                   .hbu019.
                            
                            jsr GameLevelDataCompress       ; compress expanded level data only                         .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; avoid level data reload
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu019.
                            sta HL_LevelReload              ; force a level reload if <> HL_LevelNumDisk                .hbu019.
                            
                            jmp LevelStart                  ; play edited level                                         .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMirror           Does    : level editor: toggle level edit mirror mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMirror            .block                           ;                                                           .hbu018.
                            jsr LED_CursorPosSave           ; save current cursor position                              .hbu018.
                            jsr LED_MirrorLevel             ; mirror an already loaded level                            .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; back to level editor
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_Start_ExpandOnly        ; bypass editor init                                        .hbu018.
                           .bend                            ;                                                           .hbu018.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_MirrorLevel           Does    : mirror an already loaded level                                                    .hbu018.
;                           Expects :                                                                                   .hbu018.
;                           Returns :                                                                                   .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
LED_MirrorLevel            .block                           ;                                                           .hbu018.
                            lda #<HL_LevelDataBuf           ; init level data buffer pointer                            .hbu018.
                            sta smMirrorIn_Le               ;                                                           .hbu018.
                            sta smMirrorIn_Ri               ;                                                           .hbu018.
                            sta smMirrorOut_Le              ;                                                           .hbu018.
                            sta smMirrorOut_Ri              ;                                                           .hbu018.
                            
                            lda #HL_LevelDataBufDataRows - $01 ; get max level data rows                                .hbu018.
                            sta HL_MirrorRowCount           ; set level data row counter                                .hbu018.
                            
InitNextMirrorLevelCol      lda #(HL_LevelDataBufDataCols - $01) / $02 ; get number of bytes to be swapped              .hbu018.
                            sta HL_MirrorSwapCount          ; set number of bytes to be swapped                         .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; init right and left side column offsets
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_LevelDataBufDataCols - $01 ; get offset right side of row                           .hbu018.
                            ldx #$00                        ; get offset left side of row                               .hbu018.
                            
smMirrorIn_Le               = * + $01                       ;                                                           .hbu018.
GetNextMirrorLevelByte      lda HL_LevelDataBuf,x           ; get  left side byte                                       .hbu018.
                            pha                             ; save left side byte                                       .hbu018.
                            
smMirrorIn_Ri               = * + $01                       ;                                                           .hbu018.
                            lda HL_LevelDataBuf,y           ; get right side byte                                       .hbu018.
                            sta HL_MirrorByteDisk           ; set right side byte                                       .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; swap right side byte nibbles
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_MirrorByteDisk           ; shift left nibble right                                   .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            
                            asl                             ; shift right nibble left                                   .hbu018.
                            asl                             ;                                                           .hbu018.
                            asl                             ;                                                           .hbu018.
                            asl                             ;                                                           .hbu018.
                            
                            ora HL_MirrorByteDisk           ; insert new right nibble                                   .hbu018.
smMirrorOut_Le              = * + $01                       ;                                                           .hbu018.
                            sta HL_LevelDataBuf,x           ; store swapped right level byte to left side of row        .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; swap left side byte nibbles
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore left side byte                                    .hbu018.
                            sta HL_MirrorByteDisk           ; save left side byte                                       .hbu018.
                            
                            lsr HL_MirrorByteDisk           ; shift left nibble right                                   .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            lsr HL_MirrorByteDisk           ;                                                           .hbu018.
                            
                            asl                             ; shift right nibble left                                   .hbu018.
                            asl                             ;                                                           .hbu018.
                            asl                             ;                                                           .hbu018.
                            asl                             ;                                                           .hbu018.
                            
                            ora HL_MirrorByteDisk           ; insert new right nibble                                   .hbu018.
smMirrorOut_Ri              = * + $01                       ;                                                           .hbu018.
                            sta HL_LevelDataBuf,y           ; store swapped left level byte to right side of row        .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance columns offsets
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; dec offset right side                                     .hbu018.
                            inx                             ; inc offset left side                                      .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this row is complete
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_MirrorSwapCount          ; dec number of bytes to be swapped                         .hbu018.
                            bpl GetNextMirrorLevelByte      ; check: min - no: continue                                 .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the output pointer to the next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smMirrorOut_Le              ;                                                           .hbu018.
                            clc                             ;                                                           .hbu018.
                            adc #HL_LevelDataBufDataCols    ;                                                           .hbu018.
                            sta smMirrorIn_Le               ;                                                           .hbu018.
                            sta smMirrorIn_Ri               ;                                                           .hbu018.
                            sta smMirrorOut_Le              ;                                                           .hbu018.
                            sta smMirrorOut_Ri              ;                                                           .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the level data block is completely processed
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_MirrorRowCount           ; dec level data row counter                                .hbu018.
                            bpl InitNextMirrorLevelCol      ; check: min - no: continue                                 .hbu018.
                            
;                           lda #HLZ_LevelModified_Yes      ; get flag                                                  .hbu018.
;                           sta HLZ_LevelModified           ; set flag level data was modified                          .hbu018.
                            lsr HLZ_LevelModified           ; set flag HLZ_LevelModified_Yes                            .hbu018.
                            
                            rts                             ;                                                           .hbu018.
                           .bend                            ;                                                           .hbu018.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelClear            Does    : wipe out the edited level contents
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelClear             .block                           ; 
                            jsr LED_LevelClearHandler       ; write out the clear question and get an answer            .hbu035.
                            bcc IniClear                    ; check: answer was YES - yes: clear                        .hbu035.
                            
                            jsr StatusMsgTextShow           ; restore the level msg text or a default msg text          .hbu035.
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
; the answer was YES - clear the level data
; --------------------------------------------------------------------------------------------------------------------- ;
IniClear                    lda #$00                        ; get clear level value                                     .hbu035.
                            tay                             ; ini offset                                                .hbu035.
ClrNextBufferByte           sta HL_LevelDataBuf,y           ; clear a buffer byte                                       .hbu035.
                            
                            iny                             ;                                                           .hbu035.
                            cpy #HL_LevelDataBufData_Len    ;                                                           .hbu035.
                            bne ClrNextBufferByte           ;                                                           .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
; init level data with a bottom row loderunner to allow a sccessful level data expansion
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty | HL_TileNum_LodeRunner ;  get a loderunner tile                      .hbu035.
                            sta HL_LevelDataBuf + HL_LevelDataBufData_Len - HL_LevelDataBufDataCols ; set loderunner    .hbu035.
                            
                            jsr GameLevelDataExpand         ; expand the cleared data and display it                    .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor to the loderunner tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_ScreenRow_Max          ;                                                           .hbu035.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu035.
                            lda #HLZ_ScreenCol_Min          ;                                                           .hbu035.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu035.
                            
;                           lda #HLZ_LevelModified_Yes      ; get flag                                                  .hbu035.
;                           sta HLZ_LevelModified           ; set flag level data was modified                          .hbu035.
                            lsr HLZ_LevelModified           ; set flag HLZ_LevelModified_Yes                            .hbu018.
                            
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu035.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveUp           Does    : rotate level data one row upwards
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveUp            .block                           ; 
                            jsr LED_LevelMoveInit           ; init the work buffers and save the cursor pos             .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; save the top row data bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufDataCols - $01 ; ini row byte count                                     .hbu036.
GetNextLevelDataTopRowByte  lda HL_LevelDataBuf,x           ; get a top row level byte                                  .hbu036.
                            sta HL_BufRotateLevelData_01,x  ; save the top row level byte                               .hbu036.
                            dex                             ; dec row byte count                                        .hbu036.
                            bpl GetNextLevelDataTopRowByte  ; check: min - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move the level data bytes one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufDataCols    ; ini from offset - row #1                                  .hbu036.
                            ldy #$00                        ; ini to   offset - row #0                                  .hbu036.
GetNextLevelDataBlockByte   lda HL_LevelDataBuf,x           ; get the next level data byte                              .hbu036.
                            sta HL_LevelDataBuf,y           ; move the whole level data one row up                      .hbu036.
                            
                            iny                             ; inc to   offset                                           .hbu036.
                            inx                             ; inc from offset                                           .hbu036.
                            cpx #HL_LevelDataBufData_Len    ; test max from offset                                      .hbu036.
                            bne GetNextLevelDataBlockByte   ; check: EQ - no: continue                                  .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the old top row data bytes to the bottom row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufDataCols - $01 ; ini row byte count                                     .hbu036.
GetNextLevelDataBotRowByte  lda HL_BufRotateLevelData_01,x  ; get a bottom row level byte                               .hbu036.
                            sta HL_LevelDataBuf + HL_LevelDataBufData_Len - HL_LevelDataBufDataCols,x ; set it          .hbu036.
                            dex                             ; dec row byte count                                        .hbu036.
                            bpl GetNextLevelDataBotRowByte  ; check: min - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; expand and redisplay the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_LevelMoveFinish         ; redisplay level and set modified flag                     .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveDown         Does    : rotate level data one row downwards
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveDown          .block                           ; 
                            jsr LED_LevelMoveInit           ; init the work buffers and save the cursor pos             .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; save the bottom row data bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufDataCols - $01 ; ini row column byte count                              .hbu036.
GetNextLevelDataBotRowByte  lda HL_LevelDataBuf + HL_LevelDataBufData_Len - HL_LevelDataBufDataCols,x ; get bot byte    .hbu036.
                            sta HL_BufRotateLevelData_01,x  ; save the bottom row level byte                            .hbu036.
                            dex                             ; dec row byte count                                        .hbu036.
                            bpl GetNextLevelDataBotRowByte  ; check: min - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move the level data bytes one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufData_Len - HL_LevelDataBufDataCols - $01; ini from offset - 2nd last row.hbu036.
                            ldy #HL_LevelDataBufData_Len - $01 ; ini to offset - end of last row                        .hbu036.
GetNextLevelDataBlockByte   lda HL_LevelDataBuf,x           ; get the next level data byte                              .hbu036.
                            sta HL_LevelDataBuf,y           ; move the whole level data one row down                    .hbu036.
                            
                            dey                             ; dec to   offset                                           .hbu036.
                            dex                             ; dec from offset                                           .hbu036.
                            cpx #$ff                        ; test min from offset                                      .hbu036.
                            bne GetNextLevelDataBlockByte   ; check: NE - yes: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the old bottom row data bytes to the top row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelDataBufDataCols - $01 ; ini row byte count                                     .hbu036.
GetNextLevelDataTopRowByte  lda HL_BufRotateLevelData_01,x  ; get a bottom row level byte                               .hbu036.
                            sta HL_LevelDataBuf,x           ; save the new top row level byte                           .hbu036.
                            dex                             ; dec row byte count                                        .hbu036.
                            bpl GetNextLevelDataTopRowByte  ; check: min - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; expand and redisplay the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_LevelMoveFinish         ; redisplay level and set modified flag                     .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveLeft         Does    : rotate level data one column left      
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveLeft          .block                           ; 
; ----------------------------------------------------------------------------------------------
; the level data byte organization makes it a bit tricky to move the data one column to the left
; ----------------------------------------------------------------------------------------------
; 2 image numbers are condensed into one level buffer byte
;   the left  nybble holds the image number of the right screen position
;   the right nybble holds the image number of the left  screen position
; this reversed order makes a simple shift impossible and requires the following steps
; --------------------------------------------------------------------------------------------------------------------- ;
; 29 02 21 43 65 87 29 22 22 02 21 43 65 87  - split the starting row data into 2 rows of separate buffers
; --------------------------------------------------------------------------------------------------------------------- ;
; .9 .2 .1 .3 .5 .7 .9 .2 .2 .2 .1 .3 .5 .7  - 1st row buffer: isolate right nibble 
; 2. 0. 2. 4. 6. 8. 2. 2. 2. 0. 2. 4. 6. 8.  - 2nd row buffer: isolate left  nibble 
; 
; 9. 2. 1. 3. 5. 7. 9. 2. 2. 2. 1. 3. 5. 7.  - 1st rowbuffer: shift 4bit left 
; .2 .0 .2 .4 .6 .8 .2 .2 .2 .0 .2 .4 .6 .8  - 2nd rowbuffer: shift 4bit right
; 
; 2. 1. 3. 5. 7. 9. 2. 2. 2. 1. 3. 5. 7. 9.  - 1st row buffer: rotate all the bytes of each row one postion to the left
; 
; 2. 1. 3. 5. 7. 9. 2. 2. 2. 1. 3. 5. 7. 9.  - 1st row buffer: combine each byte with its 2nd row buffer counterpart
; .2 .0 .2 .4 .6 .8 .2 .2 .2 .0 .2 .4 .6 .8  - 2nd row buffer:
; --------------------------------------------------------------------------------------------------------------------- ;
; 22 10 32 54 76 98 22 22 22 10 32 54 76 98   - the resulting row data is shifted one postion to the left
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_LevelMoveInit           ; init the work buffers and save the cursor pos             .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; init work buffer #2 pointer for row rotation right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<HL_BufRotateLevelData_01  ; ini work buffer #1 pointer to one position right          .hbu036.
                            sta HLZ_WorkBufPtr_Lo           ;                                                           .hbu036.
                            lda #>HL_BufRotateLevelData_01  ;                                                           .hbu036.
                            sta HLZ_WorkBufPtr_Hi           ;                                                           .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; split level data into $10 single rows
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini level data offset                                     .hbu036.
                            ldy #$00                        ; ini column byte count                                     .hbu036.
GetNextLevelDataByte        lda HL_LevelDataBuf,x           ; get level data byte                                       .hbu036.
                            pha                             ; save level data byte                                      .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; isolate right nibble and shift it to the left
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; isolate right nibble                                      .hbu036.
                            asl                             ; shift to left nible                                       .hbu036.
                            asl                             ;                                                           .hbu036.
                            asl                             ;                                                           .hbu036.
                            asl                             ;                                                           .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move level buffer #1 row bytes one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta (HLZ_WorkBufPtr),y          ; set level buffer byte to work buffer #1 row               .hbu036.
                            
                            pla                             ; restore level data byte                                   .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; isolate left nibble and shift it to the right
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$f0                        ; isolate left nibble                                       .hbu036.
                            lsr                             ; shift to right nibble                                     .hbu036.
                            lsr                             ;                                                           .hbu036.
                            lsr                             ;                                                           .hbu036.
                            lsr                             ;                                                           .hbu036.
smWorkBuf2_Lo               = * + $01                       ;                                                           .hbu036.
                            sta HL_BufRotateLevelData_02 + $01,y ; set level buffer byte to work buffer #2 row          .hbu036.
                            
                            inx                             ; inc level data offset                                     .hbu036.
                            
                            iny                             ; inc column byte count                                     .hbu036.
                            cpy #HL_LevelDataBufDataCols    ; test $0e colum bytes                                      .hbu036.
                            bne GetNextLevelDataByte        ; check: max - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move 1st row byte to last row byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; set offset 1st level buffer row byte                      .hbu036.
                            lda (HLZ_WorkBufPtr),y          ; get 1st level buffer row byte                             .hbu036.
                            ldy #HL_LevelDataBufDataCols    ; get offset last level buffer row byte                     .hbu036.
                            sta (HLZ_WorkBufPtr),y          ; set 1st level buffer row byte as last                     .hbu036.
                            
                            ldy #$00                        ; ini column byte count                                     .hbu036.
                            lda #$ff                        ; get filler byte                                           .hbu036.
                            sta (HLZ_WorkBufPtr),y          ; set 1st level buffer byte to filler                       .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance buffer pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smWorkBuf2_Lo               ; get actual buffer #2 row start                            .hbu036.
                            clc                             ;                                                           .hbu036.
                            adc #$10                        ; add row offset                                            .hbu036.
                            sta smWorkBuf2_Lo               ; set next work buffer #2 row start                         .hbu036.
                            
                            lda HLZ_WorkBufPtr_Lo           ; get actual buffer #1 row start                            .hbu036.
                            clc                             ;                                                           .hbu036.
                            adc #$10                        ; add row offset                                            .hbu036.
                            sta HLZ_WorkBufPtr_Lo           ; set next work buffer #1 row start                         .hbu036.
                            bne GetNextLevelDataByte        ; check: $10 rows processed - no: continue                  .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; combine the shifted buffer bytes and copy them back to the level data buffer - each row now starts with $ff $ff
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini offset work  data buffers                             .hbu036.
                            ldy #$00                        ; ini offset level data buffer                              .hbu036.
CpyNextLevelDataByte        lda HL_BufRotateLevelData_01,x  ; get level buffer #1 value                                 .hbu036.
                            cmp #$ff                        ; test level row data filler value                          .hbu036.
                            beq IncBufferPointer            ; check: EQ - yes: overread                                 .hbu036.
                            
                            ora HL_BufRotateLevelData_02,x  ; ins level buffer #2 value                                 .hbu036.
                            sta HL_LevelDataBuf,y           ; write back to level data buffer                           .hbu036.
                            
                            iny                             ; inc offset work data buffers                              .hbu036.
                            
IncBufferPointer            inx                             ; inc offset level data buffer                              .hbu036.
                            bne CpyNextLevelDataByte        ; check: max - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; expand and redisplay the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_LevelMoveFinish         ; redisplay level and set modified flag                     .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveRight        Does    : rotate level data one column right     
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveRight         .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; the level data byte organization makes it a bit tricky to move the data one column to the right
; -----------------------------------------------------------------------------------------------
; 2 image numbers are condensed into one level buffer byte
;   the left  nybble holds the image number of the right screen position
;   the right nybble holds the image number of the left  screen position
; this reversed order makes a simple shift impossible and requires the following steps
; --------------------------------------------------------------------------------------------------------------------- ;
; 22 02 21 43 65 87 29 22 22 12 32 54 76 98  - split the starting row data into 2 rows of separate buffers
; --------------------------------------------------------------------------------------------------------------------- ;
; .2 .2 .1 .3 .5 .7 .9 .2 .2 .2 .2 .4 .6 .8  - 1st row buffer: isolate the right nibble
; 2. 0. 2. 4. 6. 8. 2. 2. 2. 1. 3. 5. 7. 9.  - 2nd row buffer: isolate the left  nibble
;                                           
; 2. 2. 1. 3. 5. 7. 9. 2. 2. 2. 2. 4. 6. 8.  - 1st row buffer: shift 4bit to the left
; .2 .0 .2 .4 .6 .8 .2 .2 .2 .1 .3 .5 .7 .9  - 2nd row buffer: shift 4bit to the right
;                                           
; .9 .2 .0 .2 .4 .6 .8 .2 .2 .2 .1 .3 .5 .7  - 2nd row buffer: rotate all the bytes of each row one postion to the right
;                                           
; 2. 2. 1. 3. 5. 7. 9. 2. 2. 2. 2. 4. 6. 8.  - 1st row buffer: combine each byte with its 2nd row buffer counterpart
; .9 .2 .0 .2 .4 .6 .8 .2 .2 .2 .1 .3 .5 .7  - 2nd row buffer: 
; --------------------------------------------------------------------------------------------------------------------- ;
; 29 22 10 32 54 76 98 22 22 22 21 43 65 87  - the resulting row data is shifted one postion to the right
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_LevelMoveInit           ; init the work buffers and save the cursor pos             .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; init work buffer #2 pointer for row rotation right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<HL_BufRotateLevelData_02 + $01 ; ini work buffer #2 pointer to one position right     .hbu036.
                            sta HLZ_WorkBufPtr_Lo           ;                                                           .hbu036.
                            lda #>HL_BufRotateLevelData_02  ;                                                           .hbu036.
                            sta HLZ_WorkBufPtr_Hi           ;                                                           .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; split level data into $10 single rows
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini level data offset                                     .hbu036.
                            ldy #$00                        ; ini column byte count                                     .hbu036.
GetNextLevelDataByte        lda HL_LevelDataBuf,x           ; get level data byte                                       .hbu036.
                            pha                             ; save level data byte                                      .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; isolate right nibble and shift it to the left
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; isolate right nibble                                      .hbu036.
                            asl                             ; shift to left nible                                       .hbu036.
                            asl                             ;                                                           .hbu036.
                            asl                             ;                                                           .hbu036.
                            asl                             ;                                                           .hbu036.
smWorkBuf1_Lo               = * + $01                       ;                                                           .hbu036.
                            sta HL_BufRotateLevelData_01,y  ; set level buffer byte to work buffer #1 row               .hbu036.
                            
                            pla                             ; restore level data byte                                   .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; isolate left nibble and shift it to the right
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$f0                        ; isolate left nibble                                       .hbu036.
                            lsr                             ; shift to right nibble                                     .hbu036.
                            lsr                             ;                                                           .hbu036.
                            lsr                             ;                                                           .hbu036.
                            lsr                             ;                                                           .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move level buffer #2 row bytes one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta (HLZ_WorkBufPtr),y          ; set level buffer byte to work buffer #2 row               .hbu036.
                            
                            inx                             ; inc level data offset                                     .hbu036.
                            
                            iny                             ; inc column byte count                                     .hbu036.
                            cpy #HL_LevelDataBufDataCols    ; test $0e colum bytes                                      .hbu036.
                            bne GetNextLevelDataByte        ; check: max - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; init move last row byte to 1st row byte - HLZ_WorkBufPtr_Lo needs to be reset to the 1st row position
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_WorkBufPtr_Lo           ; step level data buffer #2 ptr one position back           .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; move last row byte to 1st row byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_WorkBufPtr),y          ; get last level row data byte                              .hbu036.
                            pha                             ; sav last level row data byte                              .hbu036.
                            lda #$ff                        ; get clear value
                            sta (HLZ_WorkBufPtr),y          ; clear last level row data byte                            .hbu036.
                            
                            pla                             ; restore last level row data byte                          .hbu036.
                            ldy #$00                        ; ini column byte count                                     .hbu036.
                            sta (HLZ_WorkBufPtr),y          ; store last level row data byte as new 1st byte            .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; advance buffer pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ;                                                           .hbu036.
                            lda HLZ_WorkBufPtr_Lo           ; get work address low                                      .hbu036.
                            adc #$11                        ; add row offset                                            .hbu036.
                            sta HLZ_WorkBufPtr_Lo           ; set to next work buffer row                               .hbu036.
                            
                            lda smWorkBuf1_Lo               ; get work address low                                      .hbu036.
                            clc                             ;                                                           .hbu036.
                            adc #$10                        ; add row offset                                            .hbu036.
                            sta smWorkBuf1_Lo               ; set to next work buffer row                               .hbu036.
                            bne GetNextLevelDataByte        ; check: $10 rows processed - no: continue                  .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; combine the shifted buffer bytes and copy them back to the level data buffer - each row now ends with $ff $ff
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini offset work  data buffers                             .hbu036.
                            ldy #$00                        ; ini offset level data buffer                              .hbu036.
CpyNextLevelDataByte        lda HL_BufRotateLevelData_01,x  ; get level buffer #1 value                                 .hbu036.
                            cmp #$ff                        ; test level row data filler value                          .hbu036.
                            beq IncBufferPointer            ; check: EQ - yes: overread                                 .hbu036.
                            
                            ora HL_BufRotateLevelData_02,x  ; ins level buffer #2 value                                 .hbu036.
                            sta HL_LevelDataBuf,y           ; write back to level data buffer                           .hbu036.
                            
                            iny                             ; inc offset work  data buffers                             .hbu036.
                            
IncBufferPointer            inx                             ; inc offset level data buffer                              .hbu036.
                            bne CpyNextLevelDataByte        ; check: max - no: continue                                 .hbu036.
; --------------------------------------------------------------------------------------------------------------------- ;
; expand and redisplay the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_LevelMoveFinish         ; redisplay level and set modified flag                     .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveInit         Does    : initialize the two work buffers and save the cursor position                 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveInit          .block                           ; 
                            ldy #$00                        ; get count                                                 .hbu036.
                            lda #$ff                        ; get clear value                                           .hbu036.
ClrNextWorkBufByte          sta HL_BufRotateLevelData_01,y  ; clear buffers                                             .hbu036.
                            sta HL_BufRotateLevelData_02,y  ;                                                           .hbu036.
                            dey                             ; dec count                                                 .hbu036.
                            bne ClrNextWorkBufByte          ; check: min - no: continue                                 .hbu036.
                            
                            jmp LED_CursorPosSave           ; save the cursor positon and return                        .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelMoveFinish       Does    : expand and redisplay the new level data / set the level data modified flag
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelMoveFinish        .block                           ; 
                            ldx #HL_OutToScreenPrep_Yes     ; get flag force copy data to prepare hires screen          .hbu036
                            jsr GameLevelDataExpand         ; expand the cleared data and display it                    .hbu036.
                            jsr LED_CursorPosRestore        ; restore the cursor position                               .hbu036.
                            
;                           lda #HLZ_LevelModified_Yes      ; get flag                                                  .hbu036.
;                           sta HLZ_LevelModified           ; set flag level data was modified                          .hbu036.
                            lsr HLZ_LevelModified           ; set flag HLZ_LevelModified_Yes                            .hbu036.
                            
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu036.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorPosSave         Does    : save the actual cursor position
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorPosSave          .block                           ;                                                           .hbu009.
                            lda HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu009.
                            sta HL_ScreenColSave            ;                                                           .hbu009.
                            lda HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu009.
                            sta HL_ScreenRowSave            ;                                                           .hbu009.
                            
                            rts                             ;                                                           .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorPosRestore      Does    : restore the saved cursor position
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorPosRestore       .block                           ;                                                           .hbu009.
                            lda HL_ScreenRowSave            ;                                                           .hbu009.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu009.
                            lda HL_ScreenColSave            ;                                                           .hbu009.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu009.
                            
                            rts                             ;                                                           .hbu009.
                           .bend                            ;                                                           .hbu009.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorPosMsg          Does    : set cursor to message position
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorPosMsg           .block                           ;                                                           .hbu009.
                            lda #HL_StatusRowNum            ;                                                           .hbu009.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu009.
                            lda #HL_StatusRow_Col_Msg       ;                                                           .hbu009.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu009.
                            
                            rts                             ;                                                           .hbu009.
                           .bend                            ;                                                           .hbu009.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorPosStatus       Does    : set cursor to status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorPosStatus        .block                           ;                                                           .hbu009.
                            lda #HL_StatusRowNum            ;                                                           .hbu009.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu009.
                            lda #$00                        ;                                                           .hbu009.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu009.
                            
                            rts                             ;                                                           .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorPosHome         Does    : set cursor to top left screen corner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorPosHome          .block                           ;                                                           .hbu010.
                            lda #$00                        ;                                                           .hbu010.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu010.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu010.
                            
                            rts                             ;                                                           .hbu010.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Start                 Does    : level editor: start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Start                  .block                           ; 
                            lda #HL_ModeMirror_Off          ; reset a possible mirror mode                              .hbu018.
                            sta HL_ModeMirror               ;                                                           .hbu018.

                            jsr LED_CursorPosHome           ; int restore cursor position                               .hbu019.
                            jsr LED_CursorPosSave           ; save restore cursor position for RestoreCursorPos         .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Start_Recolor         Does    : level editor: return point from quit level test/reload level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Start_Recolor          .block                           ;                                                           .hbu019.
                            lda #HR_LT_BLUE_LT_RED          ; get hires color                                           .hbu018.
                            ldx #HR_CYAN_RED                ; hires color status line                                   .hbu002.
                            ldy #WHITE                      ; COLORAM color                                             .hbu002.
                            jsr ColorLevelHandler           ; fill game level screen with the selected colors           .hbu002.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu002.
                            sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000         .hbu002.
                            
                            jsr StatusAreaSetup             ; display baselines before level data                       .hbu002.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Start_ExpandOnly      Does    : level editor: expand and redisplay level data without init
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Start_ExpandOnly       .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; update level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>HL_ScreenGfxPrepare       ; get gfx prepare screen
                            sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit level without reload from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_OutToScreenPrep_Yes     ; get flag force copy data to prepare hires screen          .hbu020. enhanced 
                            jsr GameLevelDataExpand         ; expand compressed level disk data
                            bcc StatusOutMsgText            ; check: successful - yes
                            
                            jmp BED_CommandError            ; error beep and wait for next command
; --------------------------------------------------------------------------------------------------------------------- ;
; restore cursor position from init or from the last position after quit testing
; --------------------------------------------------------------------------------------------------------------------- ;
;IniCursorHome              jsr LED_CursorPosHome           ;                                                           .hbu010.hbu019. removed
StatusOutMsgText            jsr StatusMsgTextShow           ; output the level msg text or a default msg text           .hbu009.
RestoreCursorPos            jsr LED_CursorPosRestore        ; restore old cursor position                               .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_GetKey                Does    : level editor: main loop
;                                   : check input key for a valid tile number or a valid level editor command
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_GetKey                 .block                           ; 
WaitNextPlayerInputKey      jsr LED_WaitForInput            ; set data pointer/blink cursor/wait for input
; --------------------------------------------------------------------------------------------------------------------- ;
; get a level tile number $00-$09
; --------------------------------------------------------------------------------------------------------------------- ;
Checkinput                  jsr BED_CheckInputDigit         ; check if key pressed is a digit                           .hbu022.
                            bcs CheckLevelEditorCmd         ; check: was digit - no: might be an level editor command
; --------------------------------------------------------------------------------------------------------------------- ;
; save a valid level tile number $00-$09
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HLZ_ImageNumber             ; save level input tile ($00-$09)
; --------------------------------------------------------------------------------------------------------------------- ;
; get level data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if level data is same than input tile number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            lda HLZ_ImageNumber             ; get level input tile ($00-$09)
                            eor (HLZ_LevelDataGamePtrRow),y ; unpacked level data ($0800-$09c3)
                            beq SetLevelTile                ; check: same as input data - yes: do not set modify flag
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag level data was modified
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HLZ_LevelModified           ; set flag HLZ_LevelModified_Yes 
; --------------------------------------------------------------------------------------------------------------------- ;
; store input tile number to level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelTile                lda HLZ_ImageNumber             ; get level input tile ($00-$09)
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            jmp WaitNextPlayerInputKey      ; wait for next key
; --------------------------------------------------------------------------------------------------------------------- ;
; input might be a level editor command
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelEditorCmd         sta HLZ_ImageNumber             ; set level input tile ($00-$09)
                            
                            ldy HL_PlayerInputType          ; flag key or joystick interaction                          .hbu027.
                            bne WaitJoystickInit            ; check: HL_PlayerInputType_Joystick - yes                  .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; was input from keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$ff                        ; preset -1 to allow pre loop inc
SetNextLevelEditorCmdOff    iny                             ; 
                            lda TabLED_CmdChar,y            ; get next command char table entry
                            beq LED_BeepBadInput            ; check: EoT - yes: beep and wait for next input
                            
                            cmp HLZ_ImageNumber             ; test with input char
                            bne SetNextLevelEditorCmdOff    ; check: NE - yes: not a cmd - continue
                            beq CmdDispatch                 ; always - dispatch command found                           .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; was input from joystick
; --------------------------------------------------------------------------------------------------------------------- ;
WaitJoystickInit            ldx #$00                        ;                                                           .hbu027.
                            ldy #$80                        ; ini debounce delay                                        .hbu027.
DecNext_X                   dex                             ;                                                           .hbu027.
                            bne DecNext_X                   ;                                                           .hbu027.
                            dey                             ;                                                           .hbu027.
                            bne DecNext_X                   ;                                                           .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; get joystick moves
; --------------------------------------------------------------------------------------------------------------------- ;
WaitJoystick                lda HL_JoystickNew              ;                                                           .hbu027.
                            ror a                           ; shift out bit LED_MoveCursorUp                            .hbu027.
                            bcs CmdDispatch                 ; check: up: yes                                            .hbu027.
                            
                            iny                             ;                                                           .hbu027.
                            ror a                           ; shift out bit LED_MoveCursorDown                          .hbu027.
                            bcs CmdDispatch                 ; check: down - yes                                         .hbu027.
                            
                            iny                             ;                                                           .hbu027.
                            ror a                           ; shift out bit LED_MoveCursorLeft                          .hbu027.
                            bcs CmdDispatch                 ; check: left - yes                                         .hbu027.
                            
                            iny                             ;                                                           .hbu027.
                            ror a                           ; shift out bit LED_MoveCursorRight                         .hbu027.
                            bcs CmdDispatch                 ; check: right - yes                                        .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; no valid joystick move found - do not beep
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; input was a level editor command - dispatch the appropriate sub-routine
; --------------------------------------------------------------------------------------------------------------------- ;
CmdDispatch                 tya                             ; 
                            asl a                           ; *2
                            tay                             ; 
                            
                            lda TabLED_CmdAddress + $01,y   ; get address command routine HI
                            pha                             ; push to stack
                            lda TabLED_CmdAddress + $00,y   ; get address command routine LO
                            pha                             ; push to stack
                            
                            rts                             ; dispatch command routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_BeepBadInput          Does    : level editor: error beep
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_BeepBadInput           .block                           ; 
                            jsr EditorErrorBeep             ; output an error beep signal
                            jmp LED_GetKey                  ; check input key for a valid tile number/command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorUp              Does    : level editor: step cursor up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorUp               .block                           ; 
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #HL_ScreenRows_Min          ; test min                                                  .hbu012.
                            bne MoveCursor_Up               ; check: EQ - no                                            .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor to max row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ScreenRows_Max          ; get max row                                               .hbu012.
                            sta HLZ_ScreenRow               ; set max row - rotate: continue on bottom                  .hbu012.
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
MoveCursor_Up               dec HLZ_ScreenRow               ; screen row  (00-0f)
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorLeft            Does    : level editor: step cursor left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorLeft             .block                           ; 
                            lda HLZ_ScreenCol               ; get screen col  ($00-$1b)
                            cmp #HL_ScreenCols_Min          ; test min                                                  .hbu012.
                            bne MoveCursor_Left             ; check: min - no                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor to max column
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ScreenCols_Max          ; get max column                                            .hbu012.
                            sta HLZ_ScreenCol               ; set max column - rotate: continue at right end            .hbu012.
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
MoveCursor_Left             dec HLZ_ScreenCol               ; screen col  ($00-$1b)
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorRight           Does    : level editor: step cursor right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorRight            .block                           ; 
                            lda HLZ_ScreenCol               ; get screen col ($00-$1b)
                            cmp #HL_ScreenCols_Max          ; test max                                                  .hbu012.
                            bne MoveCursor_Right            ; check: EQ - no                                            .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; ; set cursor to min column
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ScreenCols_Min          ; get min column                                            .hbu012.
                            sta HLZ_ScreenCol               ; set min column - rotate: continue on left end             .hbu012.
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
MoveCursor_Right            inc HLZ_ScreenCol               ; screen col  ($00-$1b)
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorDown            Does    : level editor: step cursor down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorDown             .block                           ; 
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #HL_ScreenRows_Max          ; test max                                                  .hbu012.
                            bne MoveCursor_Down             ; check: EQ - no                                            .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor to min row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ScreenRows_Min          ; get min row - rotate: continue on top                     .hbu012.
                            sta HLZ_ScreenRow               ;                                                           .hbu012.
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
MoveCursor_Down             inc HLZ_ScreenRow               ; screen row  (00-0f)
                            jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_GetYesOrNo            Does    : level editor: get a Y/N answer        
;                           Expects : 
;                           Returns : .C = 0 - answer was YES
;                                   : .C = 1 - answer was NO
; --------------------------------------------------------------------------------------------------------------------- ;
LED_GetYesOrNo             .block                           ; 
                            lda #HR_LT_GREEN_LT_GREEN       ; get attention message color
                            jsr StatusMsgTextColor          ;                                                           .hbu020.
                            
                            dec HLZ_ScreenCol               ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; announce the question
; --------------------------------------------------------------------------------------------------------------------- ;
BeepAndWaitForInput         jsr EditorErrorBeep             ; output an error beep signal
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ce                        ; "N" to blink default reply                                .hbu020.
                            jsr TextCharPrepare             ; map to character image data numbers                       .hbu020.
                            jsr BED_CursorBlink             ; wait for input key and blink cursor                       .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; clear input
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_KeyNew_None             ; get initial value                                         .hbu020.
                            sty HL_KeyNew                   ; ini new key input                                         .hbu020.
                            
CheckKey_RunStop            cmp #$3f                        ; <RUN/STOP>                                                .hbu020.
                            bne CheckKey_N                  ; check: EQ - no: check Y/N                                 .hbu020.
                            beq SetAnswer_No                ; always exit with NO                                       .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_N                  cmp #$01                        ; test <ENTER>                                              .hbu020.
                            beq SetAnswer_No                ; check: EQ - yes: exit with default NO                     .hbu020.
                            
                            cmp #$27                        ; test "N"                                                  .hbu020.
                            beq SetAnswer_No                ; check: EQ - yes: exit NO                                  .hbu020.
                            
                            cmp #$19                        ; test "Y"                                                  .hbu020.
                            bne BeepAndWaitForInput         ; check: Y - no: beep and request a valid input             .hbu020.
                            
SetAnswer_Yes               clc                             ; set flag YES                                              .hbu020.
                            rts                             ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
SetAnswer_No                sec                             ; set flag NO                                               .hbu020.
                            rts                             ;                                                           .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelClearHandler     Does    : level editor: clear the edited level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelClearHandler      .block                           ; 
                            jsr LED_CursorPosSave           ; save actual cursr pos                                     .hbu035.
;                           jsr GameLevelClearMsgOutArea    ; clear the message area                                    .hbu035.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu035.
                            sta HLZ_TargetGfxOutput         ; output to display screen only                             .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
; display save question in the message text area - keep level display
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu035.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "c" | $80 ;               ; CLEAR DATA  Y/N                                           .hbu035.
                            .byte "l" | $80 ;               ;                                                           .hbu035.
                            .byte "e" | $80 ;               ;                                                           .hbu035.
                            .byte "a" | $80 ;               ;                                                           .hbu035.
                            .byte "r" | $80 ;               ;                                                           .hbu035.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu035.
                            .byte "d" | $80 ;               ;                                                           .hbu035.
                            .byte "a" | $80 ;               ;                                                           .hbu035.
                            .byte "t" | $80 ;               ;                                                           .hbu035.
                            .byte "a" | $80 ;               ;                                                           .hbu035.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu035.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu035.
                            .byte "y" | $80 ;               ;                                                           .hbu035.
                            .byte "/" | $80 ;               ;                                                           .hbu035.
                            .byte "n" | $80 ;               ;                                                           .hbu035.
                            
                            .byte $00 ; EndOfText                                                                       .hbu035.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_GetYesOrNo              ; get YES/NO                                                .hbu035.
                            php                             ; save the answer in the processor status                   .hbu035.
                            
;                           lda #HLZ_LevelModified_No       ; get flag level data not modified                          .hbu035.
;                           sta HLZ_LevelModified           ; set edit status                                           .hbu035.
                            
;                           jsr StatusMsgTextShow           ; restore the level msg text or a default msg text          .hbu035.
                            
                            jsr LED_CursorPosRestore        ;                                                           .hbu035.
                            
                            plp                             ; restore the answer in the processor status                .hbu035.
                            rts                             ;                                                           .hbu035.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelSaveHandler      Does    : level editor: save the edited level
;                           Expects : .A=$00 - flag: restore the level message area
;                                   : .A=$ff - flag: do not restore the level message area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSaveHandler       .block                           ;                                                           .hbu020.
                            pha                             ; save the msg retauration flag                             .hbu020.
                            jsr LED_CursorPosSave           ; save actual cursr pos
                            
;                           lda HLZ_ScreenRow               ; get screen row ($00-$0f)                                  .hbu020. removed
;                           pha                             ;                                                           .hbu020. removed
;                           lda HLZ_ScreenCol               ; get screen col ($00-$1b)                                  .hbu020. removed
;                           pha                             ;                                                           .hbu020. removed
                            
                            jsr GameLevelClearMsgOutArea    ; clear the message area                                    .hbu020.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu020.
                            sta HLZ_TargetGfxOutput         ; output to display screen only                             .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; display save question in the message text area - keep level display
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu020.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "s" | $80 ;               ; SAVE DATA   Y/N                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "v" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "y" | $80 ;               ;                                                           .hbu020.
                            .byte "/" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            
                            .byte $00 ; EndOfText                                                                       .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_LT_GREEN_LT_GREEN       ; get attention message color
                            jsr StatusMsgTextColor          ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; announce the question
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_GetYesOrNo              ; get YES/NO                                                .hbu020.
                            bcs LED_LevelSaveHandlerX       ; the answer was no - exit                                  .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; the answer was YES - do all the disk checks
; --------------------------------------------------------------------------------------------------------------------- ;
; read in loderunner score block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderuner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            bne CheckUserLevelDisk          ; check: NE - yes: loderunner disk in drive
                            
                            jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
;                           jmp SetCursorHome               ;                                                           .hbu020. removed
                            jmp LED_LevelSaveHandlerX       ; exit bad disk                                             .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; check user level disk
; --------------------------------------------------------------------------------------------------------------------- ;
CheckUserLevelDisk          cmp #HL_ScoreBufCheck_Mod_No    ; test disk is not a master disk
                            bne CompressLevelDataAndStore   ; check: NE - yes: user level disk in drive
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
;                           jmp SetCursorHome               ;                                                           .hbu020. removed
                            jmp LED_LevelSaveHandlerX       ; exit bad disk                                             .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
CompressLevelDataAndStore   jsr GameLevelDataCompress       ; compress level data and store to disk
; --------------------------------------------------------------------------------------------------------------------- ;
; restore cursor position
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSaveHandlerX       pla                             ; restore the msg retauration flag                          .hbu020.
                            beq MsgRestore                  ; check: restore - yes                                      .hbu020.
                            
                            inc HL_LevelReload              ; force a level reload if <> HL_LevelNumDisk                .hbu020.
                            
                            sec                             ; force command prompt redisplay                            .hbu020.
                            rts                             ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
MsgRestore                  jsr LED_CursorPosRestore        ;                                                           .hbu020.
                            
;                           pla                             ;                                                           .hbu020. removed
;                           sta HLZ_ScreenCol               ; set screen col ($00-$1b)                                  .hbu020. removed
;                           pla                             ;                                                           .hbu020. removed
;                           sta HLZ_ScreenRow               ; set screen row ($00-$0f)                                  .hbu020. removed
                            
;                           lda #HLZ_LevelModified_No       ; get flag level data not modified                          .hbu020. removed
;                           sta HLZ_LevelModified           ; set edit status                                           .hbu020. removed
                            
                            jmp StatusMsgTextShow           ; restore the level msg text and return                     .hbu023.
; --------------------------------------------------------------------------------------------------------------------- ;
;SetCursorHome              lda #$00                        ; get top left corner                                       .hbu020. removed
;                           sta HLZ_ScreenCol               ; set screen col ($00-$1b)                                  .hbu020. removed
;                           sta HLZ_ScreenRow               ; set screen row ($00-$0f)                                  .hbu020. removed
;                           jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu020. removed
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelSave             Does    : level editor: save level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSave              .block                           ; 
                            lda #$00                        ; flag: restore the level message area                      .hbu020.
                            jsr LED_LevelSaveHandler        ; save the edited level
                            
                            lda #HLZ_LevelModified_No       ; get flag level data not modified                          .hbu020.
                            sta HLZ_LevelModified           ; set edit status                                           .hbu020.
                            
                            jmp LED_GetKey                  ; check input key for a valid tile number/command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelNext             Does    : level editor: edit next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelNext              .block                           ; 
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            jsr GameLevelNumIncHandler      ; control the level number increase                         .hbu002.
                            
                            lda #HL_LevelReload_Force       ; get flag force level reload                               .hbu012.
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk.hbu012.
                            
                            jmp LED_Start_ExpandOnly        ; bypass editor init                                        .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelPrev             Does    : level editor: edit previous level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelPrev              .block                           ; 
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            jsr GameLevelNumDecHandler      ; control the level number decrease                         .hbu002.
                            
                            lda #HL_LevelReload_Force       ; get flag force level reload                               .hbu012.
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk.hbu012.
                            
                            jmp LED_Start_ExpandOnly        ; bypass editor init                                        .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelSame             Does    : level editor: reload level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSame              .block                           ; 
                            jsr LED_CursorPosSave           ; save actual cursr pos                                     .hbu012.
                            jsr LED_CheckLevelModified      ; care for edit changes                                     .hbu012.
                            
                            lda #HL_LevelReload_Force       ; get flag force level reload                               .hbu012.
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk.hbu012.
                            
                            jmp LED_Start_Recolor           ; reset to fix level editor colors                          .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelText             Does    : level editor: edit the all gold collected message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelText              .block                           ; 
                            lda #HR_YELLOW_YELLOW           ;                                                           .hbu012.
                            jsr StatusMsgTextColor          ;                                                           .hbu012.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu012.
                            sta HLZ_TargetGfxOutput         ; target output  $20=$2000 $40=$4000                        .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; get the msg text
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosSave           ; save actual cursr pos                                     .hbu012.
                            jsr LED_CursorPosMsg            ; set cursor to message text input position                 .hbu012.
                            
                            clc                             ; get flag do not the clear buffer                          .hbu012.
                            ldy #HL_LevelDataBufMsgTxt_Len  ; get input max length                                      .hbu012.
                            jsr GameGetInputText            ; get a message text                                        .hbu012.
                            beq RestoreEditCursorPos        ; check: input text entered - no: bypass flag setting       .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; if some text was entered set the modification flag
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #HLZ_LevelModified_Yes      ; get flag level data mofified                              .hbu012.
;                           sta HLZ_LevelModified           ; restore modification flag                                 .hbu012.
                            lsr HLZ_LevelModified           ; set flag HLZ_LevelModified_Yes                            .hbu018.
                            
RestoreEditCursorPos        jsr LED_CursorPosRestore        ; restore old cursor position                               .hbu012.
                            
                            lda HLZ_LevelModified           ; get flag modified                                         .hbu012.
                            bne LED_LevelTextX              ; check: modifued - no: discard the changes                 .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the new message together with the message indicator
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_LevelDataBufMsgTxt_Len - $01 ; get msg text length                                  .hbu012.
GetNextMsgByte              lda HL_InputBuffer,y            ; copy the message text                                     .hbu012.
                            sta HL_LevelDataBufMsgTxt,y     ; to the level message store                                .hbu012.
                            
                            dey                             ; dec msg text length                                       .hbu012.
                            bpl GetNextMsgByte              ; check: min - no: continue                                 .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy msg indicator
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_LevelDataBufMsgID_Len   ; get msg id length                                         .hbu012.
GetNextMsgIdByte            lda TabLevelMsgId,y             ; copy the message id                                       .hbu012.
                            sta HL_LevelDataBufMsgID - $01,y; behind the message text                                   .hbu012.
                            
                            dey                             ; dec msg id length                                         .hbu012.
                            bpl GetNextMsgIdByte            ; check: min - no: continue                                 .hbu012.
                            
LED_LevelTextX              jmp LED_GetKey                  ; check input key for a valid tile number/command           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Quit                  Does    : level editor: quit
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Quit                   .block                           ; 
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            bcs LED_QuitX                   ; no modifications - quietly renew edit screen              .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; return to board editor main page - keep the header lines
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_ScreenRow_BED_Input_Max + $01 ;                                                    .hbu020.
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu020.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu020.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu020.
                            
                            jmp BED_CommandCheck            ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; return to board editor main page - renew the whole screen
; --------------------------------------------------------------------------------------------------------------------- ;
LED_QuitX                   jmp BED_Init                    ; board editor: clear screen and init                       .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CheckLevelModified    Does    : level editor: check if level was modified and ask for acknowlege
;                           Expects : 
;                           Returns : C=1 - modification flag not set
;                                   : C=0 - modification successfully handled
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CheckLevelModified     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LevelModified           ; get edit status
                            beq LevelWasModified            ; check: level data modified - yes
                            
                            sec                             ; no modifications - force command prompt redisplay         .hbu020.
                            rts                             ; not modified - nothing to say - exit
; --------------------------------------------------------------------------------------------------------------------- ;
LevelWasModified            lda #HLZ_LevelModified_No       ; get flag level data not modified                          .hbu020.
                            sta HLZ_LevelModified           ; unconditionally reset edit status if arrived here         .hbu020.
                            
                            lda #$ff                        ; flag: do not restore the level message area               .hbu020.
                            jmp LED_LevelSaveHandler        ; ask for a save and return                                 .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CheckDiskType         Does    : check if disk is a loderunner data disk and if it is modifiable then
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckDiskType          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #HL_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            bne ChkDiskModifiable           ; check: EQ - no: check if modifiable
                            
                            jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
;                           jmp BED_Init                    ; clear screen and init the board editor                    .hbu020. removed
                            jmp BED_CommandCheck            ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDiskModifiable           cmp #HL_ScoreBufCheck_Mod_No    ; test disk is not a master disk
                            bne BED_CheckDiskTypeX          ; check: EQ - no: good end
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
;                           jmp BED_Init                    ; clear screen and init the board editor                    .hbu020. removed
                            jmp BED_CommandCheck            ;                                                           .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckDiskTypeX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ErrorMsgDiskMaster    Does    : write out error message loderunner master disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ErrorMsgDiskMaster     .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu020.
                            
                            lda #$06                        ;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu020.
                            lda #$06                        ;                                                           .hbu020.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu020.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "m" | $80 ;               ;       MASTER DISKETTE                                     .hbu020.
                            .byte "a" | $80 ;               ;     USER NOT ALLOWED TO                                   .hbu020.
                            .byte "s" | $80 ;               ; MANIPULATE MASTER DISKETTE!                               .hbu020.
                            .byte "t" | $80 ;               ;   HIT A KEY TO CONTINUE                                   .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "k" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "w" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            
                            .byte $00 ; EndOfText
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_MsgHitAnyKey          Does    : board editor: wait for key after info message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_MsgHitAnyKey           .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ;   HIT A KEY TO CONTINUE                                   .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_MsgTextHitAnyKey         ; show the message text 'HIT A KEY TO CONTINUE'            .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
;                           .byte "h" | $80 ;               ;                                                           .hbu020. removed
;                           .byte "i" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "t" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020. removed 
;                           .byte "a" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020. removed 
;                           .byte "k" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "e" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "y" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020. removed 
;                           .byte "t" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "o" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020. removed 
;                           .byte "c" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "o" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "n" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "t" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "i" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "n" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "u" | $80 ;               ;                                                           .hbu020. removed 
;                           .byte "e" | $80 ;               ;                                                           .hbu020. removed 
;                            
;                           .byte $00 ; EndOfText                                                                       .hbu020. removed
; --------------------------------------------------------------------------------------------------------------------- ;
;                           jsr EditorErrorBeep             ; output an error beep signal
;                           
;                           lda #HL_TileNum_Empty           ; get blank chr under cursor
;                           jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile
;                            
;                           pla                             ; restore old hires color                                   .hbu020. removed
;                           lda #HLZ_ScreenRow_BED_Input_Max + $01 ;                                                    .hbu020. removed
;                           sta HLZ_ScreenRow               ; set screen row ($00-$0f) - force command prompt redisplay .hbu020. removed
;                            
;                           ldx #HL_KeyNew_None             ; get initial value                                         .hbu020. removed
;                           stx HL_KeyNew                   ; ini new key input                                         .hbu020. removed
                            
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; init key input
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #HL_KeyNew_None             ; get initial value                                         .hbu020. removed
;                           sta HL_KeyNew                   ; ini new key input                                         .hbu020. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; update status row
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #>HL_ScreenGfxPrepare       ; get gfx prepare screen                                    .hbu020. removed
;                           sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000         .hbu020. removed
;                                                                                                                       .hbu020. removed
;                           jsr StatusAreaSetup             ; display the status row with separator and text            .hbu020. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; keep disk level data
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #HL_OutToScreenPrep_Yes     ; get flag force copy data to prepare hires screen          .hbu020. removed
;                           sta HL_OutToScreenPrep          ; set flag force copy data to prepare hires screen          .hbu020. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; care for hidden ladders/trap doors/gold/enemies/loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
;                           jsr LevelSpecialTileHandler     ; handle special level tiles and set up prepare gfx screen  .hbu020. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; restore screen colors
; --------------------------------------------------------------------------------------------------------------------- ;
;                           pla                             ; restore old hires color                                   .hbu020. removed
;                           jmp ColorLevel                  ; fill game level screen with the selected colors           .hbu020. removed
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_MsgTextHitAnyKey      Does    : board editor: show msg text hit a key
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_MsgTextHitAnyKey       .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "h" | $80 ;               ;  HIT A KEY TO CONTINUE                                    .hbu014.
                            .byte "i" | $80 ;               ;                                                           .hbu014.
                            .byte "t" | $80 ;               ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte "a" | $80 ;               ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte "k" | $80 ;               ;                                                           .hbu014.
                            .byte "e" | $80 ;               ;                                                           .hbu014.
                            .byte "y" | $80 ;               ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte "t" | $80 ;               ;                                                           .hbu014.
                            .byte "o" | $80 ;               ;                                                           .hbu014.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu014.
                            .byte "c" | $80 ;               ;                                                           .hbu014.
                            .byte "o" | $80 ;               ;                                                           .hbu014.
                            .byte "n" | $80 ;               ;                                                           .hbu014.
                            .byte "t" | $80 ;               ;                                                           .hbu014.
                            .byte "i" | $80 ;               ;                                                           .hbu014.
                            .byte "n" | $80 ;               ;                                                           .hbu014.
                            .byte "u" | $80 ;               ;                                                           .hbu014.
                            .byte "e" | $80 ;               ;                                                           .hbu014.
                            
                            .byte $00 ; EndOfText                                                                       .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
; beep and wait for player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output an error beep signal
WaitPlayerInput             jsr PlayerCheckInput            ; look for player input                                     .hbu014.
                            bcc WaitPlayerInput             ; check: player input - no: continue waiting                .hbu014.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu014.
                            stx HL_KeyNew                   ; ini new key input                                         .hbu014.
                            
                            rts                             ;                                                           .hbu014.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ErrorMsgDiskUnknown   Does    : write out disk in drive is not a loderunner datta disk error message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ErrorMsgDiskUnknown    .block                           ; 
                            jsr ScreenEditorClear           ; clear display grafic screen for editor cmd input          .hbu020.
                            
                            lda #$07                        ;                                                           .hbu020.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu020.
                            lda #$05                        ;                                                           .hbu020.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu020.
                            
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "u" | $80 ;               ;     UNKNOWN DISKETTE                                      .hbu020.
                            .byte "n" | $80 ;               ; NO LODE RUNNER DATA DISK                                  .hbu020.
                            .byte "k" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;  HIT ANY KEY TO CONTINUE                                  .hbu020.
                            .byte "w" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "k" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "l" | $80 ;               ;                                                           .hbu020.
                            .byte "o" | $80 ;               ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte "u" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "n" | $80 ;               ;                                                           .hbu020.
                            .byte "e" | $80 ;               ;                                                           .hbu020.
                            .byte "r" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte "t" | $80 ;               ;                                                           .hbu020.
                            .byte "a" | $80 ;               ;                                                           .hbu020.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu020.
                            .byte "d" | $80 ;               ;                                                           .hbu020.
                            .byte "i" | $80 ;               ;                                                           .hbu020.
                            .byte "s" | $80 ;               ;                                                           .hbu020.
                            .byte "k" | $80 ;               ;                                                           .hbu020.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu020.
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_MsgHitAnyKey            ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_WaitForInput          Does    : level editor: set the data pointer to screen row/col
;                                   :               blink the cursor and wait for input
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_WaitForInput           .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            
                            jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; level editor commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabLED_CmdChar              = * ; level editor commands
                            .byte $21 ; i - Move cursor up
                            .byte $24 ; m - Move cursor down
                            .byte $22 ; j - Move cursor left
                            .byte $25 ; k - Move cursor right
                            .byte $2a ; l - Move cursor right                                                           .hbu012.
                            
                            .byte $87 ; <CURSOR UP>                                                                     .hbu012.
                            .byte $07 ; <CURSOR DOWN>                                                                   .hbu012.
                            .byte $82 ; <CURSOR LEFT>                                                                   .hbu012.
                            .byte $02 ; <CURSOR RIGHT>                                                                  .hbu012.
                            
                            .byte $8d ; S - Save
                            .byte $96 ; T - Test     a level                                                            .hbu019.
                            .byte $16 ; t - Edit     a level message text                                               .hbu012.
                            .byte $8a ; A - Reload   a level                                                            .hbu012.
                            .byte $95 ; F - Forward  a level
                            .byte $9e ; U - Forward  a level                                                            .hbu012.
                            .byte $9c ; B - Backward a level
                            .byte $a9 ; P - Backward a level                                                            .hbu012.
                            .byte $9f ; V - Mirror   a level (Reverse)                                                  .hbu018.
                            .byte $94 ; C - Clear    a level                                                            .hbu035.
                            
                            .byte $a1 ; I - Rotate a level data row up                                                  .hbu036.
                            .byte $a4 ; M - Rotate a row down                                                           .hbu036.
                            .byte $a2 ; J - Rotate a column left                                                        .hbu036.
                            .byte $a5 ; K - Rotate a column right                                                       .hbu036.
                            .byte $aa ; L - Rotate a column right                                                       .hbu036.
                            
                            .byte $97 ; X - Toggle xmit level mode                                                      .hbu022.
                            .byte $17 ; x - Xmit a level to drive 9                                                     .hbu022.
                            .byte $28 ; + - Inc xmit target level num on drive #9 by 01                                 .hbu022.
                            .byte $31 ; + - Inc xmit target level num on drive #9 by 10 with <SHIFT> +                  .hbu022.
                            .byte $2b ; - - Dec xmit target level num on drive #9 by 01                                 .hbu022.
                            .byte $ae ; - - Dec xmit target level num on drive #9 by 10 with <SHIFT> -                  .hbu022.
                            
                            .byte $be ; Q - Quit
                            
                            .byte $00 ; end of command table marker
; --------------------------------------------------------------------------------------------------------------------- ;
; level editor command routines
; --------------------------------------------------------------------------------------------------------------------- ;
TabLED_CmdAddress           = * ; 
                            .word LED_CursorUp       - $01 ; i - Move Cursor Up              keep this order because of .hbu027.
                            .word LED_CursorDown     - $01 ; m - Move Cursor Down
                            .word LED_CursorLeft     - $01 ; j - Move Cursor Left
                            .word LED_CursorRight    - $01 ; k - Move Cursor Right
                            .word LED_CursorRight    - $01 ; l - Move Cursor Right                                      .hbu012.
                            
                            .word LED_CursorUp       - $01 ; <CURSOR UP>                                                .hbu027.
                            .word LED_CursorDown     - $01 ; <CURSOR DOWN>                                              .hbu027.
                            .word LED_CursorLeft     - $01 ; <CURSOR LEFT>                                              .hbu027.
                            .word LED_CursorRight    - $01 ; <CURSOR RIGHT>                                             .hbu027.
                            
                            .word LED_LevelSave      - $01 ; S - Save
                            .word LED_LevelTest      - $01 ; T - Test     level                                         .hbu019.
                            .word LED_LevelText      - $01 ; t - Edit     a level message text                          .hbu012.
                            .word LED_LevelSame      - $01 ; A - Reload   a level                                       .hbu012.
                            .word LED_LevelNext      - $01 ; F - Forward  a level                                          
                            .word LED_LevelNext      - $01 ; U - Forward  a level                                       .hbu012.
                            .word LED_LevelPrev      - $01 ; B - Backward a level                                          
                            .word LED_LevelPrev      - $01 ; P - Backward a level                                       .hbu012.
                            .word LED_LevelMirror    - $01 ; V - Mirror   a level                                       .hbu018.
                            .word LED_LevelClear     - $01 ; C - Wipe out a level                                       .hbu035.
                            
                            .word LED_LevelMoveUp    - $01 ; I - Rotate a level data a row up                           .hbu036.
                            .word LED_LevelMoveDown  - $01 ; M - Rotate a level data a row down                         .hbu036.
                            .word LED_LevelMoveLeft  - $01 ; J - Rotate a level data a column left                      .hbu036.
                            .word LED_LevelMoveRight - $01 ; K - Rotate a level data a column right                     .hbu036.
                            .word LED_LevelMoveRight - $01 ; L - Rotate a level data a column right                     .hbu036.
                            
                            .word LED_XmitToggle     - $01 ; X - Toggle transmit level mode                             .hbu099.
                            .word LED_XmitLevel      - $01 ; x - Xmit level to a slot of drive #9                       .hbu099.
                            .word LED_XmitLevelInc   - $01 ; + - Inc xmit target level num on drive #9 by 01            .hbu099.
                            .word LED_XmitLevelInc10 - $01 ; + - Inc xmit target level num on drive #9 by 10            .hbu099.
                            .word LED_XmitLevelDec   - $01 ; - - Dec xmit target level num on drive #9 by 01            .hbu099.
                            .word LED_XmitLevelDec10 - $01 ; - - Dec xmit target level num on drive #9 by 10            .hbu099.
                            
                            .word LED_Quit           - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelNumberGet        Does    : board editor: get a level number
;                           Expects : 
;                           Returns : .C=0 - OK
;                                   : .C=1 - error
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelNumberGet         .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; convert disk level number previously played to digits
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_LevelNumDisk             ; get disk level num (000-249) 
                            iny                             ; make it a game level number
                            tya                             ; get value to be converted
                            jsr ConvertHexToDec             ; result in HL_Digit_100/HL_Digit_10/HL_Digit_1
                            
                            lda HLZ_ScreenCol               ; get screen col ($00-$1b)
                            sta TabBED_SaveCurrentScreenCol ; save screen col
; --------------------------------------------------------------------------------------------------------------------- ;
; output converted disk level number parts to the status row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset to converted level numbers
GetNextConvLvlvNum          lda HL_Digit,y                  ; get converted level number 100/10/1 part
                            
                            sty TabBED_SaveConvLevelNumOff  ; save offset to converted level numbers
                            
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            ldy TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            iny                             ; inc offset to converted level numbers
                            cpy #$03                        ; test max bypassed
                            bcc GetNextConvLvlvNum          ; check: LT - yes: limit not reached - continue
; --------------------------------------------------------------------------------------------------------------------- ;
; restore screen column
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabBED_SaveCurrentScreenCol ; get saved screen col
                            sta HLZ_ScreenCol               ; restore screen col ($00-$1b)
                            
                            ldy #$00                        ; ini offset to converted level numbers
                            sty TabBED_SaveConvLevelNumOff  ; set offset to converted level numbers
                            
GetNextLevelNumOff          ldx TabBED_SaveConvLevelNumOff  ; get converted level number offset
                            lda HL_Digit,x                  ; get 100/10/1 parts
                            clc                             ; 
                            adc #NumDigit_0                 ; make it a digit image                                     .hbu000.
                            jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_CheckInputDigit         ; check if key pressed is a digit
                            bcc DisplayInputDigit           ; check: was digit - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a <RETURN>
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$01                        ; test <RETURN>
                            beq BED_LevelNumberToBin        ; check: EQ - yes: done - convert to binary level number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a cursor move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$07                        ; test <CURSOR_UP>
                            beq GetLevelNumOff              ; check: EQ - yes
                            
                            cmp #$82                        ; test <CURSOR_LEFT>
                            bne ChkCursorRight              ; check: EQ - no
                            
GetLevelNumOff              ldx TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            beq BeepBadInput                ; check: at left border of digit display - yes: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; move digit display cursor one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabBED_SaveConvLevelNumOff  ; dec offset to converted level numbers
                            dec HLZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCursorRight              cmp #$02                        ; test <CURSOR_RIGHT>
                            bne ChkRunStop                  ; check: EQ - no
                            
                            ldx TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            cpx #$02                        ; test right border
                            beq BeepBadInput                ; check: EQ - yes: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; move digit display cursor one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            inc TabBED_SaveConvLevelNumOff  ; inc offset to converted level numbers
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkRunStop                  cmp #$3f                        ; test <RUN/STOP>
                            bne ChkInputDigit               ; check: EQ - no: check if input was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
; was <RUN/STOP> - level number input interrupted - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
ChkInputDigit               jsr BED_CheckInputDigit         ; check if key pressed is a digit
                            bcs BeepBadInput                ; check: was digit - no: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; input was a digit - display at cursor position
; --------------------------------------------------------------------------------------------------------------------- ;
DisplayInputDigit           ldy TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            sta HL_Digit,y                  ; set update digit under screen pos - 100/10/1 parts
                            
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            inc TabBED_SaveConvLevelNumOff  ; inc offset to converted level numbers
                            lda TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            cmp #$03                        ; test passed right border
                            bcc GetNextLevelNumOff          ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; reset digit display cursor to rightmost position
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabBED_SaveConvLevelNumOff  ; dec offset to converted level numbers
                            dec HLZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BeepBadInput                jsr EditorErrorBeep             ; output an error beep signal
                            jmp GetNextLevelNumOff          ; wait for next input
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelNumberToBin      Does    : create a binary level number from level number input
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelNumberToBin       .block                           ; 
                            lda TabBED_SaveCurrentScreenCol ; get save screen col
                            clc                             ; 
                            adc #$03                        ; add offset rightmost digit
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda #$00                        ; ini result
; --------------------------------------------------------------------------------------------------------------------- ;
; count 100s
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_Digit_100                ; get digit 100 part
                            beq Count10s                    ; check: had one - no: count 10s
                            
                            clc                             ; 
AddNext100                  adc #$64                        ; 100
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: done - exit
                            
                            dex                             ; dec digit 100 part
                            bne AddNext100                  ; check: min - no: continue add 100
; --------------------------------------------------------------------------------------------------------------------- ;
; count 10s
; --------------------------------------------------------------------------------------------------------------------- ;
Count10s                    ldx HL_Digit_10                 ; get digit 10 part
                            beq Add1s                       ; check: had one - no: add 1s
                            
                            clc                             ; 
AddNext10                   adc #$0a                        ; 10
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: done - exit
                            
                            dex                             ; dec digit 10 part
                            bne AddNext10                   ; check: min - no: continue add 10
; --------------------------------------------------------------------------------------------------------------------- ;
; add 1s
; --------------------------------------------------------------------------------------------------------------------- ;
Add1s                       clc                             ; 
                            adc HL_Digit_1                  ; digit 1 part
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: something went wrong
; --------------------------------------------------------------------------------------------------------------------- ;
; store level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HL_LevelNumGame             ; set game level num (001-250) 
; --------------------------------------------------------------------------------------------------------------------- ;
; store disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get game level number
                            dey                             ; disk level number starts at 000
                            sty HL_LevelNumDisk             ; set disk level num (000-249) 
; --------------------------------------------------------------------------------------------------------------------- ;
; .C=0 - .Y <  HL_LevelNumGame_Max
; .C=1 - .Y >= HL_LevelNumGame_Max
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #HL_LevelNumGame_Max        ; test 250
                            
BED_LevelNumberToBinX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_GetCommandChar        Does    : board editor: get a command char from player
;                           Expects : 
;                           Returns : .A=command char
; --------------------------------------------------------------------------------------------------------------------- ;
BED_GetCommandChar         .block                           ; 
                            lda #HL_TileNum_Empty           ; get blank chr under cursor
                            jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile
                            
                            ldx #HL_KeyNew_None             ; get initial value
                            stx HL_KeyNew                   ; ini new key input
                            
                            cmp #$3f                        ; test <RUN/STOP>
                            bne BED_GetCommandCharX         ; check: EQ - no: return command char
; --------------------------------------------------------------------------------------------------------------------- ;
; command char input interrupted - get a new one
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_GetCommandCharX         rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSaveLeaderboardOffId     = *       ; offset input new leaderboard entry ID
TabBED_SaveConvLevelNumOff  .byte $00 ; offset to converted level numbers
TabBED_SaveCurrentScreenCol .byte $00 ; 
TabBED_SaveMoveLevelSource  .byte $00 ; 
TabBED_SaveMoveLevelTarget  .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CheckInputDigit       Does    : board editor: check input char for a digit
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckInputDigit        .block                           ; 
                            lda HL_KeyNew                   ; get actual key
                            
                            ldy #HL_KeyNew_None             ; get initial value
                            sty HL_KeyNew                   ; ini new key input
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CheckInputDigit           Does    : check input char for a digit
;                           Expects : .A-value to be checked
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckInputDigit            .block                           ; 
                            ldy #TabBED_KeyDigit_Len - $01  ; get length digit key tab
ChkNextDigitTabEntry        cmp TabBED_KeyDigit,y           ; test key entered is a digit
                            beq WasDigit                    ; check: EQ - yes
                            
                            dey                             ; dec length digit key tab
                            bpl ChkNextDigitTabEntry        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; input char was not a digit
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; flag: input was no digit
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; input char was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
WasDigit                    tya                             ; get digit replacement (rank)
                            clc                             ; flag: input was a digit
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_KeyDigit             = *       ; 
                            .byte $23 ; 0
                            .byte $38 ; 1
                            .byte $3b ; 2
                            .byte $08 ; 3
                            .byte $0b ; 4
                            .byte $10 ; 5
                            .byte $13 ; 6
                            .byte $18 ; 7
                            .byte $1b ; 8
                            .byte $20 ; 9
TabBED_KeyDigit_Len         = * - TabBED_KeyDigit ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabLodeRuDiskId             = *       ; 
                            .byte "d" | $80 ;               ; DANE BIGHAM
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ;
                            .byte "a" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
TabLodeRuDiskId_Len         = * - TabLodeRuDiskId - $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryHandler         Does    : check if the gamer score is worth an entry on the leaderboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryHandler          .block                           ; 
                            lda HL_Cheated                  ; get flag cheated
                            beq ScoreEntryHandlerX          ; check: HL_Cheated_Yes - yes: no leaderboard entry
                            
                            lda HL_DemoRec                  ; get flag level demo move recording                        .hbu034.
                            bmi ScoreEntryHandlerX          ; check: HL_DemoRec_On - yes: no leaderboard entry          .hbu034.
                            
                            lda HL_ModeDebugUsed            ; get flag debug mode used                                  .hbu022.
                            bne ScoreEntryHandlerX          ; check: HL_ModeDebugUsed - yes: no leaderboard entry       .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; check zero score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_Score_Lo                 ; combine score bytes
                            ora HL_Score_Mid_Lo             ; 
                            ora HL_Score_Mid_Hi             ; 
                            ora HL_Score_Hi                 ; 
                            beq ScoreEntryHandlerX          ; check: all zero - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; read in leaderbord block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            beq ScoreEntryHandlerX          ; check: HL_ScoreBufCheck_Bad - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard entries to work buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextDiskScoreByte        lda HL_ScoreBuf,y               ; get disk block data
                            sta HL_BufScoreWork,y           ; set work buffer data
                            
                            iny                             ; inc offset
                            bne GetNextDiskScoreByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; test if the score reached qualifies for a new leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; get entry count - start with entry one
GetNextScoreBufferOff       ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            
                            lda HL_LevelNumGame             ; get game level number (001-250)
                            cmp HL_ScoreBufLevel,x          ; test score board entry - level
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda HL_Score_Hi                 ; get score HI
                            cmp HL_ScoreBufValue_Hi,x       ; test score board entry - score HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda HL_Score_Mid_Hi             ; get score MID HI
                            cmp HL_ScoreBufValue_Mid_Hi,x   ; test score board entry - score MID HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda HL_Score_Mid_Lo             ; get score MID LO
                            cmp HL_ScoreBufValue_Mid_Lo,x   ; test score board entry - score MID LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda HL_Score_Lo                 ; get score LO
                            cmp HL_ScoreBufValue_Lo,x       ; test score board entry - score LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
IncScoreEntryCount          iny                             ; inc entry count
                            cpy #HL_ScoreBufEntry_Max + $01 ; test max score entries
                            bcc GetNextScoreBufferOff       ; check: max reached - no: continue
                            
ScoreEntryHandlerX          rts                             ; exit no new leaderboard entry
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryNew             Does    : insert the new gamer score into the leaderboard
;                           Expects : .Y=leaderboard entry number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryNew              .block                           ; 
                            cpy #HL_ScoreBufEntry_Max       ; test bottom of scrore entries
                            beq GetNewScorerIdChars         ; check: EQ - yes: no insertion for enry 10 - simply overwrite
                            
                            sty HLZ_ScoreBoardOff           ; set number of new entry
; --------------------------------------------------------------------------------------------------------------------- ;
; open a score buffer slot for insertion of the new candidate
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_ScoreBufEntry_Max - $01 ; get max entries to move
GetNextScoreEntryOff        ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            lda #HL_ScoreBufEntry_Len       ; get score buffer entry length
                            sta HLZ_WorkScoreEntryLen       ; set entry length
; --------------------------------------------------------------------------------------------------------------------- ;
; free a buffer entry for insertion by moving the entries one position down
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSourceByte           lda HL_ScoreBufEntryFrom,x      ; get source
                            sta HL_ScoreBufEntryTo,x        ; set target - move data one position down
                            
                            inx                             ; inc score buffer entry row offset
                            dec HLZ_WorkScoreEntryLen       ; dec score buffer entry length
                            bne GetNextSourceByte           ; check: entry length min - no: continue
                            
                            cpy HLZ_ScoreBoardOff           ; test with number of new entry
                            beq GetNewScorerIdChars         ; check: EQ - yes: target pos reached - done
                            
                            dey                             ; dec max number of score buffer entries
                            bne GetNextScoreEntryOff        ; check: min - no: move next entry
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new scorers data
; --------------------------------------------------------------------------------------------------------------------- ;
; clear scorer id
; --------------------------------------------------------------------------------------------------------------------- ;
GetNewScorerIdChars         ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            lda #" " | $80                  ; get <SHIFT_SPACE>
                            sta HL_ScoreBufName_Char1,x     ; ini player id char 1
                            sta HL_ScoreBufName_Char2,x     ; ini player id char 2
                            sta HL_ScoreBufName_Char3,x     ; ini player id char 3
                            sta HL_ScoreBufName_Char4,x     ; ini player id char 4                                      .hbu029.
                            sta HL_ScoreBufName_Char5,x     ; ini player id char 5                                      .hbu029.
                            sta HL_ScoreBufName_Char6,x     ; ini player id char 6                                      .hbu029.
                            sta HL_ScoreBufName_Char7,x     ; ini player id char 7                                      .hbu029.
                            sta HL_ScoreBufName_Char8,x     ; ini player id char 8                                      .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
; insert level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumGame             ; get game level number (001-250)
                            sta HL_ScoreBufLevel,x          ; set level
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_Score_Hi                 ; get score HI
                            sta HL_ScoreBufValue_Hi,x       ; set score HI
                            
                            lda HL_Score_Mid_Hi             ; get score MID HI
                            sta HL_ScoreBufValue_Mid_Hi,x   ; set score MID HI
                            
                            lda HL_Score_Mid_Lo             ; get score MID LO
                            sta HL_ScoreBufValue_Mid_Lo,x   ; set score MID LO
                            
                            lda HL_Score_Lo                 ; get score LO
                            sta HL_ScoreBufValue_Lo,x       ; set score LO
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new flags
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeRnd                  ; get random mode                                           .hbu029.
                            sta HL_ScoreBufFlag_Random,x    ; save random mode                                          .hbu029.
                            
                            lda HL_ModeMirror               ; get mirror mode                                           .hbu029.
                            sta HL_ScoreBufFlag_Mirror,x    ; set mirror mode                                           .hbu029.
                            
                            lda HL_ModeDebugUsed            ; get flag debug mode used                                  .hbu029.
                            and #~HL_ModeDebugUsed_Level    ; reset flag debug mode was used for this level             .hbu022.
                            sta HL_ScoreBufFlag_Debug,x     ; set flag debug mode used                                  .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
; init fetch of new initials
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty HLZ_WorkScoreNewEntryNum    ; save number of new entry
                            
                            lda TabScoreBufEntryOff,y       ; get score buffer entry offset
                            sta smLeaderboardIdOff_In       ; set input entry offset
                            sta smLeaderboardIdOff_Out      ; set output entry offset
                            
                            jsr ScoreShowLeaderboard        ; show leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
; get board entry row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_WorkScoreNewEntryNum    ; restore number of new entry
                            clc                             ; 
                            adc #HL_BoardHeaderRows         ; add number of header rows
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; get board entry column number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_BoardEntryCol_Id        ; get start col initials
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldx #$00                        ; get initial value
                            stx TabSaveLeaderboardOffId     ; ini offset to input ID of new board entry
; --------------------------------------------------------------------------------------------------------------------- ;
; set grouped leaderboard row pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabScreenScoresRowOff     ;                                                           .hbu014.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Lo ;                                                .hbu014.
                            lda #>TabScreenScoresRowOff     ;                                                           .hbu014.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Hi ;                                                .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLeaderboardOffId     ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
smLeaderboardIdOff_In       = * + $01                       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ScoreBuf,x               ; get 1st scorer ID char
                            jsr TextCharPrepare             ; prepare and substitute char for output
                            jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile
                            
                            ldx #HL_KeyNew_None             ; get inital value
                            stx HL_KeyNew                   ; ini new key input
                            
                            jsr InputKeySubstitute          ; get a leaderbord scorer ID char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
; check for legal control chars
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$8d                        ; test <ENTER>
                            beq WriteNewLeaderboardToDisk   ; check: EQ - yes: finished - write to disk
                            
                            cmp #$88                        ; test key <CURSOR UP/DOWN>
                            bne ChkCursorRight              ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test input cursor position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            beq BeepWrongInput              ; check: left border reached - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabSaveLeaderboardOffId     ; dec offset to input ID of new board entry
                            dec HLZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCursorRight              cmp #$95                        ; test key <CURSOR LEFT/RIGHT>
                            bne CheckScoreIdChar            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test input cursor position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            cpx #HL_BoardEntryCol_Id_Len    ; test max right
                            beq BeepWrongInput              ; check: max right - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            inc TabSaveLeaderboardOffId     ; inc offset to input ID of new board entry
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check for legal special chars
; --------------------------------------------------------------------------------------------------------------------- ;
CheckScoreIdChar            cmp #"." | $80                  ; test "."
                            beq ShowScorerIdChar            ; check: EQ - yes: display it
                            
                            cmp #" " | $80                  ; test <SHIFT_SPACE>
                            beq ShowScorerIdChar            ; check: EQ - yes: display it
                            
                            cmp #"a" | $80                  ; test "A"
                            bcc BeepWrongInput              ; check: LT - yes: error beep
                            
                            cmp #"z" | $80 + $01            ; test "Z" + 1
                            bcs BeepWrongInput              ; check: GE - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; output id char entered
; --------------------------------------------------------------------------------------------------------------------- ;
ShowScorerIdChar            ldy TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
smLeaderboardIdOff_Out      = * + $01                       ; 
                            sta HL_ScoreBuf,y               ; set store typed chr into score initials area
                            
                            jsr TextOutCharHandler          ; control the output of a single char
; --------------------------------------------------------------------------------------------------------------------- ;
; advance cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabSaveLeaderboardOffId     ; inc offset to input ID of new board entry
                            lda TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            cmp #HL_BoardEntryCol_Id_Len + $01 ; test max right
                            bcc GetNextLeaderboardOffId     ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; correct cursor position to right border
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabSaveLeaderboardOffId     ; dec offset to input ID of new board entry
                            dec HLZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BeepWrongInput              jsr EditorErrorBeep             ; output an error beep signal
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; restore grouped leaderboard row pointers
; --------------------------------------------------------------------------------------------------------------------- ;
WriteNewLeaderboardToDisk   lda #<TabScreenRowOff            ;                                                          .hbu014.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Lo ;                                                .hbu014.
                            lda #>TabScreenRowOff            ;                                                          .hbu014.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Hi ;                                                .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
; prevent updated leaderboard from being overwritten
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextNewScoreByte         lda HL_ScoreBuf,y               ; get score disk block data
                            sta HL_BufScoreWorkNew,y        ; set score work buffer data
                            
                            iny                             ; inc offset
                            bne GetNextNewScoreByte         ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get leaderboard from disk with check
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskRead | HL_DiskForce_Score ; read with flag force score processing               .hbu016.
                            jsr ScoreDiskHandler            ; read in the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard data back - prevent manipulations
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextSaveScoreByte        lda HL_ScoreBuf,y               ; get new leaderboard byte from save buffer
                            cmp HL_BufScoreWork,y           ; test with leaderboard work bffer
                            bne ScoreEntryNewX              ; check: EQ - no: manipulated - exit
                            
                            lda HL_BufScoreWorkNew,y        ; get new leaderboard byte
                            sta HL_ScoreBuf,y               ; set disk leaderboard byte
                            
                            iny                             ; inc offset
                            bne GetNextSaveScoreByte        ; check: max - no: continue
                            
                            lda #HL_DiskWrite | HL_DiskForce_Score ; write with flag force score processing             .hbu016.
                            jsr ScoreDiskHandler            ; write out the leaderboard block
                            
ScoreEntryNewX              jmp DemoWaitInit                ; init wait for demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreShowLeaderboard      Does    : show the leaderboard of 10 entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowLeaderboard       .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #<TabScreenScoresRowOff     ; 2nd entry point for calls from StartGraficOut             .hbu015.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Lo ;                                                .hbu015.
                            lda #>TabScreenScoresRowOff     ;                                                           .hbu015.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Hi ;                                                .hbu015.
                            jsr ScoreEntryColors            ;                                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosHome           ;                                                           .hbu010.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;     LODE RUNNER HIGH SCORES
                            .byte " " | $80 ; <SHIFT_SPACE> ;       NAME   LEVEL  SCORES
                            .byte " " | $80 ; <SHIFT_SPACE> ;     -------- ----- --------
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ;
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ;
                            .byte "h" | $80 ;               ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu029.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu029.
                            .byte "n" | $80 ;               ;                                                           .hbu029.
                            .byte "a" | $80 ;               ;                                                           .hbu029.
                            .byte "m" | $80 ;               ;                                                           .hbu029.
                            .byte "e" | $80 ;               ;                                                           .hbu029.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu029.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu029.
;                           .byte "i" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "n" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "i" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "t" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "i" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "a" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "l" | $80 ;               ;                                                           .hbu029. removed
;                           .byte "s" | $80 ;               ;                                                           .hbu029. removed
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ;
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ;                                                           .hbu029.
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get initial value
                            sta HLZ_ScoreBoardRank          ; ini actual rank
                            
ScoreNextEntryOut           cmp #$0a                        ; test 10th entry
                            bne ShowEntryLowerTen           ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; rank 10 starts with a "1"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get 1 - start rank 10 with a "1"
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda #$00                        ; get 0 - continue rank 10 with a "0"
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            jmp ScoreRowHeaderOut           ; output the header
; --------------------------------------------------------------------------------------------------------------------- ;
; rank digits 1-9 start with a blank
; --------------------------------------------------------------------------------------------------------------------- ;
ShowEntryLowerTen           lda #" " | $80                  ; rank 1-9 - start with <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            lda HLZ_ScoreBoardRank          ; get actual rank
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
ScoreRowHeaderOut           jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
; score row header
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "." | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ScoreBoardRank          ; get actual rank
                            ldy TabScoreBufEntryOff,x       ; get score buffer entry offset
                            sty HLZ_ScoreBoardOff           ; set score board offset
                            
;                           lda HL_ScoreBufLevel,y          ; get level number                                          .hbu029. removed
;                           bne ScoreRowInitials            ; check: zero - no: show scorer initials                    .hbu029. removed
                            
;                           jmp ScoreSetNextEntry           ;                                                           .hbu029. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer ID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ScoreBufName_Len        ; get counter id length                                     .hbu029.
                            sta HLZ_ScoreBoardIdLen         ; get counter id length                                     .hbu029.
GetNextRowScoreInitial      ldy HLZ_ScoreBoardOff           ; get score board offset                                    .hbu029.
                            lda HL_ScoreBuf,y               ; get player id chars                                       .hbu029.
                            bne OutScoreListEntry           ; check: empty name - no: continue list entry output        .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
; empty entry name - end of list - output the rest of the ranking numbers only
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp ScoreSetNextEntry           ; set next empty entry rank number                          .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
OutScoreListEntry           jsr TextOutCharHandler          ; control the output of a single char                       .hbu029.
                            
                            inc HLZ_ScoreBoardOff           ; inc score board offset                                    .hbu029.
                            dec HLZ_ScoreBoardIdLen         ; get counter id length                                     .hbu029.
                            bne GetNextRowScoreInitial      ; check: min - no: continue                                 .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
; score row filler between initials and level
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; output level number reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScoreBoardOff           ; get score board offset
                            lda HL_ScoreBuf,y               ; get level number reached
                            jsr ConvertHexToDec             ; result in HL_Digit_100/HL_Digit_10/HL_Digit_1
                            
                            lda HL_Digit_100                ; get digit 100 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
; score row gap between level and score
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer score reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScoreBoardOff           ; set score board offset to score                           .hbu029.
                            ldy HLZ_ScoreBoardOff           ; get score board offset
                            lda HL_ScoreBuf,y               ; get score                                                 .hbu029.
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            inc HLZ_ScoreBoardOff           ; set score board offset to score                           .hbu029.
                            ldy HLZ_ScoreBoardOff           ; get score board offset
                            lda HL_ScoreBuf,y               ; get score                                                 .hbu029.
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            inc HLZ_ScoreBoardOff           ; set score board offset to score                           .hbu029.
                            ldy HLZ_ScoreBoardOff           ; get score board offset
                            lda HL_ScoreBuf,y               ; get score                                                 .hbu029.
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            inc HLZ_ScoreBoardOff           ; set score board offset to score                           .hbu029.
                            ldy HLZ_ScoreBoardOff           ; get score board offset
                            lda HL_ScoreBuf,y               ; get score                                                 .hbu029.
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSetNextEntry           jsr TextCharOutNewLine          ; set cursor to next line
                            
                            inc HLZ_ScoreBoardRank          ; inc actual rank
; --------------------------------------------------------------------------------------------------------------------- ;
; check all entries processed
; --------------------------------------------------------------------------------------------------------------------- ;
ChkMaxListEntries           lda HLZ_ScoreBoardRank          ; get actual rank
                            cmp #HL_ScoreBufEntry_Max + $01 ; test max
                            bcs ScoreShowLeaderboardX       ; check: GE - yes: exit
                            
                            jmp ScoreNextEntryOut           ; show next leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowLeaderboardX       lda #<TabScreenRowOff                      ; restore pointer to game row offsets            .hbu015.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Lo ;                                                .hbu015.
                            lda #>TabScreenRowOff                      ;                                                .hbu015.
                            sta ScreenGetGfxPosXY.smGetScreenRowOff_Hi ;                                                .hbu015.
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreBufEntryOff         = * ; start of each leaderboard entry in the score buffer
                            .byte $00                        ; 
                            .byte HL_ScoreBufEntry_Len * $00 ; $00                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $01 ; $10                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $02 ; $20                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $03 ; $30                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $04 ; $40                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $05 ; $50                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $06 ; $60                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $07 ; $70                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $08 ; $80                                                      .hbu029.
                            .byte HL_ScoreBufEntry_Len * $09 ; $90                                                      .hbu029.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryColors          Does    : select a new color for each high score group
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryColors           .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set hires color screen pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<HL_MemScreenMC            ;                                                           .hbu015.
                            sta HLZ_ScoreColorScreenPtr_Lo  ;                                                           .hbu015.
                            lda #>HL_MemScreenMC            ;                                                           .hbu015.
                            sta HLZ_ScoreColorScreenPtr_Hi  ;                                                           .hbu015.
                            
                            ldx #$00                        ; ini color tab offset                                      .hbu015.
SetRowCount                 ldy #LLEN - $01                 ; 28 color row positions                                    .hbu015.
                            lda TabScoreColors,x            ; get a color                                               .hbu015.
                            
SetColor                    sta (HLZ_ScoreColorScreenPtr),y ; put a color                                               .hbu015.
                            cpy #$06                        ; check for rank area                                       .hbu015.
                            bne SetColPtr                   ;                                                           .hbu015.
                            
                            lda #HR_WHITE_WHITE             ; get rank color                                            .hbu015.
                            
SetColPtr                   dey                             ; set next color screen col                                 .hbu015.
                            bpl SetColor                    ;                                                           .hbu015.
                            
SetRowPtr                   lda #LLEN                       ; set color screen to next row                              .hbu015.
                            clc                             ;                                                           .hbu015.
                            adc HLZ_ScoreColorScreenPtr_Lo  ;                                                           .hbu015.
                            sta HLZ_ScoreColorScreenPtr_Lo  ;                                                           .hbu015.
                            bcc SetNextColorRow             ;                                                           .hbu015.
                            inc HLZ_ScoreColorScreenPtr_Hi  ;                                                           .hbu015.
                            
SetNextColorRow             inx                             ; inc color tab offset                                      .hbu015.
                            cpx #TabScoreColors_Len - $01   ; test with max color table length                          .hbu015.
                            bne SetRowCount                 ; check: EQ - no: continue                                  .hbu015.
                            
                            rts                             ;                                                           .hbu015.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreColors              .byte HR_CYAN_CYAN              ; title line                                                .hbu015.
                            .byte HR_CYAN_CYAN              ;                                                           .hbu015.
                            .byte HR_CYAN_CYAN              ;                                                           .hbu015.
                            .byte HR_CYAN_CYAN              ;                                                           .hbu015.
                            
                            .byte HR_WHITE_WHITE            ; header line                                               .hbu015.
                            .byte HR_WHITE_WHITE            ;                                                           .hbu015.
                            
                            .byte HR_WHITE_WHITE            ; separation line                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; the podium
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte HR_LT_GREEN_LT_GREEN      ; 1st place                                                 .hbu015.
                            .byte HR_YELLOW_YELLOW          ; 2nd place                                                 .hbu015.
                            .byte HR_YELLOW_YELLOW          ;                                                           .hbu015.
                            .byte HR_LT_RED_LT_RED          ; 3rd place                                                 .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; runners up places 4-6
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte HR_LT_GREY_LT_GREY        ;                                                           .hbu015.
                            .byte HR_LT_GREY_LT_GREY        ;                                                           .hbu015.
                            .byte HR_LT_GREY_LT_GREY        ;                                                           .hbu015.
                            .byte HR_LT_GREY_LT_GREY        ;                                                           .hbu015.
                            .byte HR_LT_GREY_LT_GREY        ;                                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; runners up places 7-9
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte HR_GREY_GREY              ;                                                           .hbu015.
                            .byte HR_GREY_GREY              ;                                                           .hbu015.
                            .byte HR_GREY_GREY              ;                                                           .hbu015.
                            .byte HR_GREY_GREY              ;                                                           .hbu015.
                            .byte HR_GREY_GREY              ;                                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; last one in list
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte HR_DK_GREY_DK_GREY        ;                                                           .hbu015.
                            .byte HR_DK_GREY_DK_GREY        ;                                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
; message area
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte HR_CYAN_CYAN              ;                                                           .hbu015.
                            .byte HR_CYAN_CYAN              ;                                                           .hbu015.
TabScoreColors_Len           = * - TabScoreColors           ;                                                           .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; InputKeySubstitute        Does    : get a raw input char substitution
;                           Expects : .A=raw char
;                           Returns : .A=char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
InputKeySubstitute         .block                           ; 
                            cmp #$82                        ; test <CURSOR LEFT>
                            bne GetKeySubstTabValue         ; check: EQ - no
                            
                            lda #$07                        ; get <CURSOR UP> replacement value
                            
GetKeySubstTabValue         tay                             ; set key as key substitution table offset
                            lda TabKeySubstValue,y          ; get key substitution table value
                            ora #$80                        ; set bit7
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabKeySubstValue            = *       ; 
KeyMatrix_Row_0             .byte $00 ; $00 - INS/DEL
                            .byte $0d ; $01 - RETURN
                            .byte $15 ; $02 - CURSOR LEFT
                            .byte $ff ; $03 - F7          - ignore
                            .byte $ff ; $04 - F1          - ignore
                            .byte $ff ; $05 - F3          - ignore
                            .byte $ff ; $06 - F5          - ignore
                            .byte $08 ; $07 - CURSOR UP
                            
KeyMatrix_Row_1             .byte $33 ; $08 - 3
                            .byte $57 ; $09 - W
                            .byte $41 ; $0a - A
                            .byte $34 ; $0b - 4
                            .byte $5a ; $0c - Z
                            .byte $53 ; $0d - S
                            .byte $45 ; $0e - E
                            .byte $ff ; $0f - SHIFT Left  - ignore
                            
KeyMatrix_Row_2             .byte $35 ; $10 - 5
                            .byte $52 ; $11 - R
                            .byte $44 ; $12 - D
                            .byte $36 ; $13 - 6
                            .byte $43 ; $14 - C
                            .byte $46 ; $15 - F
                            .byte $54 ; $16 - T
                            .byte $58 ; $17 - X
                            
KeyMatrix_Row_3             .byte $37 ; $18 - 7
                            .byte $59 ; $19 - Y
                            .byte $47 ; $1a - G
                            .byte $38 ; $1b - 8
                            .byte $42 ; $1c - B
                            .byte $48 ; $1d - H
                            .byte $55 ; $1e - U
                            .byte $56 ; $1f - V
                            
KeyMatrix_Row_4             .byte $39 ; $20 - 9
                            .byte $49 ; $21 - I
                            .byte $4a ; $22 - J
                            .byte $30 ; $23 - 0
                            .byte $4d ; $24 - M
                            .byte $4b ; $25 - K
                            .byte $4f ; $26 - O
                            .byte $4e ; $27 - N
                            
KeyMatrix_Row_5             .byte $2b ; $28 - +
                            .byte $50 ; $29 - P
                            .byte $4c ; $2a - L
                            .byte $2d ; $2b - 
                            .byte $2e ; $2c - .
                            .byte $3a ; $2d - :
                            .byte $ff ; $2e - @           - ignore
                            .byte $2c ; $2f - ,
                            
KeyMatrix_Row_6             .byte $5c ; $30 - £
                            .byte $2a ; $31 - *
                            .byte $3b ; $32 - ;
                            .byte $ff ; $33 - CLR/HOME    - ignore
                            .byte $ff ; $34 - SHIFT RIGHT - ignore
                            .byte $3d ; $35 - =
                            .byte $ff ; $36 - ARROW UP    - ignore
                            .byte $2f ; $37 - /
                            
KeyMatrix_Row_7             .byte $31 ; $38 - 1
                            .byte $ff ; $39 - ARROW LEFT  - ignore
                            .byte $ff ; $3a - CTRL        - ignore
                            .byte $32 ; $3b - 2
                            .byte $20 ; $3c - SPACE
                            .byte $ff ; $3d - C=          - ignore
                            .byte $51 ; $3e - Q
                            .byte $ff ; $3f - RUN/STOP    - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataExpand       Does    : expand compressed level disk data
;                           Expects : .X=0 - data needs a copy to prepare hires screen
;                                   : .X=1 - data already copied to prepare hires screen
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataExpand        .block                           ; 
                            stx HL_OutToScreenPrep          ; set flag copy data to prepare hires screen
                            
                            ldx #$ff                        ; get initial value
                            stx HLZ_LodeRuCol               ; ini no loderunner found
                            stx HL_ExitLadderCount          ; ini hidden ladder count                                   .hbu030.
                            
                            inx                             ; get initial value $00
                            stx HL_GoldToCollect            ; ini HL_GoldToCollect_None 
                            stx HL_EnemyCount               ; ini HL_EnmyCount_None
                            stx HL_EnemyToMoveNum           ; ini HL_EnemyToMoveNum_None
                            stx HLZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                            stx HLZ_LevelDiskDataOff        ; ini disk level data offset
                            stx HLZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            stx HLZ_ScreenRow               ; ini screen row ($00-$0f)
                            
                            txa                             ; $00
                            ldx #HL_WA_HoleMax              ; get count max entries of hole open time table
IniNextOpenHoleTabEntry     sta HL_WA_HoleOpenTime,x        ; ini hole open time tab
                            
                            dex                             ; dec count entries of hole open time table
                            bpl IniNextOpenHoleTabEntry     ; check: min - no: continue
                            
                            ldx #HL_WA_EnemyBirth_Len       ; get count max entries of enemy rebirth time table
IniNextRibirthTimeTabEntry  sta HL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            dex                             ; dec count of enemy rebirth time table
                            bpl IniNextRibirthTimeTabEntry  ; check: min - no: continue
                            
                            lda #HL_LodeRuState_Alive       ; get flag loderunner alive
                            sta HL_LodeRuState              ; set flag loderunner alive
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a level reload is necessary
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249)
                            cmp HL_LevelReload              ; test with reload
                            beq SetNoDiskLoadRequired       ; check: EQ - yes: level aready loaded - no reload necessary
                            
                            lda #HL_DiskRead                ; get flag read block
                            jsr DiskOperationHandler        ; read block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
; set HL_LevelNumDisk=HL_LevelReload - avoids level data reload from disk for the same level number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNoDiskLoadRequired       lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            sta HL_LevelReload              ; set to avoid a level data reload
; --------------------------------------------------------------------------------------------------------------------- ;
; expand the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set control level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set control level data row pointer LOlevel control data pointer HI
                            
                            lda #HLZ_ScreenCol_Min          ; get initial value
                            sta HLZ_ScreenCol               ; ini screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; handle compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextNibbleCtrl           lda HLZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
; --------------------------------------------------------------------------------------------------------------------- ;
; get compressed data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LevelDiskDataOff        ; get disk level data offset
                            lda HL_LevelDataBuf,y           ; get a packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; check compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; ....#### - isolate right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           lsr a                           ; .####... - isolate left nibble
                            lsr a                           ; ..####..
                            lsr a                           ; ...####.
                            lsr a                           ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_LevelDiskDataOff        ; inc offset to next disk level byte
                            
ForceProcessingLeftNibble   inc HLZ_WorkLevelDataPartCtrl   ; force .C set the next round - process left nibble
                            
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; care for valid level tile number
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Max + $01       ; test valid byte range ($00-$09)
                            bcc StoreUnpackedLevelTile      ; check: LT - yes: valid
                            
                            lda #HL_TileNum_Empty           ; get invalid level tile replacement - store an empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
; store level tile into both level data buffers
; --------------------------------------------------------------------------------------------------------------------- ;
StoreUnpackedLevelTile      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            
                            lda HLZ_ScreenCol               ; get screen col ($00-$1b)
                            cmp #HLZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: max passed - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #HLZ_ScreenRow_Max + $01    ; test max
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; care for hidden ladders/trap doors/gold/enemies/loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LevelSpecialTileHandler     ; handle special level tiles and set up prepare gfx screen
                            bcc GameContinue                ; check: loderunner tile found - yes: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; missing loderunner level data tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            beq GameColdStart               ; check: still 1st level - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; force restart with 1st level
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_LevelNumDisk_Min        ; get initial value
                            stx HL_LevelNumDisk             ; set disk level num (000-249)  - last level completed
; --------------------------------------------------------------------------------------------------------------------- ;
; try to increase the game speed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameSpeedCtrl            ; get game speed ($00-$0a)
                            cmp #HL_GameSpeedCtrl_Max       ; test game speed max
                            bcs GameRestart                 ; check: GE - yes: max reached or bypassed - bypass inc
                            
                            inc HL_GameSpeedCtrl            ; make the game a bit difficulter
                            
GameRestart                 dex                             ; set flag copy data to prepare hires screen
                            jmp GameLevelDataExpand         ; expand compressed level disk data
; --------------------------------------------------------------------------------------------------------------------- ;
GameContinue                jmp LED_CursorPosRestore        ; restore HLZ_ScreenRow/HLZ_ScreenCol values                .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; error restart - probably no loderunner level disk
; --------------------------------------------------------------------------------------------------------------------- ;
GameColdStart               jmp ColdStart                   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataCompress     Does    : compress expanded level data and store to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataCompress      .block                           ; 
                            lda #$00                        ; get initial value
                            sta HLZ_LevelDiskDataOff        ; ini disk level data offset
                            sta HLZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            sta HLZ_ScreenRow               ; ini screen row ($00-$0f)
                            
SetNextLevelDataRowPtr      ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #HLZ_ScreenCol_Min          ; get inital value
                            sty HLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextNibbleCtrl           lda HLZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
                            
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HLZ_ImageNumber             ; save as right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           asl a                           ; isolate left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora HLZ_ImageNumber             ; insert right nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; store complete data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LevelDiskDataOff        ; get disk level data offset
                            sta HL_LevelDataBuf,y           ; set packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_LevelDiskDataOff        ; disk level data offset
                            
ForceProcessingLeftNibble   inc HLZ_WorkLevelDataPartCtrl   ; will set .C the next round - force left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            cpy #HLZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #HLZ_ScreenRow_Max + $01    ; test max passed
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; level data block must not be written in test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelTest                ; flag: level testmode on/off                               .hbu019.
                            beq IniWriteLevelData           ; check: HL_LevelTest_Off - yes: write level data to disk   .hbu019.
                            
                            rts                             ; no saves in test mode                                     .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; write packed data block to disk
; --------------------------------------------------------------------------------------------------------------------- ;
IniWriteLevelData           lda #HL_DiskWrite               ; get flag write block to disk
                            jmp DiskOperationHandler        ; write level data block to disk and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskOperationHandler      Does    : decide whether a level is to be loaded from disk or not (demo)
;                           Expects : .A=$01 - Read  level block  .A=$c1 Bit7=1 - score block / Bit6=1 - RND block
;                                   : .A=$02 - Write level block  .A=$c2 Bit7=1 - score block / Bit6=1 - RND block
;                                   : .A=$04 - Init  level block
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskOperationHandler       .block                           ; 
;                           pha                             ; save mode - $01=read $02=write $04=init                   .hbu002. removed
                            sta HL_DiskAction               ; $01=read $02=write $04=init / $81=read $82=write          .hbu002.
                            
                            bpl ChkDemoOrGameLevels         ; check: bypass flag set - no: check for demo
; --------------------------------------------------------------------------------------------------------------------- ;
; reset a possible force flag - bypass demo check
; --------------------------------------------------------------------------------------------------------------------- ;
;                           pla                             ; restore mode - $01=read $02=write $04=init                .hbu002. removed
;                           and #$7f                        ; .####### - clear flag force bypass demo                   .hbu016. removed
;                           pha                             ; save mode - $01=read $02=write $04=init                   .hbu002. removed
                            
;                           jmp DiskCmdStringInit           ; init disk command string for read/write/init              .hbu001.hbu002 removed
                            jmp DiskCmdHandler              ;                                                           .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; demo levels are built in - only game levels must be loaded from disk
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDemoOrGameLevels         lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit
                            lsr a                           ; shift out mode flag
                            beq DemoLevelDataHandler        ; check: demo - yes: demo - levels built in - no disk load
; --------------------------------------------------------------------------------------------------------------------- ;
; only game levels have to be loaded
; --------------------------------------------------------------------------------------------------------------------- ;
;                           jmp DiskCmdStringInit           ; init disk command string for read/write/init              .hbu002. removed
                            jmp DiskCmdHandler              ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoLevelDataHandler      Does    : control demo level data selection
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoLevelDataHandler       .block                           ; 
;                           pla                             ; remove mode from stack                                    .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; 4 demo levels are built in
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            cmp #HL_LevelNumDisk_Demo_Max + $01 ; test max 4 demo levels                                .hbu003.
                            bcc IniDemoLevelDataPointers    ; check: LT - yes: continue with next demo level data       .hbu003.
; --------------------------------------------------------------------------------------------------------------------- ;
; maximum reached - restart at demo level one
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumDisk_Demo_Min   ; get restart at level 1
                            sta HL_LevelNumDisk             ; set disk level num (000-249) 
; --------------------------------------------------------------------------------------------------------------------- ;
; increase demo speed
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inc HL_GameSpeedCtrl            ; inc game speed ($00-$0a)                                  .hbu003. removed
;                                                                                                                       .hbu003. removed
;                           ldx HL_GameSpeedCtrl            ; get game speed                                            .hbu003. removed
;                           cpx #HL_GameSpeedCtrl_Max       ; test game speed max                                       .hbu003. removed
;                           bcc SetNextDemoLevelDataAddress ; check: LT - yes: bypass correction                        .hbu003. removed
;                                                                                                                       .hbu003. removed
;                           dec HL_GameSpeedCtrl            ; correct game speed to max                                 .hbu003. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data pointer to next demo level data
; --------------------------------------------------------------------------------------------------------------------- ;
IniDemoLevelDataPointers    asl a                           ; *2                                                        .hbu003.
                            tay                             ; set demo level data offset                                .hbu003.
                            lda TabDemoLevelData + $00,y    ;                                                           .hbu003.
                            sta smCopyDemoLevel_Lo          ; address demo level data                                   .hbu003.
                            lda TabDemoLevelData + $01,y    ;                                                           .hbu003.
                            sta smCopyDemoLevel_Hi          ; address demo level data                                   .hbu003.
                            
                            lda TabDemoLevelMoves + $00,y   ;                                                           .hbu003.
                            sta HLZ_DemoMoveDataPtr_Lo      ; pointer DemoMoveData                                      .hbu003.
                            lda TabDemoLevelMoves + $01,y   ;                                                           .hbu003.
                            sta HLZ_DemoMoveDataPtr_Hi      ; pointer DemoMoveData                                      .hbu003.
                            
                            lda #$00                        ;                                                           .hbu003.
                            sta HLZ_DemoMoveDuration        ; ini demo move duration                                    .hbu003.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy demo level data to level data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get demo level data offset
smCopyDemoLevel_Lo          = * + $01                       ;                                                           .hbu003.
smCopyDemoLevel_Hi          = * + $02                       ; 
GetNextDemoLevelDataByte    lda TabDemoDataLevel,y          ; get demo level data                                       .hbu003.
                            sta HL_LevelDataBuf,y           ; 
                            iny                             ; 
                            bne GetNextDemoLevelDataByte    ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoLevelData            = *                        ; 
smTabDemoLevelData_01       = *                        ;                                                                .hbu034.
                            .word TabDemoDataLevel_01  ;                                                                .hbu003.
                            .word TabDemoDataLevel_02  ;                                                                .hbu003.
                            .word TabDemoDataLevel_03  ;                                                                .hbu003.
                            .word TabDemoDataLevel_04  ;                                                                .hbu003.
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoLevelMoves           = *                        ; 
smTabDemoLevelMoves_01      = *                        ;                                                                .hbu034.
                            .word TabDemoMovesLevel_01 ;                                                                .hbu003.
                            .word TabDemoMovesLevel_02 ;                                                                .hbu003.
                            .word TabDemoMovesLevel_03 ;                                                                .hbu003.
                            .word TabDemoMovesLevel_04 ;                                                                .hbu003.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameDemoMoveToggleRec     Does    : toggle demo recording mode at game start
;                           Expects : .A=desired recording mode
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameDemoMoveToggleRec      .block                           ;                                                           .hbu034.
                            sta HL_DemoRec                  ; set desired recording mode                                .hbu034.
                            beq GetDemoRecordingOff         ; check: HL_DemoRec_Off - yes: deactivate recording         .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; init demo move buffers - no buffer overflow check - the game will crash if more than $280 moves are recorded
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; get buffer init value                                     .hbu034.
                            ldy #$00                        ; get buffer offset                                         .hbu034.
IniNextDemoMoveBufEntry     sta HL_BufDemoMoves + $000,y    ; init the $05 available move buffers                       .hbu034.
                            sta HL_BufDemoMoves + $100,y    ;                                                           .hbu034.
                            sta HL_BufDemoMoves + $200,y    ; --> no buffer overflow check <--                          .hbu034.
                            sta HL_BufDemoMoves + $300,y    ; max $280 (640) moves can be recorded                      .hbu034.
                            sta HL_BufDemoMoves + $400,y    ; move #281 starts to overwrite the i/o area at $d000       .hbu034.
                            
                            iny                             ; inc buffer offset                                         .hbu034.
                            bne IniNextDemoMoveBufEntry     ; check: max - no: continue                                 .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; init demo recorder vars and table
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty HLZ_RecordDemoMove          ; ini actual move                                           .hbu034.
                            sty HLZ_RecordDemoMoveBufOff    ; ini record move buffer offset                             .hbu034.
                            sty HLZ_RecordDemoTime          ; ini actual move time                                      .hbu034.
                            
                            sta HLZ_RecordDemoMoveOld       ; ini old move to $ff for 1st comparison                    .hbu034.
                            
                            lda #<HL_BufDemoMoves           ; get buffer address Lo                                     .hbu034.
                            sta HLZ_DemoMoveBufferPtr_Lo    ; set buffer address Lo                                     .hbu034.
                            lda #>HL_BufDemoMoves           ; get buffer address Hi                                     .hbu034.
                            sta HLZ_DemoMoveBufferPtr_Hi    ; set buffer address Hi                                     .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; enable the direct check of the recorded demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #<HL_LevelDataBuf           ; set demo data table entriy to actual level                .hbu034.
                            sty smTabDemoLevelData_01 + $00 ;                                                           .hbu034.
                            ldy #>HL_LevelDataBuf           ;                                                           .hbu034.
                            sty smTabDemoLevelData_01 + $01 ;                                                           .hbu034.
                            
                            ldy #<HL_BufDemoMoves           ; set 1st demo move table entriy to recorded values         .hbu034.
                            sty smTabDemoLevelMoves_01 + $00;                                                           .hbu034.
                            ldy #>HL_BufDemoMoves           ;                                                           .hbu034.
                            sty smTabDemoLevelMoves_01 + $01;                                                           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; save pre replay lives and disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ;                                                           .hbu034.
                            sta HL_LevelNumDiskSave         ;                                                           .hbu034.
                            
                            lda HL_NumLives                 ;                                                           .hbu034.
                            sta HL_NumLivesSave             ;                                                           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare subroutine activation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$a5                        ; get opcode: LDA <ZeroPage>                                .hbu034.
                            lda #GREY                       ; get demo rec border color                                 .hbu034.
                            bne SetDemoRecordingFlags       ; always                                                    .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; switch demo move recording off
; --------------------------------------------------------------------------------------------------------------------- ;
GetDemoRecordingOff         ldy #<TabDemoDataLevel_01       ; reset demo data and move table entries                    .hbu034.
                            sty smTabDemoLevelData_01 + $00 ;                                                           .hbu034.
                            ldy #>TabDemoDataLevel_01       ;                                                           .hbu034.
                            sty smTabDemoLevelData_01 + $01 ;                                                           .hbu034.
                            
                            ldy #<TabDemoMovesLevel_01      ;                                                           .hbu034.
                            sty smTabDemoLevelMoves_01 + $00;                                                           .hbu034.
                            ldy #>TabDemoMovesLevel_01      ;                                                           .hbu034.
                            sty smTabDemoLevelMoves_01 + $01;                                                           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare subroutine deactivation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$60                        ; get opcode: RTS                                           .hbu034.
                            lda #BLACK                      ; get game border color                                     .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; (de)activate demo level recording subroutine
; --------------------------------------------------------------------------------------------------------------------- ;
SetDemoRecordingFlags       ldx #HL_DemoRecReplay_No        ; get flag recorded demo replay mode off                    .hbu034.
                            stx HL_DemoRecReplay            ;                                                           .hbu034.
                            
                            sty GameDemoMoveRecorder.smDemoMoveRecorderStart ; (de)activate the recorder subroutine     .hbu034.
                            sta EXTCOL                      ; VIC($D020) Border Color - (de)activate the recorder color .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset player input - do not start the chase now
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_KeyNew_None             ; get initial value                                         .hbu034.
                            sta HL_KeyNew                   ; ini new key input                                         .hbu034.
                            
                            jmp EditorErrorBeep             ; output a beep signal and return                           .hbu034.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameDemoMoveRecorder      Does    : record loderunner moves for the game start demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameDemoMoveRecorder       .block                           ; 
smDemoMoveRecorderStart     = *                             ;                                                           .hbu034.
                            lda HLZ_RecordDemoMove          ; get actual move                                           .hbu034.
                            ldx HLZ_RecordDemoMoveOld       ; get old move                                              .hbu034.
                            bpl CmpDemoMoveOld              ; check: 1st move - no: continue                            .hbu034.
                            
                            sta HLZ_RecordDemoMoveOld       ; ensure the recording of the 1st move and time             .hbu034.
                            bmi IncDemoMoveTime             ; always                                                    .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
CmpDemoMoveOld              cmp HLZ_RecordDemoMoveOld       ; test if still same move                                   .hbu034.
                            beq IncDemoMoveTime             ; check: same move - yes: inc move time and exit            .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; a new move was found - finish current one
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMoveFinish              ldy HLZ_RecordDemoMoveBufOff    ; get next recording table offset                           .hbu034.
                            lda HLZ_RecordDemoMoveOld       ; get old move                                              .hbu034.
                            sta (HLZ_DemoMoveBufferPtr),y   ; set old move in buffer                                    .hbu034.
                           
                            lda HLZ_RecordDemoMove          ; get actual move                                           .hbu034.
                            sta HLZ_RecordDemoMoveOld       ; set as old move                                           .hbu034.
                            
                            iny                             ; point old move time                                       .hbu034.
                            lda HLZ_RecordDemoTime          ; get old move time                                         .hbu034.
                            sta (HLZ_DemoMoveBufferPtr),y   ; set old move in buffer                                    .hbu034.
                            
                            lda #$01                        ; get init value                                            .hbu034.
                            sta HLZ_RecordDemoTime          ; ini actual move time                                      .hbu034.
                            
                            iny                             ; advance to next free recording buffer entry               .hbu034.
                            sty HLZ_RecordDemoMoveBufOff    ; save next recording buffer offset                         .hbu034.
                            bne GameDemoMoveRecorderX       ; check: 1st buffer full - no                               .hbu034.
                            
                            inc HLZ_DemoMoveBufferPtr_Hi    ; inc buffer address ptr Hi - continue with the next buffer .hbu034.
                            
                            rts                             ; done                                                      .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
IncDemoMoveTime             inc HLZ_RecordDemoTime          ; increase current move time                                .hbu034.
                            
GameDemoMoveRecorderX       rts                             ;                                                           .hbu034.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameDemoMoveInitReplay    Does    : initialize the replay of the recorded demo moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameDemoMoveInitReplay     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; end the demo move recording mode - init the replay of the recorded demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$60                        ; opcode: RTS                                               .hbu034.
                            sta GameDemoMoveRecorder.smDemoMoveRecorderStart ; disable the recorder subroutine          .hbu034.
                            
                            lda #HL_DemoRec_Off             ; get flag demo recording off                               .hbu034.
                            sta HL_DemoRec                  ;                                                           .hbu034.
                            
                            lda #HL_DemoRecReplay_Yes       ; get flag demo recording replay on                         .hbu034.
                            sta HL_DemoRecReplay            ;                                                           .hbu034.
                            
                            lda #DK_GREY                    ; get demo replay color                                     .hbu034.
                            sta EXTCOL                      ; VIC($D020) Border Color                                   .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; last recorded move time needs to be adapted - level finish stopps the recording too early
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_RecordDemoMoveBufOff    ; get offset recording buffer next move                     .hbu034.
                            dey                             ; set offset recording time last move                       .hbu034.
                            lda (HLZ_DemoMoveBufferPtr),y   ; get recording time last move                              .hbu034.
                            clc                             ;                                                           .hbu034.
                            adc #$20                        ; finishing time always too low - add some more             .hbu034.
                            bcc SetNewFinishTime            ; check: overflow - no                                      .hbu034.
                            
                            lda #$ff                        ; get max last move time                                    .hbu034.
                            
SetNewFinishTime            sta (HLZ_DemoMoveBufferPtr),y   ; set correct finish time last move                         .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; beep and auto start the replay
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output a beep signal and return                           .hbu034.
                            jmp DemoGameInit                ; auto start the replay                                     .hbu034.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameDemoMoveStopReplay    Does    : stop the replay of the recorded demo moves and return to game mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameDemoMoveStopReplay     .block                           ; 
                            lda #HL_DemoRec_Off             ; get flag demo recording off                               .hbu034.
                            jsr GameDemoMoveToggleRec       ; switch off demo recording and replay                      .hbu034.
                            
                            lda #HL_GameMode_Play           ; get play mode                                             .hbu034.
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit      .hbu034.
                            
                            lda #HL_KeyNew_None             ;                                                           .hbu034.
                            sta HL_KeyNew                   ; avoid an immediate start                                  .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore pre replay lives and disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_NumLivesSave             ;                                                           .hbu034.
                            sta HL_NumLives                 ;                                                           .hbu034.
                            
                            ldx HL_LevelNumDiskSave         ;                                                           .hbu034.
                            stx HL_LevelNumDisk             ;                                                           .hbu034.
                            stx HL_LevelReload              ; set equal to avoid a level data reload                    .hbu034.
                            
                            inx                             ; set game level number                                     .hbu034.
                            stx HL_LevelNumGame             ;                                                           .hbu034.
                            
                            jmp LevelStart                  ; restart old level                                         .hbu034.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerGetDiskBlockNumber   Does    : calculate the times block number/offset from the disk level number
;                           Expects : .A=disk level number
;                           Returns : .A=offset level times block entry for disk level number
;                                   : .Y=level times block number
;                                   : .C=1 - level times block needs to be loaded
;                                   : .C=0 - level times block already in memory
; --------------------------------------------------------------------------------------------------------------------- ;
TimerGetDiskBlockNumber    .block                           ; 
                            ldy #HL_TimerBuf_BlockNum_01    ; preset disk block num 1                                   .hbu037.
                            
                            cmp #HL_TimerBuf_Entry_Max - $01; test count block 1 max                                    .hbu037.
                            bcc GetBufferBlockSlotNum       ; check: LT - yes: level belongs to block 1                 .hbu037.
                            beq GetBufferBlockSlotNum       ; check: EQ - yes: level belongs to block 1                 .hbu037.
                            
                            iny                             ; set disk block number 2                                   .hbu037.
                            
                            sec                             ;                                                           .hbu037.
                            sbc #HL_TimerBuf_Entry_Max      ;                                                           .hbu037.
                            cmp #HL_TimerBuf_Entry_Max - $01; test count block 2 max                                    .hbu037.
                            bcc GetBufferBlockSlotNum       ; check: LT - yes: level belongs to block 2                 .hbu037.
                            beq GetBufferBlockSlotNum       ; check: EQ - yes: level belongs to block 2                 .hbu037.
                            
                            iny                             ; level belongs to disk block 3                             .hbu037.
                            
                            sec                             ;                                                           .hbu037.
                            sbc #HL_TimerBuf_Entry_Max      ;                                                           .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; disk level timer slot number = disk level number * $03
; --------------------------------------------------------------------------------------------------------------------- ;
GetBufferBlockSlotNum       sta HL_Timer_LevelNumDiskSave   ; save calculated timer disk block number                   .hbu037.
                            
                            asl                             ; disk level number * $02                                   .hbu037.
                            clc                             ;                                                           .hbu037.
                            adc HL_Timer_LevelNumDiskSave   ; disk level number * $03                                   .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; test if the calculated timer disk block is already loaded
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HL_TimerBuf_BlockNum        ; test if timer block is already loaded                     .hbu037.
                            beq TimerBlockLoaded            ; check: EQ - yes: flag no reload                           .hbu037.
                            
                            sec                             ; set flag block needs to be reloaded                       .hbu037.
                            rts                             ;                                                           .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
TimerBlockLoaded            clc                             ; set flag block already loaded                             .hbu037.
                            rts                             ;                                                           .hbu037.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerDiskHandler          Does    : read or write the times block for the disk level number
;                           Expects : .A=$01 - Read times disk block belonging to the disk level number
;                                   : .A=$81 - Read  -> .Y=level times block number
;                                   : .A=$02 - Write -> .Y=level times block number
;                           Returns : .A=offset level times block entry for disk level number
;                                   : .Y=level times block number
; --------------------------------------------------------------------------------------------------------------------- ;
TimerDiskHandler           .block                           ; 
                            sta HL_Timer_ModeSave           ; save disc access flag                                     .hbu037.
                            
                            lda HL_LevelNumDisk             ; get disk level number (000-249)                           .hbu037.
                            sta HL_LevelNumDiskSave         ; save disk level number                                    .hbu037.
                            
                            inc DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; select times read  buffer                      .hbu037.
                            inc DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; select times write buffer                    .hbu037.
                            
                            ldx HL_Timer_ModeSave           ; restore disk access flag                                  .hbu037.
                            bmi ForceTimesBlock             ; check: HL_DiskForce_Times - yes: force a READ             .hbu037.
                            
                            cpx #HL_DiskWrite               ; test flag timer block WRITE                               .hbu037.
                            bne GetTimerBlockNumber         ; check: EQ - no: bypass unconditional WRITE                .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; if an explicit WRITE is requested the timer block number in .Y is always fix
; --------------------------------------------------------------------------------------------------------------------- ;
ForceTimesBlock             sty HL_LevelNumDisk             ; set timer block number (253-255)                          .hbu037.
                            
                            lda HL_Timer_ModeSave           ; restore disc access flag                                  .hbu037.
                            jsr DiskOperationHandler        ; write timer block to disk                                 .hbu037.
                            jmp TimerDiskHandlerX           ; exit                                                      .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate the DISK level number for timer block READ
; --------------------------------------------------------------------------------------------------------------------- ;
GetTimerBlockNumber         jsr TimerGetDiskBlockNumber     ; get times disk block number for this level                .hbu037.
                            bcc TimerDiskHandlerX           ; check: timer block reload - no: exit                      .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; required timer disk level block not in buffer - load it 1st
; --------------------------------------------------------------------------------------------------------------------- ;
                            pha                             ; save offset level number entry in timer block             .hbu037.
                            sty HL_LevelNumDisk             ; preset timer block number (253-255)                       .hbu037.
                            
                            lda HL_TimerBuf_Mod             ; get level times modification flag                         .hbu037.
                            bpl IniReadTimerBlock           ; check: modified - no: simply read the necessary block     .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; a modified level times block needs to be saved 1st
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get timer block number (253-255)                          .hbu037.
                            pha                             ; save timer block number (253-255)                         .hbu037.
                            
                            asl HL_TimerBuf_Mod             ; set HL_TimerBuf_Mod_No                                    .hbu037.
                            
                            lda HL_TimerBuf_BlockNum        ; get THIS times block number                               .hbu037.
                            sta HL_LevelNumDisk             ; set timer block number (253-255)                          .hbu037.
                            
                            lda #HL_DiskWrite               ; get WRITE flag                                            .hbu037.
                            jsr DiskOperationHandler        ; write timer block to disk                                 .hbu037.
                            
                            pla                             ; restore offset level number entry in timer block          .hbu037.
                            sta HL_LevelNumDisk             ; set timer block number (253-255)                          .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; read in the missing level times block
; --------------------------------------------------------------------------------------------------------------------- ;
IniReadTimerBlock           lda #HL_DiskRead                ; get READ flag                                             .hbu037.
                            jsr DiskOperationHandler        ; read timer block from disk                                .hbu037.
                            
                            pla                             ; restore offset level number entry in timer block          .hbu037.
                            ldy HL_LevelNumDisk             ; get timer block number (253-255)                          .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore values and exit
; --------------------------------------------------------------------------------------------------------------------- ;
TimerDiskHandlerX           ldx HL_LevelNumDiskSave         ; restore disk level number                                 .hbu037.
                            stx HL_LevelNumDisk             ; set disk level number (000-249)                           .hbu037.
                            
                            dec DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; reset to level data read buffer                .hbu037.
                            dec DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; reset to level data write buffer             .hbu037.
                            
                            rts                             ;                                                           .hbu037.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerCheckNewRecord       Does    : check and eventually set a new level record time
;                           Expects : .A=offset level times block entry for disk level number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerCheckNewRecord        .block                           ; 
                            tay
                            sty HL_Timer_LevelBlockOff      ; restore offset level number entry in timer block          .hbu037.

                            lda HL_Timer_BCD_Mins           ; test with new mins                                        .hbu037.
                            cmp HL_TimerBuf,y               ; get old mins                                              .hbu037.
                            bcc InsertNewRecord             ; check: LT - yes: new record                               .hbu037.
                            bne NoNewRecord                 ; check: GE - yes: no new record                            .hbu037.
                            
                            iny                             ;                                                           .hbu037.
                            lda HL_Timer_BCD_Secs           ; test with new secs                                        .hbu037.
                            cmp HL_TimerBuf,y               ; get old secs                                              .hbu037.
                            bcc InsertNewRecord             ; check: LT - yes: new record                               .hbu037.
                            bne NoNewRecord                 ; check: GE - yes: no new record                            .hbu037.
                            
                            iny                             ;                                                           .hbu037.
                            lda HL_Timer_BCD_10th           ; test with new 10th                                        .hbu037.
                            cmp HL_TimerBuf,y               ; get old 10th                                              .hbu037.
                            bcs NoNewRecord                 ; check: GE - yes: no new record                            .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; insert the new best time
; --------------------------------------------------------------------------------------------------------------------- ;
InsertNewRecord             ldy HL_Timer_LevelBlockOff      ; restore offset level number entry in timer block          .hbu037.
                            lda HL_Timer_BCD_Mins           ;                                                           .hbu037.
                            sta HL_TimerBuf,y               ;                                                           .hbu037.

                            iny                             ;                                                           .hbu037.
                            lda HL_Timer_BCD_Secs           ;                                                           .hbu037.
                            sta HL_TimerBuf,y               ;                                                           .hbu037.
                            
                            iny
                            lda HL_Timer_BCD_10th           ;                                                           .hbu037.
                            sta HL_TimerBuf,y               ;                                                           .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; set level times data modified flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TimerBuf_Mod_Yes        ;                                                           .hbu037.
                            sta HL_TimerBuf_Mod             ;                                                           .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; set color for new record time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_CYAN_LT_GREEN           ; get the new best time color                               .hbu038.
                            sta HL_ColorTimerMsg            ; set the new best time color                               .hbu038.
                            rts                             ; exit with new color                                       .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
NoNewRecord                 lda #HR_CYAN_LT_GREY            ; get standard level time color                             .hbu038.
                            sta HL_ColorTimerMsg            ; set standard level time color                             .hbu038.
                            
TimerCheckNewRecordX        rts                             ; exit with standard color                                  .hbu037.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TimerShowRecordHandler    Does    : display a possible level best time
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TimerShowRecordHandler     .block                           ; 
                            lda #HL_DiskRead                ;                                                           .hbu038.
                            jsr TimerDiskHandler            ; get the correct level times block for THIS level          .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if THIS level already has a best time
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNewRecord              tay                             ; get offset level times block entry for disk level number  .hbu038.
                            ldx HL_TimerBuf + $02,y         ; get best 10th                                             .hbu038.
                            cpx #$99                        ; test initial value                                        .hbu038.
                            beq CheckNewRecordX             ; check: EQ - yes: not best times available for this level  .hbu038.
; --------------------------------------------------------------------------------------------------------------------- ;
; display the level best time
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TimerRecordOut              ; print the levels best time in the status row message area .hbu038.
                            
CheckNewRecordX             rts                             ;                                                           .hbu038.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreDiskHandler          Does    : read or write the scores block
;                           Expects : .A=$81 - Read
;                                   : .A=$82 - Write
;                           Returns : .A=HL_ScoreBufCheck_Bad     - loderunner disk ID not found
;                                   : .A=HL_ScoreBufCheck_Mod_No  - loderunner master disk
;                                   : .A=HL_ScoreBufCheck_Mod_Yes - loderunner player level data disk
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreDiskHandler           .block                           ; 
                            tax                             ; save access type - 81=read 82=write
                            
                            lda HL_LevelNumDisk             ; get disk level number (000-249)
                            pha                             ; save disk level number
                            
                            dec DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; select score read buffer                       .hbu037.
                            dec DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; select score write buffer                    .hbu037.
                            
                            lda #HL_LevelNumDisk_Score      ; get disk level 251 - stores the leaderboard data
                            sta HL_LevelNumDisk             ; set disk level number 251
                            
                            txa                             ; restore access type - 01=read 02=write
                            jsr DiskOperationHandler        ; read leaderboard block from disk
                            
                            pla                             ; restore disk level number
                            sta HL_LevelNumDisk             ; set disk level number (000-249)
                            
                            inc DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; reset to level data read buffer                .hbu037.
                            inc DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; reset to level data write buffer             .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; init check loderunner disk id DANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length of loderunner disk id string
                            
                            lda #$00                        ; get initial value
                            sta HLZ_WorkChkDiskIdResult     ; ini check result
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk id DANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDiskIdChar           lda HL_ScoreBufDiskId,y         ; get a loderunner disk id char
                            eor TabLodeRuDiskId,y           ; flip with tabled disk id char
                            ora HLZ_WorkChkDiskIdResult     ; insert old check result
                            sta HLZ_WorkChkDiskIdResult     ; set new check result
                            
                            dey                             ; dec disk id length
                            bpl GetNextDiskIdChar           ; check: end of disk id string - no: continue
                            
                            lda HLZ_WorkChkDiskIdResult     ; get check result
                            beq ChkLoderunnerDiskFlag       ; check: disk id correct - yes: loderunner data disk in drive
                            
                            lda #HL_ScoreBufCheck_Bad       ; get flag loderunner disk ID not found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set correct disk flag
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLoderunnerDiskFlag       lda #HL_ScoreBufCheck_Mod_No    ; preset flag disk in drive is a non modifiable loderunner master disk
                            
                            ldx HL_ScoreBufCheck            ; get disk block indicator flag
                            bne ScoreDiskHandlerX           ; check: player data disk - no: exit
                            
                            lda #HL_ScoreBufCheck_Mod_Yes   ; get flag disk in drive is a modifiable player level disk
                            
ScoreDiskHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskError                 Does    : jump back to start in case of a disk error
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskError                  .block                           ; 
                            lda #$02                        ; get mid wait time                                         .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.
                            
                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecRead           Does    : read a disk block into a preset data buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecRead            .block                           ; 
                            lda #"1"                        ; get command id read
                            sta TabDiskCmd_CmdType          ; set command id to u1=read
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk read command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get ini offset cmd string
PutNextDiskCmdCharRead      lda TabDiskCmd,y                ; get disk command string - u1:02 0 tt .ss
                            beq GoDiskCmdCheckRC            ; check: end of cmd string - yes: check RC
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc cmd string offset
                            jmp PutNextDiskCmdCharRead      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check rc
; --------------------------------------------------------------------------------------------------------------------- ;
GoDiskCmdCheckRC            jsr DiskCmdCheckRC              ; check the disk command return code
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; overread the 1st block used byte count byte - will be added to the very end of the block data as 256 bytes are read
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
; --------------------------------------------------------------------------------------------------------------------- ;
; check read scores
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DiskAction               ; $01=read $02=write $04=init $81=read $82=write            .hbu018.
                            bmi IniGetDiskByte              ; bypass mirror check in case of a score block read         .hbu018.
; --------------------------------------------------------------------------------------------------------------------- ;
; read in disk buffer
; --------------------------------------------------------------------------------------------------------------------- ;
IniGetDiskByte              ldy #$00                        ; get ini get byte count                                    .hbu018.
GetNextDiskByte             jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
smSetDiskReadBufPtr_Hi      = * + $02                       ; 
                            sta HL_LevelDataBuf,y           ; set get store disk data byte
                            
                            iny                             ; inc get byte count
                            bne GetNextDiskByte             ; check: 255 bytes read - no: continue
                            
;                           jmp DiskCmdResetSpeed           ; activate the slow 1542 C64 mode                           .hbu016. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; check if level has to be mirrored
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeMirror               ; get flag mirror level                                     .hbu018.
                            beq CloseFiles                  ; check: HL_ModeMirror_Off - yes: bypass mirror             .hbu018.
                            
                            jsr LED_MirrorLevel             ; mirror an already loaded level                            .hbu018.
                            
CloseFiles                  jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)         .hbu016.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdStringInit         Does    : init disk command string for read/write/init
;                           Expects : .A=mode $01=read $02=write $04=init
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
;DiskCmdStringInit          .block                           ;                                                          .hbu002. removed
;                            lda #SPENA_ALL_OFF              ; get switch off all sprites                               .hbu002. removed
;                            sta SPENA                       ; VIC($D015) Sprite Enable Register                        .hbu002. removed
;                            
;                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)        .hbu002. removed
;                            
;                            ldx #"0"                        ; preset sector number HI for sector values below 10       .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate sector/track numbers from disk level number
; each track contains 16 level blocks ($00-$0f)
; start track is track 3
; --------------------------------------------------------------------------------------------------------------------- ;
;                            lda HL_LevelNumDisk             ; get disk level num (000-249)                             .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; Sector_number = HL_LevelNumDisk MOD 15
; --------------------------------------------------------------------------------------------------------------------- ;
;                            and #$0f                        ; get the rest of the division by 15                       .hbu002. removed
;                            
;                            cmp #$0a                        ; test value 10                                            .hbu002. removed
;                            bcc PutSectorNum_Hi             ; check: LT - yes: set sector number HI                    .hbu002. removed
;                            
;                            ldx #"1"                        ; get sector number HI for sector values above 9           .hbu002. removed
;                            
;                            sec                             ;                                                          .hbu002. removed
;                            sbc #$0a                        ; subtract 10 for 1s part                                  .hbu002. removed
;                            
;PutSectorNum_Hi             stx TabDiskCmd_Sec_Hi           ; set disk comand sector number HI                         .hbu002. removed
;                            
;                            clc                             ;                                                          .hbu002. removed
;                            adc #"0"                        ; generate char digit 0-9 from binary                      .hbu002. removed
;                            sta TabDiskCmd_Sec_Lo           ; set disk comand sector number LO                         .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
;                            lda HL_LevelNumDisk             ; get disk level num (000-249)                             .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; Track_number = INT(HL_LevelNumDisk/16)
; --------------------------------------------------------------------------------------------------------------------- ;
;                            lsr a                           ; /2                                                       .hbu002. removed
;                            lsr a                           ; /4                                                       .hbu002. removed
;                            lsr a                           ; /8                                                       .hbu002. removed
;                            lsr a                           ; /16                                                      .hbu002. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; add start track number
; --------------------------------------------------------------------------------------------------------------------- ;
;                            clc                             ;                                                          .hbu002. removed
;                            adc #HL_LevelDataStartTrackNum  ; add start level data track 3                             .hbu002. removed
;                            
;                            ldx #"0"                        ; preset track number HI for track values below 10         .hbu002. removed
;                            
;                            cmp #$0a                        ; test value 10                                            .hbu002. removed
;                            bcc PutTrackNum_Hi              ; check: LT - yes: set track number HI                     .hbu002. removed
;                            
;                            ldx #"1"                        ; get track number HI for track values above 9             .hbu002. removed
;                            
;                            sec                             ;                                                          .hbu002. removed
;                            sbc #$0a                        ; subtract 10 for 1s part                                  .hbu002. removed
;                            
;PutTrackNum_Hi              stx TabDiskCmd_Trk_Hi           ; set disk comand track number HI                          .hbu002. removed
;                            
;                            clc                             ;                                                          .hbu002. removed
;                            adc #"0"                        ; generate char digit 0-9 from binary                      .hbu002. removed
;                            sta TabDiskCmd_Trk_Lo           ; set disk comand track number LO                          .hbu002. removed
;                           .bend                            ;                                                          .hbu002. removed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdHandler            Does    : open channels and device for read/write/init commands
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdHandler             .block                           ; 
                            lda #SPENA_ALL_OFF              ; switch off all sprites                                    .hbu002.
                            sta SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu002.
                            
                            lda HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu002.
                            ldx #$08                        ; drive no                                                  .hbu002.
                            jsr DiskCmdStringHandler        ; generate the block access command and open channels       .hbu002.
                            bcs DiskError                   ; check: disk error - yes: restart                          .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; check requested disk action
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DiskAction               ; $01=read $02=write $04=init $81=read $82=write            .hbu002.
                            lsr a                           ; shift READ bit to .C
                            bcs DiskCmdExecRead             ; check: READ mode - yes: exec READ
                            
                            lsr a                           ; shift WRITE bit to .C
                            bcc DiskCmdExecInit             ; check: WRITE mode - no: exec INIT
                            
                            jmp DiskCmdExecWrite            ; exec write
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecWrite          Does    : write a disk block from a preset data buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWrite           .block                           ; 
                            lda #"2"                        ; get command id write 
                            sta TabDiskCmd_CmdType          ; set u2=write
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; write out data buffer to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini level data pointer
smSetDiskWriteBufPtr_Hi     = * + $02                       ; 
GetNextPackedLevelDataByte  lda HL_LevelDataBuf,y           ; get data byte
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc level data pointer
                            bne GetNextPackedLevelDataByte  ; check: max - no: continue
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk write command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get command string offset
PutNextDiskCmdCharWrite     lda TabDiskCmd,y                ; get disk command string u2:02 0 tt ss
                            beq DiskCmdExecWriteX           ; check: EoC mmarker - yes: exit
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc command string offset
                            jmp PutNextDiskCmdCharWrite     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWriteX           jsr DiskCmdCheckRC              ; check the disk command return code                        .hbu016.
;                           jmp DiskCmdResetSpeed           ; activate the slow 1542 C64 mode                           .hbu016.
                            jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)         .hbu016.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecInit           Does    : initialize a loderunner level data disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecInit            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize score and level data buffers
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini buffer offset
                            tya                             ; ini buffer data value
ClearNextBufferByte         sta HL_ScoreBuf,y               ; clear HI score buffer
                            sta HL_LevelDataBuf,y           ; clear packed level data buffer
                            
                            iny                             ; inc buffer offset
                            bne ClearNextBufferByte         ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init level data with a loderunner tile to ease the Board Editor start
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty | HL_TileNum_LodeRunner ;  get a loderunner tile                      .hbu037.
                            sta HL_LevelDataBuf + HL_LevelDataBufData_Len - HL_LevelDataBufDataCols ; set loderunner    .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; init the level success message buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_LevelDataBufMsgTxt_Len - $01 ; ini msg buffer offset                                .hbu037.
ClrNextMsgBufByte           lda TabLevelMsgDefault,y        ; get get a default msg text byte                           .hbu037.
                            sta HL_LevelDataBufMsgTxt,y     ; ini the msg buffer                                        .hbu037.
                            
                            dey                             ; dec msg buffer offset                                     .hbu037.
                            bpl ClrNextMsgBufByte           ; check: min - no: continue                                 .hbu037.
; --------------------------------------------------------------------------------------------------------------------- ;
; init write of 250 level blocks
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumDisk_Max        ; get 249 blocks to write
                            sta HL_LevelNumDisk             ; ini disk level num (000-249)
                            
;                           jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)         .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; write 250 empty level blocks
; --------------------------------------------------------------------------------------------------------------------- ;
WriteNextLevelDataBlock     lda #HL_DiskWrite               ; get flag write 250 empty levels to disk
                            jsr DiskOperationHandler        ; write block to disk
                            
                            dec HL_LevelNumDisk             ; dec disk level num (000-249)
                            
                            lda HL_LevelNumDisk             ; get disk level num (000-249) 
                            cmp #$ff                        ; test min
                            bne WriteNextLevelDataBlock     ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with loderunner disk string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length loderunner disk id string
SetNextDiskIdChar           lda TabLodeRuDiskId,y           ; get loderunner disk id=DANE BIGHAM
                            sta HL_ScoreBufDiskId,y         ; set store as loderunner disk id in HI score data block
                            
                            dey                             ; dec length loderunner disk id sting
                            bpl SetNextDiskIdChar           ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with player level id flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; flag HL_DiskUserData
                            sty HL_ScoreBufCheck            ; set indicator store in Highscore block
; --------------------------------------------------------------------------------------------------------------------- ;
; write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_DiskWrite | HL_DiskForce_Score ; write with flag force score processing             .hbu016.
                            jsr ScoreDiskHandler            ; write out the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; write save games block and three level time blocks
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameStorageBlockClear       ; init and write the game save entries block                .hbu039.
                            jmp GameTimeBlocksClear         ; init and write the level best times data blocks           .hbu039.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
;                           .byte $00 ; <obsolete>                                                                      .hbu001.
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdStringHandler      Does    : generate the block access command and open channels
;                           Expects : .A=disk level number
;                                   : .X=drive number
;                           Returns : .C=0 - OK
;                                   : .C=1 - disc error
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdStringHandler       .block                           ;                                                           .hbu002.
                            stx HL_DiscCmdDriveNum          ; save drive number                                         .hbu002.
                            
                            bit HL_DiskAction               ; $01=read $02=write $04=init $81/$c1=read $82/$c2=write    .hbu002.
                            bvc IniLevelDataCmd             ; check: RND block flag set - no: process level data blocks .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle RND level data blocks
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_SaveGameBuf_RND_BAM_Trk - $01 ; get RND data track number                           .hbu028.
                            stx HL_Digit_10                 ; set RND data track number                                 .hbu028.
                            
                            clc                             ;                                                           .hbu028.
                            adc #HL_SaveGameBuf_RND_BAM_Sec ; add RND data sector numbers start to disk level number    .hbu028.
                            bne GetSectorNum                ; always - set up the disk command string                   .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate level data blocks track/sector number from the level number
; --------------------------------------------------------------------------------------------------------------------- ;
IniLevelDataCmd             ldx #$00                        ; get initial value                                         .hbu002.
                            stx HL_Digit_10                 ; ini track number count                                    .hbu002.
CountNextTrackNum           cmp #TabDiskBlock_Sec_Max       ; test max sector number for this track                     .hbu002.
                            bcc GetSectorNum                ; check: done - yes: remainder is the sector number         .hbu002.
                            
                            inc HL_Digit_10                 ; inc track number count                                    .hbu002.
                            
                            sbc #TabDiskBlock_Sec_Max       ; sub max sector number for this track                      .hbu002.
                            bne CountNextTrackNum           ; check: <ZERO> - no: continue counting up tracks           .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; insert block sector number                                                                                            .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
GetSectorNum                tax                             ; get the remainder as sector number table offset           .hbu002.
                            lda TabDiskBlockSec_Hi,x        ; get block sector number                                   .hbu002.
                            sta TabDiskCmd_Sec_Hi           ;                                                           .hbu002.
                            lda TabDiskBlockSec_Lo,x        ;                                                           .hbu002.
                            sta TabDiskCmd_Sec_Lo           ;                                                           .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; insert block track number                                                                                             .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_Digit_10                 ; get block track count as track number table offset        .hbu002.
                            lda TabDiskBlockTrk_Hi,x        ; get block track number                                    .hbu002.
                            sta TabDiskCmd_Trk_Hi           ;                                                           .hbu002.
                            lda TabDiskBlockTrk_Lo,x        ;                                                           .hbu002.
                            sta TabDiskCmd_Trk_Lo           ;                                                           .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; close all channels first                                                                                              .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)         .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; open the command channel                                                                                              .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #KV_SETNAM_FILENAM_NONE     ; get flag: no filename                                     .hbu002.
                            jsr SETNAM                      ; KERNAL - $FFBD = Set Filename Parameters                  .hbu002.
                            
                            lda #SA_CHANNEL_CMD             ; get channel number: command channel                       .hbu002.
                            ldx HL_DiscCmdDriveNum          ; get drive number                                          .hbu002.
                            ldy #$0f                        ; get secondary address                                     .hbu002.
                            jsr SETLFS                      ; KERNAL - $FFBA = Set Logical File Parameters              .hbu002.
                            jsr OPEN                        ; KERNAL - $FFC0 = Open a Logical File                      .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; open the data channel                                                                                                 .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #FileNameString_Len         ; get length data set name '#'                              .hbu002.
                            ldx #<FileNameString            ; get address filename LO                                   .hbu002.
                            ldy #>FileNameString            ; get address filename HI                                   .hbu002.
                            jsr SETNAM                      ; KERNAL - $FFBD = Set Filename Parameters                  .hbu002.
                            
                            lda #$02                        ; get channel number: data                                  .hbu002.
                            ldx HL_DiscCmdDriveNum          ; get drive number                                          .hbu002.
                            ldy #$02                        ; get secondary address                                     .hbu002.
                            jsr SETLFS                      ; KERNAL - $FFBA = Set Logical File Parameters              .hbu002.
                            jsr OPEN                        ; KERNAL - $FFC0 = Open a Logical File                      .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ;                                                           .hbu002.
                           .bend                            ;                                                           .hbu002.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
FileNameString              .byte "#" ; 
FileNameString_Len          = * - FileNameString ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmd                  = *       ; 
                            .byte "u" ; user command id
TabDiskCmd_CmdType          .byte "1" ; user command type - 1=read  2=write
                            .byte ":" ; 
                            .byte "0" ; channel number
                            .byte "2" ; 
                            .byte " " ; 
                            .byte "0" ; drive number
                            .byte " " ; 
TabDiskCmd_Trk_Hi           .byte "0" ; track number HI
TabDiskCmd_Trk_Lo           .byte "3" ; track number LO
                            .byte " " ; 
TabDiskCmd_Sec_Hi           .byte "0" ; sector number HI
TabDiskCmd_Sec_Lo           .byte "0" ; sector number LO
                            .byte CR  ; <ENTER>
                            
                            .byte $00 ; End of String marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskBlockTrk_Hi          .byte "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1"   ; .hbu002.
TabDiskBlockTrk_Lo          .byte "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "1", "2", "3", "4", "5", "6", "7"   ; .hbu002.
                            
TabDiskBlockSec_Hi          .byte "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "2" ; .hbu002.
TabDiskBlockSec_Lo          .byte "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ; .hbu002.
TabDiskBlock_Sec_Max        = * - TabDiskBlockSec_Lo ; max sector number for track 1-17 ($14)                                             ; .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
;DiskCmdSetSlowMode         = *       ;                                                                                 .hbu016. removed
;                           .byte "u" ; user command id                                                                 .hbu016. removed
;                           .byte "+" ; set slow C64 mode                                                               .hbu016. removed
;                           
;                           .byte CR  ; <ENTER>                                                                         .hbu016. removed
;                           .byte $00 ; End of String marker                                                            .hbu016. removed
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdCheckRC            Does    : check the disk command return code
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRC             .block                           ; 
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            sta HLZ_WorkDiskRC              ; set disk RC number 1st part
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            ora HLZ_WorkDiskRC              ; insert disk RC number 2nd part
                            sta HLZ_WorkDiskRC              ; set combined disk RC number
                            
GetNextDiskMsgChar          jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            cmp #CR                         ; test <ENTER>
                            bne GetNextDiskMsgChar          ; check: EQ - no: read rest of the message
                            
                            lda HLZ_WorkDiskRC              ; get combined disk RC number
                            cmp #"0"                        ; test OK
                            beq DiskCmdCheckRCX             ; check: EQ - yes: good end
                            
                            jmp ColdStart                   ; bad end - disk error - restart
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRCX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdResetSpeed         Does    : activate the slow 1541 C64 mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
;DiskCmdResetSpeed         .block                           ;                                                           .hbu016. removed
;                           jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333) .hbu016. removed
;                           
;                           ldx #SA_CHANNEL_CMD             ; get command channel number                                .hbu016. removed
;                           jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250).hbu016. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk command string
; --------------------------------------------------------------------------------------------------------------------- ;
;                           ldy #$00                        ; ini disk command offset                                   .hbu016. removed
;GetNextDiskCmdChar         lda DiskCmdSetSlowMode,y        ; get cmd u+                                                .hbu016. removed
;                           beq DiskCmdResetSpeedX          ; check: EoC marker - yes: exit                             .hbu016. removed
;                           
;                           jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)      .hbu016. removed
;                           
;                           iny                             ; inc disk command offset                                   .hbu016. removed
;                           jmp GetNextDiskCmdChar          ;                                                           .hbu016. removed
; --------------------------------------------------------------------------------------------------------------------- ;
;DiskCmdResetSpeedX         jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)         .hbu016. removed
;                          .bend                            ;                                                           .hbu016. removed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelSpecialTileHandler   Does    : handle special level tiles and set up prepare gfx screen
;                           Expects : 
;                           Returns : .C=1 - no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
LevelSpecialTileHandler    .block                           ; 
                            ldy #HLZ_ScreenRow_Max          ; get max - start at bottom of screen
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #SPENA_ALL_OFF              ; get switch off sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data row pointers
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init row column offset to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HLZ_ScreenCol_Max          ; get max cols - start at rightmost column 
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get next level data col byte for this row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLevelDataByte        lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            
                            ldx HL_OutToScreenPrep          ; get flag level disk load control
                            beq GoLevelTileOutToScreenPrep  ; check: HL_OutToScreenPrep_Yes - yes: out to prepare screen
; --------------------------------------------------------------------------------------------------------------------- ;
; handle hidden ladders
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LadderExit      ; test hidden ladder
                            bne HandleGold                  ; check: EQ - no: handle gold next
                            
                            ldx HL_ExitLadderCount          ; get actual number of hidden ladders
                            inx                             ; inc number of hidden ladders                              .hbu030.
;                           cpx #HL_ExitLadderCount_Max - $03 ; test max                                                .hbu030. removed
                            cpx #HL_ExitLadderCount_Max     ; test max                                                  .hbu030.
                            bcs SetLevelTileBlank           ; check: GT - yes: do not count and blank it out
                            
SetNewLadderCount           stx HL_ExitLadderCount          ; set actual number of hidden ladders                       .hbu030.
; --------------------------------------------------------------------------------------------------------------------- ;
; count hidden ladder and store its position
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inc HL_ExitLadderCount          ; inc number of hidden ladders                              .hbu030. removed
                            
;                           inx                             ; inc table offset                                          .hbu030. removed
SetLevelTileLadderWork      lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta HL_WA_ExitLadderRow,x       ; set row number in hidden ladder row table
                            
                            tya                             ; get hidden ladder column
                            sta HL_WA_ExitLadderCol,x       ; set column number in hidden ladder column table
; --------------------------------------------------------------------------------------------------------------------- ;
; insert a blank level tile into game/ctrl level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelTileBlank           lda #HL_TileNum_Empty           ; get empty tile for hidden ladder/enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
GoLevelTileOutToScreenPrep  beq LevelTileOutToScreenPrep    ; always - branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level gold
; --------------------------------------------------------------------------------------------------------------------- ;
HandleGold                  cmp #HL_TileNum_Gold            ; test gold
                            bne HandleEnemies               ; check: EQ - no: handle enemy next
                            
                            inc HL_GoldToCollect            ; count level gold to collect
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level enemies
; --------------------------------------------------------------------------------------------------------------------- ;
HandleEnemies               cmp #HL_TileNum_Enemy           ; test enemy
                            bne HandleLoderunner            ; check: EQ - no: handle loderunner next
                            
                            ldx HL_EnemyCount               ; get number of enemies ($00-$05)
                            cpx #HL_EnemyCount_Max          ; test max of 5
                            bcs SetLevelTileBlank           ; check: GE - yes: bypass enemy 
                            
                            inc HL_EnemyToMoveNum           ; inc number of enemies to move
                            inc HL_EnemyCount               ; inc number of enemies ($00-$05)
                            
                            inx                             ; inc enemy count for table offset
                            tya                             ; get column number
                            sta HL_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta HL_SA_EnemyRow,x            ; set enemy save area row
                            
                            lda #$00                        ; get initial value
                            sta HL_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta HL_SA_EnemySprtNum,x        ; ini actual enemy sprite number
                            
                            lda #HL_PosOnImage_Center       ; get centered position
                            sta HL_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            sta HL_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get empty space
                            sta (HLZ_LevelDataCtrlPtrRow),y ; clear enemy in play level ctrl data ($0a00-$0bc3)
                            
                            lda #HL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #HL_TileNum_Enemy           ; get enemy
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargements
; --------------------------------------------------------------------------------------------------------------------- ;
;GoSetNextLevelDataRowPtr   bpl SetNextLevelDataRowPtr      ; always - branch enlargement                               .hbu030. removed
;GoGetNextLevelDataByte     bpl GetNextLevelDataByte        ; always - branch enlargement                               .hbu030. removed
GoSetNextLevelDataRowPtr    jmp SetNextLevelDataRowPtr      ; branch enlargement                                        .hbu030.
GoGetNextLevelDataByte      jmp GetNextLevelDataByte        ; branch enlargement                                        .hbu030.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
HandleLoderunner            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne ChkTrapDoorDisplay          ; check: EQ - no: handle trapdoors next
; --------------------------------------------------------------------------------------------------------------------- ;
; take the 1st one only - ignore the rest
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            bpl SetLevelTileBlank           ; check: loderunner found already - yes: blank this one out
                            
                            sty HLZ_LodeRuCol               ; ini actual col loderunner
                            
                            ldx HLZ_ScreenRow               ; get screen row ($00-$0f)
                            stx HLZ_LodeRuRow               ; ini actual row loderunner
                            
                            ldx #HLZ_LodeRuOnImgPosX_Mid    ; get middle
                            stx HLZ_LodeRuOnImgPosX         ; ini loderunner pos on image left/right
                            stx HLZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            ldx #TabNumSpriteLodeRu_RuRi_Min; get sprite number run right start                         .hbu000.
                            stx HLZ_LodeRuSprtNum           ; ini loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get empty space
                            sta (HLZ_LevelDataCtrlPtrRow),y ; clear loderunner in play level ctrl data ($0a00-$0bc3)
                            
                            lda #HL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; hide tap doors from display
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTrapDoorDisplay          cmp #HL_TileNum_BrickTrap       ; test trap door
                            bne LevelTileOutToScreenPrep    ; check: EQ - no
                            
                            lda #HL_TileNum_BrickSoft       ; get blank trap door gfx substitution
; --------------------------------------------------------------------------------------------------------------------- ;
; output level tile to prepare gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
LevelTileOutToScreenPrep    jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen column down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_ScreenCol               ; set next screen col (00-1b) bottom up
                            ldy HLZ_ScreenCol               ; get screen col (00-1b)
                            bpl GoGetNextLevelDataByte      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_ScreenRow               ; dec screen row (00-0f) - bottom up
                            ldy HLZ_ScreenRow               ; get screen row (00-0f)
                            bpl GoSetNextLevelDataRowPtr    ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; special level tiles handled - prepare gfx screen set up
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_OutToScreenPrep          ; get flag copy data to prepare hires screen
                            beq ScreenCopyDispToPrep        ; check: HL_OutToScreenPrep_Yes - yes: copy display to prepare screen
                            
                            lda HLZ_LodeRuCol               ; get actual col loderunner
                            bpl GameInitStatusRows          ; check: loderunner tile found - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; error end no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set error flag no loderunner tile found
                            rts                             ; exit with error flag set
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenCopyDispToPrepColor Does    : copy the colored display gfx hires screen data to the prepared hires gfx screen 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenCopyDispToPrepColor  .block                           ; 
                            jsr ColorLevelSelect            ; select a new color combination every 10th level           .hbu002.
                            jsr ColorLevel                  ; set new colors                                            .hbu002.
                            jsr ColorStatus                 ; fill the status row with the selected colors              .hbu002.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenCopyDispToPrep      Does    : copy the display gfx hires screen data to the prepared hires gfx screen 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenCopyDispToPrep       .block                           ; 
                            lda #>HL_ScreenGfxDisplay       ; get display hires screen address HI
                            sta HLZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            lda #>HL_ScreenGfxPrepare       ; get prepare hires screen address HI
                            sta HLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            lda #$00                        ; get display/prepare hires screen address LO
                            sta HLZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            sta HLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            tay                             ; ini page offset
GetNextScrnGfxDispByte      lda (HLZ_ScreenGfxDisplayPtr),y ; get screen display byte
                            sta (HLZ_ScreenRowPreparePtr),y ; set screen prepare byte
                            
                            iny                             ; inc page offset
                            bne GetNextScrnGfxDispByte      ; check: page copied - no: continue
                            
                            inc HLZ_ScreenRowPreparePtr_Hi  ; inc screen prepare start of row pointer HI
                            inc HLZ_ScreenRowDisplayPtr_Hi  ; inc screen display start of row pointer LO
                            
                            ldx HLZ_ScreenRowDisplayPtr_Hi  ; get screen display start of row pointer LO
                            cpx #>HL_ScreenGfxPrepareEnd + $01 ; test end of copy reached
                            bcc GetNextScrnGfxDispByte      ; check: end of copy - no: continue
                            
                            clc                             ; set flag all ok
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameInitStatusRows        Does    : prepare the status rows on both gfx screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameInitStatusRows         .block                           ; 
                            lda #>HL_ScreenGfxPrepare       ; get gfx prepare screen
                            sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            jsr ScreenCopyDispToPrepColor   ; copy colored prepared hires screen data to display screen .hbu002.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen
                            sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
;                           bne GameScreenPrepareClear      ; always - clear screen prepare from loderunner/enemy tiles .hbu001. removed
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameScreenPrepareClear    Does    : clear screen prepare from loderunner/enemy tiles
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameScreenPrepareClear     .block                           ; 
                            ldy #HLZ_ScreenRow_Max          ; get max
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
SetNextGameLevelTilePtr     lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #HLZ_ScreenCol_Max          ; get max cols
                            sty HLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextGameLevelTile        lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            beq GetGameLevelTileBlank       ; check: EQ - yes: substitute with a blank
                            
                            cmp #HL_TileNum_Enemy           ; test enemy
                            bne SetNextLevelDataPos         ; check: NE - yes: do not substitute
; --------------------------------------------------------------------------------------------------------------------- ;
; substitute loderunner/enemy level tiles on prepare screen with blank
; --------------------------------------------------------------------------------------------------------------------- ;
GetGameLevelTileBlank       lda #HL_TileNum_Empty           ; get empty tile substitution
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen column
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataPos         dec HLZ_ScreenCol               ; dec screen col ($00-$1b)
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            bpl GetNextGameLevelTile        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_ScreenRow               ; dec screen row ($00-$0f)
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            bpl SetNextGameLevelTilePtr     ; check: min - no: continue
                            
                            clc                             ; set flag good end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveHandler         Does    : control loderunner moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandler          .block                           ; 
                            lda #HL_LodeRuGetGold_Picked    ; get flag gold collected completely
                            sta HL_LodeRuGetGold            ; set flag get gold  $00=just gets it
; --------------------------------------------------------------------------------------------------------------------- ;
; check shooting first
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq LodeRuMoves                 ; check: shoot - no: move him
                            bpl GoLodeRuShootRight          ; check: shoot right - yes
                            
                            jmp LodeRuShootLeft             ; shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuShootRight          jmp LodeRuShootRight            ; shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoves                 ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile loderunner is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)  = data 'under' lr
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            bne ChkOnImagePosY_Left         ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is in the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #HLZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is left of the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
ChkOnImagePosY_Left         lda HLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #HLZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            bcc LodeRuFallsDown             ; check: LT - yes: below center
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is on bottom row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            cpy #HLZ_ScreenRow_Max          ; test max rows
                            beq GoStopFallingStartMoving    ; check: EQ - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is empty - let him fall down then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty tile
                            beq LodeRuFallsDown             ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne LodeRuFallsDown             ; check: EQ - no: loderunner falls down
                            
GoStopFallingStartMoving    jmp StopFallingStartMoving      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuFallsDown             lda #HL_LodeRuFallsDown_Yes     ; get flag loderunner falls down
                            sta HL_LodeRuFallsDown          ; set loderunner falls down
; --------------------------------------------------------------------------------------------------------------------- ;
; step fall beep down 
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_TuneBeepFall             ; dec fall beep
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #TabNumSpriteLodeRu_FaLe_Min; get sprite number fall left                               .hbu000.
                            
                            ldx HLZ_LodeRuShootMode         ; get shoot mode
                            bmi SetLodeRuSpriteNum          ; check: HLZ_LodeRuShootMode_Front - yes
                            
                            lda #TabNumSpriteLodeRu_FaRi_Min; get sprite number fall right                              .hbu000.
                            
SetLodeRuSpriteNum          sta HLZ_LodeRuSprtNum           ; set loderunner sprite number
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc HLZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image
                            
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #HLZ_LodeRuOnImgPosY_Max + $01 ; test beyond max
                            bcs SetOnImagePosY_Start        ; check: GE - yes: reinit to start
                            
                            jsr LodeRuGetGold               ; pic up and score the gold
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
SetOnImagePosY_Start        lda #HLZ_LodeRuOnImgPosY_Min    ; get min
                            sta HLZ_LodeRuOnImgPosY         ; set loderunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetLevelGameTile            ; check: EQ - no
                            
                            lda #HL_TileNum_Empty           ; get empty tile substitution
                            
SetLevelGameTile            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row below old loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set the game level tile under new loderunner row to loderunner tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; end of loderunner fall down
; --------------------------------------------------------------------------------------------------------------------- ;
StopFallingStartMoving      lda HL_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
;                           bne GetEndOfFall                ; check: end of fall - yes <obsolete>                       .hbu001.
                            
GetEndOfFall                lda #HL_LodeRuFallsDown_No      ; get end of fall
                            sta HL_LodeRuFallsDown          ; set end of fall
; --------------------------------------------------------------------------------------------------------------------- ;
; check move direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameInputHandler            ; get keyboard and joystick input - call in game routines
; --------------------------------------------------------------------------------------------------------------------- ;
; handle demo recorder moves
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameDemoMoveRecorder        ; record loderunner demo moves                              .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions up/down
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuMovesDirY          lda HL_JoystickMoveDirY         ; get move direction up/down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesUp            cmp #HL_JoystickMoveDirY_Up     ; test move up
                            bne ChkLodeRuMovesDown          ; check: EQ - no: check move down
                            
                            jsr LodeRunMoveUp               ; try to move him up
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved up
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesDown          cmp #HL_JoystickMoveDirY_Do     ; test move down
                            bne ChkLodeRuShootLeft          ; check: EQ - no: check shoot left
                            
                            jsr LodeRuMoveDown              ; try to move him down
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootLeft          cmp #HL_JoystickShoot_Le        ; test shoot left
                            bne ChkLodeRuShootRight         ; check: EQ - no: check shoot right
                            
                            jsr LodeRuShootLeftInit         ; try to shoot left
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootRight         cmp #HL_JoystickShoot_Ri        ; test shoot right
                            bne GetLodeRuMoveDirLeRi        ; check: EQ - no: check moves left/right
                            
                            jsr LodeRuShootRightInit        ; try to shoot right
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions left/right
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuMoveDirLeRi        lda HL_JoystickMoveDirX         ; get get move direction left/right
                            cmp #HL_JoystickMoveDirX_Le     ; test move left
                            bne ChkLodeRuMovesRight         ; check: EQ - no: check move right
                            
                            jmp LodeRuMoveLeft              ; try to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesRight         cmp #HL_JoystickMoveDirX_Ri     ; test move right
                            bne LodeRuMoveHandlerX          ; check: EQ - no: exit
                            
                            jmp LodeRuMoveRight             ; try to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandlerX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveLeft            Does    : try to move loderunner left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeft             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on right side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #HLZ_LodeRuOnImgPosX_Mid + $01 ; test loderunner right of image center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lodreunner is an max left col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuMoveLeftImpossible    ; check: max left - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile left of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move left
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeftImpossible    rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #HLZ_LodeRuShootMode_Front  ; get shoot to front of loderunner
                            sta HLZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            dec HLZ_LodeRuOnImgPosX         ; loderunner pos on image left/right = one step left
                            bpl GoLodeRuGetGold             ; check: move from actual to next left field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #HL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_LodeRuCol               ; dec actual col loderunner
                            dey                             ; dec column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner max PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_LodeRuOnImgPosX_Max    ; get max right
                            sta HLZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            bne GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabNumSpriteLodeRu_RuLe_Min; get sprite numbers move left min                          .hbu000.
                            ldx #TabNumSpriteLodeRu_RuLe_Max; get sprite numbers move left max                          .hbu000.
                            bne SetNextSpriteNumber         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole left
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #TabNumSpriteLodeRu_PoLe_Min; get sprite numnumber hang along a pole left min           .hbu000.
                            ldx #TabNumSpriteLodeRu_PoLe_Max; get sprite numnumber hang along a pole left max           .hbu000.
                            
SetNextSpriteNumber         jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveRight           Does    : try to move loderunner right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRight            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on left side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #HLZ_LodeRuOnImgPosX_Mid    ; test loderunner left of image center
                            bcc GoGetLodeRuPosXY            ; check: LT - yes: left of center
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lodreunner is an max right col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            cpy #HLZ_ScreenCol_Max          ; test max right
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move right 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRightImpossible   rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #HLZ_LodeRuShootMode_Back   ; get shoot to back of loderunner
                            sta HLZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            inc HLZ_LodeRuOnImgPosX         ; inc loderunner pos on image left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cmp #HLZ_LodeRuOnImgPosX_Max + $01 ; test max PosX
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #HL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_LodeRuCol               ; inc actual col loderunner
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner min PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_LodeRuOnImgPosX_Min    ; get min right
                            sta HLZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            beq GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabNumSpriteLodeRu_RuRi_Min; get sprite numbers move right min                         .hbu000.
                            ldx #TabNumSpriteLodeRu_RuRi_Max; get sprite numbers move right max                         .hbu000.
                            bne GoGoSetNextSpriteNumber     ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole right
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #TabNumSpriteLodeRu_PoRi_Min; get sprite numnumber hang along a pole right min          .hbu000.
                            ldx #TabNumSpriteLodeRu_PoRi_Max; get sprite numnumber hang along a pole right max          .hbu000.
                            
GoGoSetNextSpriteNumber     jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRunMoveUp             Does    : try to move loderunner up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRunMoveUp              .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq GetLodeRuImagePosY          ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #HLZ_LodeRuOnImgPosY_Mid + $01 ; test loderunner above the image center
                            bcc LodeRuMoveUpImpossible      ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile beyond loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3) + 1 = data below lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile beyond loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq GoGetLodeRuPosXY            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; no ladder/blocked/on top row already - impossible to move up
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveUpImpossible      sec                             ; exit with flag no move up possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          ldy HLZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #HLZ_LodeRuOnImgPosY_Mid + $01 ; test below center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on top of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            beq LodeRuMoveUpImpossible      ; check: top of screen - yes: no further move up possible
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo - $01,y  ; get expanded level data row pointer lo
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi - $01,y ; get expanded level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game level tile above loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) - 1 = data above lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            dec HLZ_LodeRuOnImgPosY         ; loderunner pos on image up/down = one step up
                            bpl GoLodeRuGetGold             ; check: move from actual to next up field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #HL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_LodeRuRow               ; dec actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            lda #HLZ_LodeRuOnImgPosY_Max    ; get max PosY
                            sta HLZ_LodeRuOnImgPosY         ; ini loderunner vertical PosY on image
                            bne GetSpriteNumLimitsMoveUpDo  ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number ladder
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumLimitsMoveUpDo  lda #TabNumSpriteLodeRu_Ladr_Min; get sprite numbers climb up/do min                        .hbu000.
                            ldx #TabNumSpriteLodeRu_Ladr_Max; get sprite numbers climb up/do max                        .hbu000.
                            jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                            
                            clc                             ; set flag move up was successfulgood end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveDown            Does    : try to move loderunner down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDown             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cpy #HLZ_LodeRuOnImgPosY_Mid    ; test above center of screen image
                            bcc GetLodeRuImagePosY          ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on the bottom of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            cpy #HLZ_ScreenRow_Max          ; test bottom of screen
                            bcs LodeRuMoveDownImpossible    ; check: GE - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveDownImpossible    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne GetLodeRuImagePosY          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked/on bottom row already - impossible to move down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDownImpossible    sec                             ; exit with flag no move down possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc HLZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image - one step down
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #HLZ_LodeRuOnImgPosY_Max + $01 ; test still on screen image
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #HL_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda #HL_TileNum_LodeRunner      ; get loderunner
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init loderunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_LodeRuOnImgPosY_Min    ; get min
                            sta HLZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            jmp LodeRunMoveUp.GetSpriteNumLimitsMoveUpDo ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jmp LodeRunMoveUp.GoLodeRuGetGold ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftX          Does    : switch off loderunner shoot left/right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftX           .block                           ; 
                            jmp LodeRuShootLeft.SetLodeRuShootFinish ; set flag shoot finished and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftInit       Does    : init try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftInit        .block                           ; 
                            lda #HL_LodeRuShoot_Le          ; get shoot left
                            sta HL_LodeRuShoot              ; ini shoot
                            sta HL_JoystickMoveDirY         ; ini movedir Y
                            sta HL_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabNumImageShootSparkLe_Min; get initial value
                            sta HLZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeft           Does    : try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeft            .block                           ; 
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            bcs LodeRuShootLeftX            ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on leftmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuShootLeftX            ; check: leftmost position - yes: no room left for shoot left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile below left of loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below left of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootLeftX            ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile left of loderunner is empty - an enemy may interrupt the process
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one position left
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #HL_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoLe   ; check: EQ - no: blocked no shoot left possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
                            lda #TabNumSpriteLodeRu_RuLe_Min; preset sprite number run left start                       .hbu000.
                            
                            cpx #HLZ_ShootStepCtrl_Switch_Le; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no
                            
                            lda #TabNumSpriteLodeRu_FiLe_Min; get sprite number shoot left                              .hbu000.
                            
SetLodeRuSpriteNum          sta HLZ_LodeRuSprtNum           ; set sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabNumImageShootSparkLe_Max; test maximum loderunner shoot step image table offset
                            beq LodeRuShootLeftFinish       ; check: EQ - yes: open a hole in shoot direction
                            
                            cpx #TabNumImageShootSparkLe_Min; test minimum loderunner shoot step image table offset
                            beq GetImageShootSpark          ; check: EQ - yes: get appropriate spark image number
                            
                            lda TabNumImageShootSpark - $01,x ; get image number shoot spark                            .hbu000.
                            pha                             ; save image number shoot spark
                            
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one column left
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabNumImageShootSpark,x     ; get shoot spark image number
                            pha                             ; save image number shoot spark
                            
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one col left
                            stx HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabNumImageShootMeltGround,x; get image shoot melts ground
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot left
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked left/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/left for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoLe   ldy HLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one col left
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output no shoot finish brick to left col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_BrickSoft       ; get normal brick - unsuccesful finish shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: min - yes: done
                            
                            dex                             ; dec loderunner shoot step image table offset
                            lda TabNumImageShootSpark,x     ; get previous spark image number
                            pha                             ; save spark image number
                            
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one row up
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #HL_LodeRuShoot_No          ; get flag shoot no
                            sta HL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot left possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftFinish       ldx HLZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one position left
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightX         Does    : exit point of LodeRuShootRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightX          .block                           ; 
                            jmp LodeRuShootRight.SetLodeRuShootFinish ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightInit      Does    : init try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightInit       .block                           ; 
                            lda #HL_LodeRuShoot_Ri          ; get shoot right
                            sta HL_LodeRuShoot              ; ini shoot
                            sta HL_JoystickMoveDirY         ; ini movedir Y
                            sta HL_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabNumImageShootSparkRi_Min; get initial value
                            sta HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRight          Does    : try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRight           .block                           ; 
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            cpy #HLZ_ScreenRow_Max          ; test max
                            bcs LodeRuShootRightX           ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on rightmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            cpy #HLZ_ScreenCol_Max          ; test rightmost position
                            bcs LodeRuShootRightX           ; check: GE - yes: no room left for shoot right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile below right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below right of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootRightX           ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile right of loderunner is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one position right
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #HL_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoRi   ; check: EQ - no: blocked no shoot right possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda #TabNumSpriteLodeRu_RuRi_Min; get sprite number run right start                         .hbu000.
                            
                            cpx #HLZ_ShootStepCtrl_Switch_Ri; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no 
                            
                            lda #TabNumSpriteLodeRu_FiRi_Min; get sprite number shoot right                             .hbu000.
                            
SetLodeRuSpriteNum          sta HLZ_LodeRuSprtNum           ; set loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabNumImageShootSparkRi_Max; test max
                            beq LodeRuShootRightFinish      ; check: EQ - yes
                            
                            cpx #TabNumImageShootSparkRi_Min; test min
                            beq GetImageShootSpark          ; check: EQ - yes
                            
                            lda TabNumImageShootSpark - $01,x ; get image number shoot spark
                            pha                             ; save image number shoot spark
                            
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabNumImageShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            stx HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; setp screen row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground - pointer is in the 2nd half of the table - needs subtraction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabNumImageShootMeltGround - TabNumImageShootSparkRi_Min,x; get image shoot melts ground
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot right
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked right/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/right for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoRi   ldy HLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one col right
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot finish brick to right col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_BrickSoft       ; get normal brick - finished shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx HLZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabNumImageShootSparkRi_Min; test minimum loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: EQ - yes: min reached - finished
                            
                            dex                             ; 
                            lda TabNumImageShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; set on column right
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore shoot spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #HL_LodeRuShoot_No          ; get flag shoot no
                            sta HL_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot right possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightFinish      ldx HLZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one position right
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteLodeRu          = * ; 
TabNumSpriteLodeRu_RuLe_00  .byte NumSprite_LodeRu_RuLe_00 ; $0b --> $00 - Run  Le 00                                   .hbu000.
                            .byte NumSprite_LodeRu_RuLe_01 ; $0c --> $01 - Run  Le 01                                   .hbu000.
TabNumSpriteLodeRu_RuLe_02  .byte NumSprite_LodeRu_RuLe_02 ; $0d --> $02 - Run  Le 02                                   .hbu000.
TabNumSpriteLodeRu_PoLe_00  .byte NumSprite_LodeRu_PoLe_00 ; $18 --> $03 - Pole Le 00                                   .hbu000.
                            .byte NumSprite_LodeRu_PoLe_01 ; $19 --> $04 - Pole Le 01                                   .hbu000.
TabNumSpriteLodeRu_PoLe_02  .byte NumSprite_LodeRu_PoLe_02 ; $1a --> $05 - Pole Le 02                                   .hbu000.
TabNumSpriteLodeRu_Fire_Le  .byte NumSprite_LodeRu_Fire_Le ; $0f --> $06 - Fire Le                                      .hbu000.
TabNumSpriteLodeRu_Fall_Le  .byte NumSprite_LodeRu_Fall_Le ; $13 --> $07 - Fall Le                                      .hbu000.
TabNumSpriteLodeRu_RuRi_00  .byte NumTile_LodeRunner       ; $09 --> $08 - Run  Ri 00 = Level Tile Loderunner           .hbu000.
                            .byte NumSprite_LodeRu_RuRi_01 ; $10 --> $09 - Run  Ri 01                                   .hbu000.
TabNumSpriteLodeRu_RuRi_02  .byte NumSprite_LodeRu_RuRi_02 ; $11 --> $0a - Run  Ri 02                                   .hbu000.
TabNumSpriteLodeRu_PoRi_00  .byte NumSprite_LodeRu_PoRi_00 ; $15 --> $0b - Pole Ri 00                                   .hbu000.
                            .byte NumSprite_LodeRu_PoRi_01 ; $16 --> $0c - Pole Ri 01                                   .hbu000.
TabNumSpriteLodeRu_PoRi_02  .byte NumSprite_LodeRu_PoRi_02 ; $17 --> $0d - Pole Ri 02                                   .hbu000.
TabNumSpriteLodeRu_Fire_Ri  .byte NumSprite_LodeRu_Fire_Ri ; $25 --> $0e - Fire Ri                                      .hbu000.
TabNumSpriteLodeRu_Fall_Ri  .byte NumSprite_LodeRu_Fall_Ri ; $14 --> $0f - Fall Ri                                      .hbu000.
TabNumSpriteLodeRu_Ladr_00  .byte NumSprite_LodeRu_Ladr_00 ; $0e --> $10 - Ladder 00                                    .hbu000.
TabNumSpriteLodeRu_Ladr_01  .byte NumSprite_LodeRu_Ladr_01 ; $12 --> $11 - Ladder 01                                    .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; set min/max values for EnemyMoveSpriteNumRotate
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteLodeRu_RuLe_Min = TabNumSpriteLodeRu_RuLe_00 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_RuLe_Max = TabNumSpriteLodeRu_RuLe_02 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_PoLe_Min = TabNumSpriteLodeRu_PoLe_00 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_PoLe_Max = TabNumSpriteLodeRu_PoLe_02 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_RuRi_Min = TabNumSpriteLodeRu_RuRi_00 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_RuRi_Max = TabNumSpriteLodeRu_RuRi_02 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_PoRi_Min = TabNumSpriteLodeRu_PoRi_00 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_PoRi_Max = TabNumSpriteLodeRu_PoRi_02 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_Ladr_Min = TabNumSpriteLodeRu_Ladr_00 - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_Ladr_Max = TabNumSpriteLodeRu_Ladr_01 - TabNumSpriteLodeRu ; table offset                            .hbu000.
                            
TabNumSpriteLodeRu_FiLe_Min = TabNumSpriteLodeRu_Fire_Le - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_FiRi_Min = TabNumSpriteLodeRu_Fire_Ri - TabNumSpriteLodeRu ; table offset                            .hbu000.
                            
TabNumSpriteLodeRu_FaLe_Min = TabNumSpriteLodeRu_Fall_Le - TabNumSpriteLodeRu ; table offset                            .hbu000.
TabNumSpriteLodeRu_FaRi_Min = TabNumSpriteLodeRu_Fall_Ri - TabNumSpriteLodeRu ; table offset                            .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; convert an image number into a image count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumImageShootSpark       = * ; shoot image number tables left/right                                                  .hbu000.
TabNumImageShootSparkLe     = * ;                                                                                       .hbu000.
TabNumImageShootSparkLe_Min = * - TabNumImageShootSpark  ; start of table left                                          .hbu000.
                            .byte NumImage_ShootSpark_00 ; $1b --> $00 - shot spark le    00                            .hbu000.
                            .byte NumImage_ShootSpark_00 ; $1b --> $01 - shot spark le    00                            .hbu000.
                            .byte NumImage_ShootSpark_01 ; $1c --> $02 - shot spark le    01                            .hbu000.
                            .byte NumImage_ShootSpark_01 ; $1c --> $03 - shot spark le    01                            .hbu000.
                            .byte NumImage_ShootSpark_02 ; $1d --> $04 - shot spark le/ri 02                            .hbu000.
                            .byte NumImage_ShootSpark_02 ; $1d --> $05 - shot spark le/ri 03                            .hbu000.
                            .byte NumImage_ShootSpark_03 ; $1e --> $06 - shot spark le/ri 03                            .hbu000.
                            .byte NumImage_ShootSpark_03 ; $1e --> $07 - shot spark le/ri 03                            .hbu000.
                            .byte NumTile_Empty          ; $00 --> $08 - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $09 - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $0a - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $0b - empty space                                    .hbu000.
TabNumImageShootSparkLe_Max = * - TabNumImageShootSpark  ; end of table left                                            .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumImageShootSparkRi     = * ;                                                                                       .hbu000.
TabNumImageShootSparkRi_Min = * - TabNumImageShootSpark  ; start of table right                                         .hbu000.
                            .byte NumImage_ShootMelt_00  ; $26 --> $00 - shot spark ri    00                            .hbu000.
                            .byte NumImage_ShootMelt_00  ; $26 --> $01 - shot spark ri    00                            .hbu000.
                            .byte NumImage_ShootMelt_01  ; $27 --> $02 - shot spark ri    01                            .hbu000.
                            .byte NumImage_ShootMelt_01  ; $27 --> $03 - shot spark ri    01                            .hbu000.
                            .byte NumImage_ShootSpark_02 ; $1d --> $04 - shot spark le/ri 02                            .hbu000.
                            .byte NumImage_ShootSpark_02 ; $1d --> $05 - shot spark le/ri 02                            .hbu000.
                            .byte NumImage_ShootSpark_03 ; $1e --> $06 - shot spark le/ri 03                            .hbu000.
                            .byte NumImage_ShootSpark_03 ; $1e --> $07 - shot spark le/ri 03                            .hbu000.
                            .byte NumTile_Empty          ; $00 --> $08 - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $09 - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $0a - empty space                                    .hbu000.
                            .byte NumTile_Empty          ; $00 --> $0b - empty space                                    .hbu000.
TabNumImageShootSparkRi_Max = * - TabNumImageShootSpark  ; end of table right                                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumImageShootMeltGround  = * ;                                                                                       .hbu000.
                            .byte NumImage_MeltGround_00 ; $1f --> $0c - melt ground phase 00                           .hbu000.
                            .byte NumImage_MeltGround_00 ; $1f --> $0d - melt ground phase 00                           .hbu000.
                            .byte NumImage_MeltGround_01 ; $20 --> $0e - melt ground phase 01                           .hbu000.
                            .byte NumImage_MeltGround_01 ; $20 --> $0f - melt ground phase 01                           .hbu000.
                            .byte NumImage_MeltGround_02 ; $21 --> $00 - melt ground phase 02                           .hbu000.
                            .byte NumImage_MeltGround_02 ; $21 --> $01 - melt ground phase 02                           .hbu000.
                            .byte NumImage_MeltGround_03 ; $22 --> $02 - melt ground phase 03                           .hbu000.
                            .byte NumImage_MeltGround_03 ; $22 --> $03 - melt ground phase 03                           .hbu000.
                            .byte NumImage_MeltGround_04 ; $23 --> $04 - melt ground phase 04                           .hbu000.
                            .byte NumImage_MeltGround_04 ; $23 --> $05 - melt ground phase 04                           .hbu000.
                            .byte NumImage_MeltGround_05 ; $24 --> $06 - melt ground phase 05                           .hbu000.
                            .byte NumImage_MeltGround_05 ; $24 --> $07 - melt ground phase 05                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHandler               Does    : control game demo mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHandler                .block                           ; 
                            lda HL_KeyNew                   ; get keyboard interaction
                            bne DemoEnd                     ; check: player keybord interaction - yes: end demo
                            
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne DemoRun                     ; check: player joystick interaction - no: continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
; player interaction - end demo with sudden death
; --------------------------------------------------------------------------------------------------------------------- ;
;DemoEnd                    lsr HLZ_DemoNoFunction          ; reset flag - used but has no function                     .hbu001. removed
DemoEnd                     lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
                            lda #HL_NumLivesDemo            ; care for one hit death
                            sta HL_NumLives                 ; set one hit death
                            
                            rts                             ; exit end of demo
; --------------------------------------------------------------------------------------------------------------------- ;
; continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoRun                     lda HLZ_DemoMoveDuration        ; get duration demo move
                            bne DemoMoveContinue            ; check: not ended yet
; --------------------------------------------------------------------------------------------------------------------- ;
; old move has ended - get a new one
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini demo move table offset
                            lda (HLZ_DemoMoveDataPtr),y     ; get demo move type
                            sta HLZ_DemoMoveType            ; set demo move type (l/r/u/d/fire)
                            
                            iny                             ; inc demo move table offset
                            lda (HLZ_DemoMoveDataPtr),y     ; get demo move duration
                            sta HLZ_DemoMoveDuration        ; set demo move duration
; --------------------------------------------------------------------------------------------------------------------- ;
; advance demo move data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_DemoMoveDataPtr_Lo      ; get demo data pointer LO
                            clc                             ; 
                            adc #TabDemoMoveEntry_Len       ; point to next demo data pair
                            sta HLZ_DemoMoveDataPtr_Lo      ; set demo data pointer LO
                            
                            lda HLZ_DemoMoveDataPtr_Hi      ; get demo data pointer HI
                            adc #$00                        ; add .C
                            sta HLZ_DemoMoveDataPtr_Hi      ; set demo data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; continue actual demo move
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMoveContinue            lda HLZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            and #$0f                        ; isolate right nibble for up/do moves
                            tax                             ; set up/do move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta HL_JoystickMoveDirY         ; set demo move up/do
                            
                            lda HLZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            lsr a                           ; isolate left nibble for left/right moves
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            tax                             ; set le/ri move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta HL_JoystickMoveDirX         ; set demo move le/ri
                            
                            dec HLZ_DemoMoveDuration        ; dec duration demo move
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoJoystickMove         = *       ; 
                            .byte HL_JoystickMoveDirY_Up   ; $00
                            .byte HL_JoystickMoveDirX_Le   ; $01
                            .byte HL_JoystickMoveDirY_Do   ; $02
                            .byte HL_JoystickMoveDirX_Ri   ; $03
                            .byte HL_JoystickShoot_Ri      ; $04
                            .byte HL_JoystickShoot_Le      ; $05
                            .byte HL_JoystickMoveDir_None  ; $06                                                        .hbu003.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameInputHandler          Does    : set joystick actions or control dispatch of in game key routines
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameInputHandler           .block                           ; 
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit
                            cmp #HL_GameMode_Demo           ; test demo
                            beq DemoHandler                 ; check: EQ - yes: control demo
; --------------------------------------------------------------------------------------------------------------------- ;
; no demo - get key 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_KeyNew                   ; get new key entered
                            bne IniNewKey                   ; check: pressed - yes
                            
                            lda HL_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #HL_ControllerType_Keyboard ; test keyboard
                            beq GameInputHandlerX           ; check: EQ - yes
                            
GoJoystickControl           jmp GameSetJoystickAction       ; get and set joystick shoot or move directions
; --------------------------------------------------------------------------------------------------------------------- ;
IniNewKey                   lda #HL_KeyNew_None             ; get initial value
                            sta HL_KeyNew                   ; ini new key input
                            
                            stx HLZ_WorkKeyNew              ; save new key entered
                            
                            ldy #$ff                        ; preset -1 to allow loop start inc
SetNextIngameKeyTabOff      iny                             ; 
                            lda TabIGC_CmdChar,y            ; get in game keys tab value
                            beq ChkControllerType           ; check: EoT command key - yes: no legal command key found
                            
                            cmp HLZ_WorkKeyNew              ; test with new key entered
                            bne SetNextIngameKeyTabOff      ; check: EQ - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch in game key routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            asl a                           ; *2
                            tay                             ; 
                            
                            lda TabIGC_CmdAddress + $01,y   ; get ingame key routine address HI
                            pha                             ; push as return address HI
                            
                            lda TabIGC_CmdAddress + $00,y   ; get ingame key routine address LO
                            pha                             ; push as return address LO
                            
                            rts                             ; dispatch command
; --------------------------------------------------------------------------------------------------------------------- ;
ChkControllerType           lda HL_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #HL_ControllerType_Joystick ; test joystick
                            beq GoJoystickControl           ; check: EQ - yes
                            
                            ldx HLZ_WorkKeyNew              ; get new key entered
                            stx HL_JoystickMoveDirY         ; set jostick move Y
                            stx HL_JoystickMoveDirX         ; set jostick move X
                            
GameInputHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_LevelNext             Does    : in game cmd: adcance to the next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_LevelNext              .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            bmi IGC_NextLevelX              ; check: HL_LevelTest_On - yes: impossible in test mode     .hbu019.
                            
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_NextLevelX              ; check: HL_DemoRec_On - yes: impossible in recording mode  .hbu034.
                            
                            jsr GameLevelNumIncHandler      ; control the level number increase                         .hbu002.
                            
                            inc HL_NumLives                 ; inc lives - compensate LR death
; --------------------------------------------------------------------------------------------------------------------- ;
; force level start by killing the loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; do not set cheat flag in debug mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bmi IGC_NextLevelX              ; check: debug mode - yes: do not set cheat flag            .hbu022.
                            
                            lsr HL_Cheated                  ; set HL_Cheated_Yes
                            
IGC_NextLevelX              rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_LevelPrev             Does    : in game command: backwards to the previous level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_LevelPrev              .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            bmi IGC_PrevLvlX                ; check: HL_LevelTest_On - yes: impossible in test mode     .hbu019.
                            
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_PrevLvlX                ; check: HL_DemoRec_On - yes: impossible in recording mode  .hbu034.
                            
                            jsr GameLevelNumDecHandler      ; control the level number decrease                         .hbu014.
                            
                            inc HL_NumLives                 ; compensate the previous kill                              .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
; force level start by killing the loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death                                  .hbu014.
; --------------------------------------------------------------------------------------------------------------------- ;
; do not set cheat flag in debug mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bmi IGC_PrevLvlX                ; check: debug mode - yes: do not set cheat flag            .hbu022.
                            
                            lsr HL_Cheated                  ; set HL_Cheated_Yes                                        .hbu014.
                            
IGC_PrevLvlX                rts                             ;                                                           .hbu014.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_TestQuit              Does    : in game command: quit the current level in test mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_TestQuit               .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            beq IGC_LevelQuitX              ; check: HL_LevelTest_Off - yes: normal end                 .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; remove return addresses from stack
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; remove return address of GameInputHandler                 .hbu019.
                            pla                             ;                                                           .hbu019.
                            
                            pla                             ; remove return address of LodeRuMoveHandler                .hbu019.
                            pla                             ;                                                           .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_LevelTestQuit         Does    : in game command: quit level - entry point after reaching LevelComplete
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_LevelTestQuit          .block                           ; 
                            lda #HL_LevelTest_Off           ; get inital value                                          .hbu019.
                            sta HL_LevelTest                ; switch test level mode off                                
                            
                            lda #HL_NumLivesInit            ; get initial value                                         .hbu019.
                            sta HL_NumLives                 ;                                                           
                            
                            lda #HL_GameMode_Edit           ; get edit mode                                             .hbu019.
                            sta HL_GameMode                 ; set game mode - $00=start $01=demo $02=play $05=edit      .hbu019.
                            sta HL_SpriteShow               ; set HL_SpriteShow_Off                                     .hbu019.
                            
                            lda #SPENA_ALL_OFF              ; disable all sprites                                       .hbu019.
                            sta SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; back to level editor
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp LED_Start_Recolor           ; reset to fix level editor colors                          .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_LevelQuitX            Does    : in game command: quit level exit point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_LevelQuitX             .block                           ; 
                            jmp GameInputHandler            ;                                                           .hbu019.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncNumLife            Does    : in game cmd: increase life counter
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncNumLife             .block                           ; 
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_IncNumLifeX             ; check: HL_DemoRec_On - yes: impossible in recording mode  .hbu034.
                            
                            inc HL_NumLives                 ; inc lives
                            bne NumLivesOut                 ; check: max reached - no
                            
                            dec HL_NumLives                 ; dec again - limit to $ff (255)
                            
NumLivesOut                 jsr StatusMsgTextReset          ; reset status line / display new no of lives               .hbu009.
                            
ChkDebug                    lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bmi IGC_IncNumLifeX             ; do not set cheat flag in debug mode                       .hbu022.
                            
                            lsr HL_Cheated                  ; set HL_Cheated_Yes
                            
IGC_IncNumLifeX             jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_UnDispatched          Does    : in game cmd: inc lives and game speed - not dispatched
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
;IGC_UnDispatched          .block                           ;                                                           .hbu001. removed
;                           inc HL_GameSpeedCtrl            ;                                                           .hbu001. removed
;                           inc HL_NumLives                 ;                                                           .hbu001. removed
;                                                                                                                       .hbu001. removed
;                           lsr HL_LodeRuState              ; HL_LodeRuState_Death                                      .hbu001. removed
;                                                                                                                       .hbu001. removed
;                           rts                             ;                                                           .hbu001. removed
;                          .bend                            ;                                                           .hbu001. removed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Pause                 Does    : in game cmd: pause the game until next RUN/STOP is pressed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Pause                  .block                           ; 
GetNextPauseKey             jsr GetNewKey                   ; wait for a input key set in IRQ
                            cmp #$03                        ; test <F7>                                                 .hbu022.
                            bne TestKey_RunStop             ; check: EQ - no                                            .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; debug mode requested with key <F7>
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DemoRec                  ; get flag demo recording mode                              .hbu034.
                            bmi TestKey_RunStop             ; check: demo recording mode on - yes: no debug mode then   .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; toggle flag debug mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_ModeDebugUsed_Game | HL_ModeDebugUsed_Level ; get compound flag debug used          .hbu022.
                            sta HL_ModeDebugUsed            ; set flag debug used                                       .hbu022.
                            
                            lda HL_ModeDebug                ; get debug mode                                            .hbu022.
                            eor #HL_ModeDebug_On            ; toggle debug mode                                         .hbu022.
                            sta HL_ModeDebug                ; set new debug mode                                        .hbu022.
                            bpl GetMarkDebugMode_Off        ; check: debug mode: no                                     .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; if in debug mode mark the border
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LT_GREY                    ; preset debug border color                                 .hbu022.
                            bne SetMarkDebugMode            ; always                                                    .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
GetMarkDebugMode_Off        lda #BLACK                      ; get normal border color                                   .hbu022.
                            
SetMarkDebugMode            sta EXTCOL                      ; VIC($D020) Border Color                                   .hbu022.
                            jsr EditorErrorBeep             ; output an error beep signal                               .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
TestKey_RunStop             cmp #$3f                        ; test <RUN/STOP>
                            bne GetNextPauseKey             ; check: EQ - no: continue pause
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd <RUN/STOP> ends the pause loop
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Resign                Does    : in game cmd: resign
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Resign                 .block                           ; 
                            ldx HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            bpl IGC_ResignX                 ; check: HL_LevelTest_On - yes: normal resign               .hbu019.
                            
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_ResignX                 ; check: HL_DemoRec_On - yes: start recorded demo           .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; in test mode only quit the level
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp IGC_TestQuit                ; quit only in test level mode                              .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; cleanup the stack first
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_ResignX                 pla                             ; remove return address of GameInputHandler                 .hbu001.
                            pla                             ;                                                           .hbu001.
                            
                            pla                             ; remove return address of LodeRuMoveHandler                .hbu001.
                            pla                             ;                                                           .hbu001.
                            
                            jmp GameOver                    ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Suicide               Does    : in game cmd: commit suicide
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Suicide                .block                           ; 
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetMirror             Does    : in game command: toggle level mirror mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetMirror              .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            bmi IGC_SetMirrorX              ; check: HL_LevelTest_On - yes: impossible in test mode     .hbu019.
                            
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_SetMirrorX              ; check: HL_DemoRec_On - yes: impossible in recording mode  .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; toggle mirror mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeMirror               ; get flag load mirrored level                              .hbu018.
                            eor #HL_ModeMirror_On           ; toggle flag load mirrored level                           .hbu018.
                            sta HL_ModeMirror               ; set flag load mirrored level                              .hbu018.
                            
                            inc HL_LevelReload              ; force a level reload if <> HL_LevelNumDisk                .hbu018.
                            
                            inc HL_NumLives                 ; compensate loderunner death                               .hbu018.
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death to force a level restart         .hbu018.
                            
IGC_SetMirrorX              jmp GameInputHandler            ;                                                           .hbu018.
                           .bend                            ;                                                           .hbu018.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DebugGold             Does    : debug in game command: force all gold collected
;                           Expects : 
;                           Returns : 
;                           Remark  : switch to debug mode 1st
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DebugGold              .block                           ; 
                            lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bpl IGC_DebugGoldX              ; check HL_ModeDebug_Off - yes: exit                        .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; set gold to collect to zero thus ending the hassle
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value                                         .hbu022.
                            sta HL_GoldToCollect            ; set no more gold to collect                               .hbu022.
                            
                            jsr JingleGotAllGoldNext        ; set the next level completed jingle                       .hbu022.
                            
IGC_DebugGoldX              jmp GameInputHandler            ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DebugScore            Does    : debug in game command: add some points to the actual score
;                           Expects : 
;                           Returns : 
;                           Remark  : switch to debug mode 1st
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DebugScore             .block                           ; 
                            lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bpl IGC_DebugScoreX             ; check HL_ModeDebug_Off - yes: exit                        .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; set gold to collect to zero thus ending the hassle
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>$1075                     ; score add value HI - score 1075 points                    .hbu022.
                            lda #<$1075                     ; score add value LO                                        .hbu022.
                            jsr StatusOutScore              ; score and update status row                               .hbu022.
                            
IGC_DebugScoreX             jmp GameInputHandler            ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DebugLives            Does    : debug in game command: increase number of lives
;                           Expects : 
;                           Returns : 
;                           Remark  : switch to debug mode 1st
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DebugLives             .block                           ; 
                            lda HL_ModeDebug                ; get flag: debug mode after <RUN/STOP>, <F7>, <RUN/STOP>   .hbu022.
                            bpl IGC_DebugLivesX             ; check HL_ModeDebug_Off - yes: exit                        .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; set gold to collect to zero thus ending the hassle
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_NumLives                 ; inc lives                                                 .hbu022
                            bne NumLivesOut                 ; check: min reached - no                                   .hbu022
                            
                            inc HL_NumLives                 ; inc again - limit to $01                                  .hbu022
                            
NumLivesOut                 jsr StatusMsgTextReset          ; reset status line / display new no of lives               .hbu022.
IGC_DebugLivesX             jmp GameInputHandler            ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitToggle            Does    : in game command: toggle transmit level data mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitToggle             .block                           ; 
                            lda HL_ModeXmit                 ; get flag: xmit mode                                       .hbu022.
                            eor #HL_ModeXmit_On             ; toggle mode flag                                          .hbu022.
                            sta HL_ModeXmit                 ; set flag: xmit mode                                       .hbu022.
                            bne IniXmitMsg                  ; check: HL_ModeXmit_On - yes: print the xmit msg           .hbu022.
                            
                            jsr StatusMsgTextShow           ; restore a possible level message text                     .hbu022.
                            jmp LED_GetKey                  ;                                                           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore start message
; --------------------------------------------------------------------------------------------------------------------- ;
IniXmitMsg                  lda #"t" | $80 ; T                                                                          .hbu022.                            
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_01 ;                                               .hbu022.
                            lda #"o" | $80 ; O                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_02 ;                                               .hbu022.
                            lda #" " | $80 ; <SHIFT_SPACE>                                                              .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_03 ;                                               .hbu022.
                            
                            jsr LED_XmitStatusMsg           ; print the status message                                  .hbu022.
                            jmp LED_GetKey                  ;                                                           .hbu022.
                           .bend                            ;                                                           .hbu022.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevel             Does    : in game command: transmit the active level to a preselected level of drive #9
;                           Expects : 
;                           Returns : 
;                           Remark  : 1st - attach an empty loderunner level disk to drive #9
;                                   : 2nd - switch on xmit mode
;                                   : 3rd - edit and test a loderunner level
;                                   : 4th - press <SHIFT>+X to transmit the edited level from drive #8 to drive #9
;                                   :       the target level number for drive #9 is counted up automatically
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevel              .block                           ; 
                            lda HL_ModeXmit                 ; get flag: xmit mode                                       .hbu022
                            beq LED_XmitLevelX              ; check: HL_ModeXmit_Off - yes: exit                        .hbu022
                            
                            lda SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu022
                            sta HL_SpriteSaveActive         ; save active sprites                                       .hbu022.
                            
                            lda #SPENA_ALL_OFF              ; switch all sprites off                                    .hbu022.
                            sta SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; transmit the active level to drive #9
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_XmitLevelData           ; transmit the active level to drive 9                      .hbu022.
                            
                            jsr LED_WaitForInput            ; wait for input here so that the xmit msg can be read      .hbu022.
                            jsr LED_XmitToggle              ; switch off the xmit mode again                            .hbu022.
                            
                            lda HL_SpriteSaveActive         ; restore active sprites                                    .hbu022.
                            sta SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu022.
                            
LED_XmitLevelX              jmp LED_GetKey.Checkinput       ; got an input already - do not wait this time              .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitNumStart          Does    : check if in xmit mode and select inc or dec handler              
;                           Expects : .A=increase amount
;                                   : .C=0 - increase
;                                   : .C=1 - decrease
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitNumStart           .block                           ; 
                            ldx HL_ModeXmit                 ; get flag: xmit mode                                       .hbu022.
                            beq LED_XmitNumStartX           ; check: HL_ModeXmit_Off - yes: exit                        .hbu022.
                            
                            bcs XmitNumDec                  ; get amount                                                .hbu022.
                            jsr LED_XmitNumIncHandler       ; increase Xmit level number                                .hbu022.
                            
                            jmp LED_GetKey                  ;                                                           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
XmitNumDec                  jsr LED_XmitNumDecHandler       ; decrease Xmit level number                                .hbu022.
                            
LED_XmitNumStartX           jmp LED_GetKey                  ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitNumDecHandler     Does    : control xmit level number decrease
;                           Expects : A=discount amount
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitNumDecHandler      .block                           ; 
                            sta HL_TempWork                 ; save discount value                                       .hbu022.
                            
                            lda HL_XmitLevelNum             ; 000-249                                                   .hbu022.
                            sec                             ;                                                           .hbu022.
                            sbc HL_TempWork                 ; $01 or $0a                                                .hbu022.
                            bcs LED_XmitNumFinish           ; check: underflow - no                                     .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; start over
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumDisk_Max        ;                                                           .hbu022.
LED_XmitNumDecHandlerX      bne LED_XmitNumFinish           ; always                                                    .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitNumIncHandler     Does    : control xmit level number increase
;                           Expects : .A=increase amount
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitNumIncHandler      .block                           ; 
                            clc                             ;                                                           .hbu022.
                            adc HL_XmitLevelNum             ; 000-249                                                   .hbu022.
                            cmp #HL_LevelNumDisk_Max + $01  ; test max + $01                                            .hbu022.
                            bcc LED_XmitNumFinish           ; check: LT - yes                                           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; start over
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumDisk_Min        ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitNumFinish         Does    : set xmit level number for drive #9 and write the xmit message
;                           Expects : .A=increase amount
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitNumFinish          .block                           ; 
                            sta HL_XmitLevelNum             ;                                                           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; init xmit message text
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #"t" | $80 ; T                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_01 ;                                               .hbu022.
                            lda #"o" | $80 ; O                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_02 ;                                               .hbu022.
                            lda #" " | $80 ; <SHIFT_SPACE>                                                              .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_03 ;                                               .hbu022.
                            
                            jmp LED_XmitStatusMsg           ; print info msg and wait for user key                      .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevelInc          Does    : in game command: increase xmit target level number
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevelInc           .block                           ; 
                            lda #$01                        ; get amount                                                .hbu022.
                            clc                             ; set flag add                                              .hbu022.
                            jmp LED_XmitNumStart            ;                                                           .hbu022.
                           .bend                            ;                                                           .hbu022.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevelInc10        Does    : in game command: increase xmit target level number
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevelInc10         .block                           ; 
                            lda #$0a                        ; get amount                                                .hbu022.
                            clc                             ; set flag add                                              .hbu022.
                            jmp LED_XmitNumStart            ;                                                           .hbu022.
                           .bend                            ;                                                           .hbu022.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevelDec          Does    : in game command: decrease xmit target level number
;                           Expects : .A=keycode
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevelDec           .block                           ; 
                            lda #$01                        ; get amount                                                .hbu022.
                            sec                             ; set flag del                                              .hbu022.
                            jmp LED_XmitNumStart            ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevelDec10        Does    : in game command: decrease xmit target level number
;                           Expects : .A=keycode
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevelDec10         .block                           ; 
                            lda #$0a                        ; get amount                                                .hbu022.
                            sec                             ; set flag del                                              .hbu022.
                            jmp LED_XmitNumStart            ;                                                           .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitLevelData         Does    : transmit the active level to drive #9
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitLevelData          .block                           ; 
                            lda HL_XmitLevelNum             ; get target level number                                   .hbu022.
                            ldx #$09                        ; get target drive number                                   .hbu022.
                            jsr DiskCmdStringHandler        ; generate the block access command and open channels       .hbu022.
                            bcs XmitLevelData_Error         ; check: disk open error - yes                              .hbu022.
;                           
                            jsr DiskCmdExecWrite            ; write the level data block                                .hbu022.
                            bcs XmitLevelData_Error         ; check: disk write error - yes                             .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; print the ok info message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #"o" | $80 ; O                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_01 ;                                               .hbu022.
                            lda #"k" | $80 ; K                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_02 ;                                               .hbu022.
                            lda #" " | $80 ; <SHIFT_SPACE>                                                              .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_03 ;                                               .hbu022.
                            
                            jsr LED_XmitStatusMsg           ; print info msg and wait for user key                      .hbu022.
                            
                            inc HL_XmitLevelNum             ; set next xmit level                                       .hbu022.
                            rts                             ;                                                           .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; print the fail info message and beep
; --------------------------------------------------------------------------------------------------------------------- ;
XmitLevelData_Error         lda #"b" | $80 ; B                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_01 ;                                               .hbu022.
                            lda #"a" | $80 ; A                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_02 ;                                               .hbu022.
                            lda #"d" | $80 ; D                                                                          .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtResult_03 ;                                               .hbu022.
                            
                            jsr LED_XmitStatusMsg           ; print info msg and wait for user key                      .hbu022.
                            jmp EditorErrorBeep             ; output an error beep signal                               .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_XmitStatusMsg         Does    : print the xmit status message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_XmitStatusMsg          .block                           ; 
                            ldx HL_XmitLevelNum             ; get xmit target    000-249                                .hbu022.
                            inx                             ; set xmit display target to game level (001-250)           .hbu022.
                            txa                             ;                                                           .hbu022.
                            jsr ConvertHexToDec             ; result in HL_Digit_100/HL_Digit_10/HL_Digit_1             .hbu022.
                            
                            lda HL_Digit_100                ; get 100s                                                  .hbu022.
                            clc                             ;                                                           .hbu022.
                            adc #NumCharDigit_Min           ; map to digit image data numbers - make it diplayable      .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtDigit_100 ; set to info message                           .hbu022.
                            
                            lda HL_Digit_10                 ; get 10s                                                   .hbu022.
                            clc                             ;                                                           .hbu022.
                            adc #NumCharDigit_Min           ; map to digit image data numbers - make it diplayable      .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtDigit_10 ; set to info message                            .hbu022.
                            
                            lda HL_Digit_1                  ; get 1s                                                    .hbu022.
                            clc                             ;                                                           .hbu022.
                            adc #NumCharDigit_Min           ; map to digit image data numbers - make it diplayable      .hbu022.
                            sta LED_XmitStatusMsg.StatusMsgTxtDigit_1 ; set to info message                             .hbu022.
                            
                            lda #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu022.
                            sta HLZ_TargetGfxOutput         ; output to display screen only                             .hbu022.
                            
                            jsr LED_CursorPosSave           ; save coursor pos                                          .hbu022.
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu022.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "x" | $80 ;               ; XMIT TO  DR9 L                                            .hbu022
                            .byte "m" | $80 ;               ;                                                           .hbu022
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
StatusMsgTxtResult_01       .byte "t" | $80 ;               ;                                                           .hbu022
StatusMsgTxtResult_02       .byte "o" | $80 ;               ;                                                           .hbu022
StatusMsgTxtResult_03       .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
                            .byte "d" | $80 ;               ;                                                           .hbu022
                            .byte "r" | $80 ;               ;                                                           .hbu022
                            .byte NumCharDigit_9            ;                                                           .hbu022
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
                            .byte "l" | $80 ;               ;                                                           .hbu022
StatusMsgTxtDigit_100       .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
StatusMsgTxtDigit_10        .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
StatusMsgTxtDigit_1         .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu022
                            
                            .byte $00 ; EndOfText                                                                       .hbu022
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_YELLOW_YELLOW           ; get game message color                                    .hbu022.
                            jsr StatusMsgTextColor          ; color                                                     .hbu022.
                            jmp LED_CursorPosRestore        ; restore old cursor position and return                    .hbu022.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetLoad               Does    : in game command: load a saved game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetLoad                .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu028.
                            bmi IGC_SetLoadX                ; check: HL_LevelTest_On - yes: no LOAD in test mode        .hbu028.
                            
TestFlag_DemoRecording      lda HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_SetLoadX                ; check: HL_DemoRec_On - yes: no LOAD in recording mode     .hbu034.
                            
TestFlag_Debug              lda HL_ModeDebug                ; get flag: debug mode                                      .hbu022.
                            beq SetLoadCmd                  ; check: HL_ModeDebug_Off - yes: select load                .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; set number of lives to minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get min number of lives                                   .hbu022.
                            sta HL_NumLives                 ;                                                           .hbu022.
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text            .hbu022.
                            jsr ColorStatus                 ; fill the status row with the selected colors              .hbu022.
; --------------------------------------------------------------------------------------------------------------------- ;
; no LOAD game in test / demo level recording mode / debug mode
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetLoadX                jmp GameInputHandler            ; no LOAD in test/demo recording/debug mode                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set LOAD command
; --------------------------------------------------------------------------------------------------------------------- ;
SetLoadCmd                  lda #$aa                        ; "L" - get load game command                               .hbu028.
                            jmp GameStorageStart            ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetSave               Does    : in game command: save a game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetSave                .block                           ; 
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu028.
                            beq ChkCheat                    ; check: HL_LevelTest_Off - yes: save still possible        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; no SAVE game in test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp GameInputHandler            ; no SAVE in test mode                                      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCheat                    lda HL_Cheated                  ; get flag: cheated                                         .hbu028.
                            bne SetSaveCmd                  ; check: HL_Cheated_No - yes                                .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; no saves after cheating
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp GameInputHandler            ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
SetSaveCmd                  lda #$8d                        ; "S" - get save game command                               .hbu028.
                            jmp GameStorageStart            ;                                                           .hbu028.
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetRandom             Does    : in game command: toggle random play level mode and restart game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetRandom              .block                           ;                                                           .hbu021.
                            lda HL_LevelTest                ; flag: level testmode on/off                               .hbu021.
                            bmi IGC_SetRandomX              ; check: HL_TestLevel_On - yes: not possible in test mode   .hbu021.
                            
                            ldx HL_DemoRec                  ; get flag: demo move recording mode                        .hbu034.
                            bmi IGC_SetRandomX              ; check: HL_DemoRec_On - yes: impossible in recording mode  .hbu034.
; --------------------------------------------------------------------------------------------------------------------- ;
; toggle random mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeRnd                  ; get random level mode                                     .hbu021.
                            eor #HL_ModeRnd_On              ; toggle mode                                               .hbu021.
                            sta HL_ModeRnd                  ; set new random level mode                                 .hbu021.
                            beq SetLevelNumbers             ; check: HL_ModeRnd_Off - yes: reinit level counting        .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; random mode on
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RND_LevelNumberTableInit    ; initialize the random level number table                  .hbu021.
                            
                            ldx #$ff                        ; get initial value                                         .hbu021.
                            stx HL_BufRndLevelNumOff        ; ini random level number table offset                      .hbu021.
                            jsr GameLevelNumIncHandler      ; control the level number increase and return              .hbu021.
                            jmp StartRandomMode             ;                                                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; store level numbers
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelNumbers             sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu021.
                            sta HL_LevelNumGame             ; set game level num (001-250)                              .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; correct game level numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_LevelNumGame             ; inc game level number (001-250)                           .hbu021.
                            
StartRandomMode             jmp GameStart                   ;                                                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetRandomX              jmp GameInputHandler            ; get keyboard and joystick input - call in game routines   .hbu021.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetJoystick           Does    : in game cmd: set input to joystick
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetJoystick            .block                           ; 
                            lda #HL_ControllerType_Joystick ; get joystick
                            sta HL_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetKeyboard           Does    : in game cmd: set input to keyboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetKeyboard            .block                           ; 
                            lda #HL_ControllerType_Keyboard ; get keyboard
                            sta HL_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DecSpeed              Does    : in game cmd: decrease game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DecSpeed               .block                           ; 
                            lda HL_GameSpeed                ; get game speed for decrease
                            cmp #HL_GameSpeed_Min           ; test min
                            beq IGC_IncSpeed.IGC_IncSpeedX  ; check: EQ - yes: bypass decrease
                            
                            dec HL_GameSpeed                ; slow down
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncSpeed              Does    : in game cmd: increase game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncSpeed               .block                           ; 
                            lda HL_GameSpeed                ; get game speed for increase
                            cmp #HL_GameSpeed_Max           ; test max
                            beq IGC_IncSpeedX               ; check: EQ - yes: bypass increase
                            
                            inc HL_GameSpeed                ; speed up
                            
IGC_IncSpeedX               jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_ShootMode             Does    : in game cmd: toggle shoot mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_ShootMode              .block                           ; 
                            lda HL_LodeRuShootMode          ; 
                            eor #HL_LodeRuShootMode_Front   ; toggle shoot mode
                            sta HL_LodeRuShootMode          ; 
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - call in game routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameGetInputText          Does    : fill the game input buffer with an user input text
;                           Expects : .Y=length of input field
;                                   : .C=0 - do not clear buffer
;                                   : .C=1 - clear buffer first
;                           Returns : .X=0 - no input text enterd
;                                   : .X=1 - input text entered
;                                   : .C=1 - <RUN/STOP> aborted
;                                   : .C=0 - normal end
; --------------------------------------------------------------------------------------------------------------------- ;
GameGetInputText           .block                           ; 
                            sty HL_InputBufferMaxLen        ; input field length
                            bcc GetByteFromBufIni           ; check: flag clear - no: do not clear input buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the input buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #" " | $80                  ; get <SHIFT_SPACE>
                            ldx #HL_InputBuffer_Len         ; get length input buffer
ClearNextInputBufPos        sta HL_InputBuffer,x            ; set next <SHIFT_SPACE>
                            
                            dex                             ; dec length input buffer
                            bpl ClearNextInputBufPos        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
GetByteFromBufIni           ldx #$00                        ; get initial value                                         .hbu012.
                            stx HL_InputBufferPos           ; ini input input screen pos                                .hbu012.
                            stx HL_KeyNew                   ; discard input key                                         .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; get the next input byte until <RETURN> key is pressed
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextByteFromBuffer       ldx HL_InputBufferPos           ; get current input screen pos                              .hbu012.
                            lda HL_InputBuffer,x            ; get a buffer char                                         .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare last char input for cursor blink - check for digits as they will not be substituted
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDigit                    cmp #NumDigit_Min               ; test a zero                                               .hbu012.
                            bcc CharSubstitution            ; check: LT - yes: substitute characters                    .hbu012.
                            
                            cmp #NumDigit_Max + $01         ; test a nine                                               .hbu012.
                            bcc WaitForInputKey             ; check: LT - yes: digit - no substitution                  .hbu012.
                            
CharSubstitution            jsr TextCharPrepare             ; map to character image data numbers                       .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for keyboard input in .A
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForInputKey             jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile      .hbu012.
                            
                            ldy #HL_KeyNew_None             ; get initial value                                         .hbu012.
                            sty HL_KeyNew                   ; discard input key                                         .hbu012.
                            
                            ldx HL_PlayerInputType          ; get user input type                                       .hbu027.
                            bne BeepInputError              ; check: joystick - yes: not accepted                       .hbu027.
                            
                            jsr CheckInputDigit             ; check digital keys and map to $00-$09                     .hbu012.
                            bcc OutDigit                    ; check: was digit - yes                                    .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_RunStop            cmp #$3f                        ; test <RUN/STOP>                                           .hbu012.
                            beq GoExit_EditAborted          ; check: <RUN/STOP> - yes: abort edit                       .hbu012.
                            
CheckKey_Q                  cmp #$be                        ; test <SHIFT-Q>                                            .hbu012.
                            bne CheckNumCtrlChars           ; check: <SHIFT-Q> - no: continue                           .hbu012.
                            
GoExit_EditAborted          jmp Exit_EditAborted            ; abort edit after Q or <RUN/STOP>                          .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; check input control chars - substitute raw input char first
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNumCtrlChars           jsr InputKeySubstitute          ; get a char substitution                                   .hbu012.
                            
                            cmp #$8d                        ; test <RETURN> - end of edit                               .hbu012.
                            beq Exit_EditDone               ; check: EQ - yes: edit done                                .hbu012.
                            
                            cmp #$88                        ; test key <CURSOR UP/DOWN>                                 .hbu012.
                            bne CheckKey_CursorLR           ; check: EQ - no: check next                                .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor left
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_InputBufferPos           ; current input screen pos                                  .hbu012.
                            beq BeepInputError              ; check: leftmost pos - yes: error                          .hbu012.
                            
                            dec HL_InputBufferPos           ; current input screen pos                                  .hbu012.
                            dec HLZ_ScreenCol               ;                                                           .hbu012.
                            jmp GetNextByteFromBuffer       ;                                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_CursorLR           cmp #$95                        ; test key <CURSOR LEFT/RIGHT>                              .hbu012.
                            bne CheckForInputChars          ; check: EQ - no: test chars                                .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_InputBufferMaxLen        ; get input buffer max len                                  .hbu012.
                            dex                             ; dec input buffer max len                                  .hbu012.
                            cpx HL_InputBufferPos           ; test with current input screen pos                        .hbu012.
                            beq BeepInputError              ; check: EQ - yes: error                                    .hbu012.
                            
                            inc HLZ_ScreenCol               ; inc column                                                .hbu012.
                            inc HL_InputBufferPos           ; inc current input screen pos                              .hbu012.
                            jmp GetNextByteFromBuffer       ;                                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; check input chars
; --------------------------------------------------------------------------------------------------------------------- ;
CheckForInputChars          cmp #" " | $80                  ; test <SHIFT_SPACE>                                        .hbu012.
                            beq OutChar                     ; check: EQ - yes: output                                   .hbu012.
                            
                            cmp #"." | $80                  ; test "."                                                  .hbu012.
                            beq OutChar                     ; check: EQ - yes: output                                   .hbu012.
                            
                            cmp #"a" | $80                  ; test "A"                                                  .hbu012.
                            bcc BeepInputError              ; check: LT - yes: error                                    .hbu012.
                            
                            cmp #"z" | $80 + $01            ; test "Z" + 1                                              .hbu012.
                            bcs BeepInputError              ; check: GE - yes: error                                    .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; ouput a char
; --------------------------------------------------------------------------------------------------------------------- ;
OutChar                     ldy HL_InputBufferPos           ; get current input screen pos                              .hbu012.
                            sta HL_InputBuffer,y            ; fill input buffer                                         .hbu012.
                            jsr TextOutCharHandler          ; output a single char - advance HLZ_ScreenCol              .hbu012.
                            
                            jmp MoveCursorRight             ; set modify flag and continue                              .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; output a digit
; --------------------------------------------------------------------------------------------------------------------- ;
OutDigit                    clc                             ;                                                           .hbu012.
                            adc #NumCharDigit_Min           ; map to chr digit image data numbers                       .hbu012.
                            ldy HL_InputBufferPos           ; get current input screen pos                              .hbu012.
                            sta HL_InputBuffer,y            ; out digit                                                 .hbu012.
                            jsr DigitCharOutHandler         ; output a single digit char - advance HLZ_ScreenCol        .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor right
; --------------------------------------------------------------------------------------------------------------------- ;
MoveCursorRight             inc HL_InputBufferPos           ; inc current input screen pos                              .hbu012.
                            
                            lda HL_InputBufferPos           ; get current input screen pos                              .hbu012.
                            cmp HL_InputBufferMaxLen        ; test max right                                            .hbu012.
                            bcc GoGetNextByteFromBuffer     ; check: LT - yes: get another buffer byte                  .hbu012.
                            
                            dec HL_InputBufferPos           ; dec current input screen pos                              .hbu012.
                            dec HLZ_ScreenCol               ; dec screen col                                            .hbu012.
                            
GoGetNextByteFromBuffer     jmp GetNextByteFromBuffer       ; get another buffer byte                                   .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; input error beep
; --------------------------------------------------------------------------------------------------------------------- ;
BeepInputError              jsr EditorErrorBeep             ; output an error beep signal                               .hbu012.
                            jmp GetNextByteFromBuffer       ; get another buffer byte                                   .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; finish input after <ENTER> was pressed
; --------------------------------------------------------------------------------------------------------------------- ;
Exit_EditDone               ldx HL_InputBufferMaxLen        ; get buffer max len                                        .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; overread trailing <SHIFT_SPACE> filler chars
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNextBufByte            lda HL_InputBuffer,x            ;                                                           .hbu012.
                            cmp #" " | $80                  ; test <SHIFT_SPACE>                                        .hbu012.
                            bne ExitInputTextFound          ; check: EQ - no: some text found                           .hbu012.
                            
                            dex                             ; dec buffer len                                            .hbu012.
                            bpl CheckNextBufByte            ; check: min - no: continue                                 .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; no input text found
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; set flag: normal end                                      .hbu012.
                            ldx #$00                        ; set flag: no text in input buffer                         .hbu012.
                            rts                             ;                                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; some input text found
; --------------------------------------------------------------------------------------------------------------------- ;
ExitInputTextFound          clc                             ; set flag: normal end                                      .hbu012.
                            ldx #$01                        ; set flag: input text found                                .hbu012.
                            rts                             ;                                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; edit aborted with <RUN/STOP> or <SHIFT Q> - discard all message changes
; --------------------------------------------------------------------------------------------------------------------- ;
Exit_EditAborted            lda #HLZ_LevelModified_No       ;                                                           .hbu012.
                            sta HLZ_LevelModified           ; clear a possible modification flag                        .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
; discard all changes and redisplay msg text - but only if in edit mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameMode                 ; get game mode $00=start $01=demo $02=play $05=edit        .hbu028.
                            cmp #HL_GameMode_Edit           ; test edit mode                                            .hbu028.
                            bne Exit_Aborted                ; check: edit mode - no: exit without msg update            .hbu028.
                            
                            ldy #HL_LevelDataBufMsgTxt_Len - $01 ; get buffer length                                    .hbu012.
GetNextDataMsgTxtChar       lda HL_LevelDataBufMsgTxt,y     ; get the message                                           .hbu012.
                            sta LevelMsgBuffer,y            ; refill message buffer                                     .hbu012.
                            sta HL_InputBuffer,y            ; refill input buffer for correct cursor blink              .hbu012.
                            
                            dey                             ; dec buffer length                                         .hbu012.
                            bpl GetNextDataMsgTxtChar       ; check: min - no: continue                                 .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LED_CursorPosMsg            ; set cursor to message position                            .hbu012.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
LevelMsgBuffer               = *                            ;                                                           .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $00                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $01                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $02                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $03                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $04                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $05                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $06                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $07                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $08                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $09                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $0a                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $0b                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $0c                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $0d                                                       .hbu012.
                            .byte " " | $80 ; <SHIFT_SPACE> ; $0e                                                       .hbu012.
                            
                            .byte $00 ; EndOfText           ;                                                           .hbu012.
; --------------------------------------------------------------------------------------------------------------------- ;
Exit_Aborted                sec                             ; set flag: exit <RUN/STOP>                                 .hbu012.
                            ldx #$00                        ;                                                           .hbu012.
                            rts                             ;                                                           .hbu012.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameNewChampionHandlerX   Does    : champion handler exit point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameNewChampionHandlerX    .block                           ; 
                            rts                             ;                                                           .hbu041.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; GameNewChampionHandler    Does    : eventually show hidden level 251 and congratulations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameNewChampionHandler     .block                           ; 
                            lda HL_Cheated                  ; test if cheats were used                                  .hbu041.
                            beq GameNewChampionHandlerX     ; check: HL_Cheated_Yes - yes: exit                         .hbu041.
                            
                            lda HL_ModeDebugUsed            ; test debug mode was used                                  .hbu041.
                            bne GameNewChampionHandlerX     ; check: HL_ModeDebugUsed - yes: no hooray                  .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; not cheated - so display hidden champion level with a short message
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumDisk_Champ      ; ini hidden disk level number                              .hbu041.
                            sta HL_LevelNumDisk             ; set hidden disk level number                              .hbu041.
                            
                            ldx #HL_OutToScreenPrep_No      ; get flag no copy data to prepare hires screen             .hbu041.
                            jsr GameLevelDataExpand         ; expand compressed level disk data                         .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; activate enemy sprites but not loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$dc                        ; ##.###.. - activate all 5 enemy sprites                   .hbu041.
                            sta SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; show message text
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$07                        ; set additional level message position                     .hbu041.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu041.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu041.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "n" | $80 ;               ;         NICELY DONE!                                      .hbu041.
                            .byte "i" | $80 ;               ;                                                           .hbu041.
                            .byte "c" | $80 ;               ;                                                           .hbu041.
                            .byte "e" | $80 ; <SHIFT_SPACE> ;                                                           .hbu041.
                            .byte "l" | $80 ;               ;                                                           .hbu041.
                            .byte "y" | $80 ; <SHIFT_SPACE> ;                                                           .hbu041.
                            .byte " " | $80 ;               ;                                                           .hbu041.
                            .byte "d" | $80 ;               ;                                                           .hbu041.
                            .byte "o" | $80 ;               ;                                                           .hbu041.
                            .byte "n" | $80 ; <SHIFT_SPACE> ;                                                           .hbu041.
                            .byte "e" | $80 ;               ;                                                           .hbu041.
                            .byte "!" | $80 ;               ;                                                           .hbu041.
                            .byte "!" | $80 ;               ;                                                           .hbu041.
                            
                            .byte $00 ; EndOfText                                                                       .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr StatusMsgTextShow           ; show the level message                                    .hbu041.
                            
                            lda TabJingleHeight_Min         ;                                                           .hbu041.
                            sta HL_JingleNum                ; select a jingle                                           .hbu041.
                            jsr JingleGotAllGoldCopy        ; prepare the hooray jingle                                 .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; get loderunner image position
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$09                        ;                                                           .hbu041.
                            sta HLZ_ScreenRow               ; screen row  ($00-$0f)                                     .hbu041.
                            lda #$0d                        ;                                                           .hbu041.
                            sta HLZ_ScreenCol               ; screen col  ($00-$1b)                                     .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; blink loderunner image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_LodeRunner_Edit ;                                                           .hbu041.
                            jsr BED_CursorBlink             ; wait for/get an input and blink the cursor meanwhile      .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; finish the actual game tune
; --------------------------------------------------------------------------------------------------------------------- ;
WaitTuneFinished            lda HL_TuneFreeBufferPosOff     ; get offset next free tune buffer byte                     .hbu041.
                            cmp HL_TuneToPlayOff            ; test still playing                                        .hbu041.
                            bne WaitTuneFinished            ; check: tune still playing - yes: continue wait            .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare restart
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_BLACK_BLACK             ;  prepare colorlevel                                       .hbu041.
                            tax                             ;                                                           .hbu041.
                            tay                             ;                                                           .hbu041.
                            jsr ColorLevelHandler           ; fill game level screen with the selected colors           .hbu041.
                            jsr StatusMsgTextReset          ; reset status line / display new num of lives              .hbu041.
                            
                            lda #HL_LevelNumDisk_Min        ; get restart disk level number                             .hbu041.
                            sta HL_LevelNumDisk             ; set restart disk level number                             .hbu041.
                              
                            rts                             ;                                                           .hbu041.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameTimeBlocksClear       Does    : initialize the loderunner level times data blocks
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameTimeBlocksClear        .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize times data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial value                                         .hbu039.
                            lda #$99                        ; get inital times value                                    .hbu039.
ClearNextBufferByte         sta HL_TimerBuf,y               ; clear times data buffer                                   .hbu039.
                            
                            iny                             ; inc buffer offset                                         .hbu039.
                            bne ClearNextBufferByte         ; check: max - no: continue                                 .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; write three level time blocks
; --------------------------------------------------------------------------------------------------------------------- ;
; init the unused space of level time blocks 1 and 2 - contains $54 (84) level times
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$aa                        ; get empty space marker                                    .hbu039.
                            ldy #<HL_TimerBuf_Empty         ; get empty space offset                                    .hbu039.
                            sta HL_TimerBuf,y               ; mark times empty buffer space byte 1                      .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; init the timer block modification flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TimerBuf_Mod_No         ; get initial value                                         .hbu039.
                            sta HL_TimerBuf_Mod             ; ini timer data modification flag                          .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; set and write the timer block number 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_TimerBuf_BlockNum_01    ; get times disk block number 01 (253) for WRITE            .hbu039.
                            sty HL_TimerBuf_BlockNum        ; set times buffer number byte                              .hbu039.
                            
                            lda #HL_DiskWrite               ; get flag write                                            .hbu039.
                            jsr TimerDiskHandler            ; write times block #01 for the disk level number           .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; set and write the timer block number 02
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_TimerBuf_BlockNum_02    ; get times disk block number 02 (254) for WRITE            .hbu039.
                            sty HL_TimerBuf_BlockNum        ; set times buffer number byte                              .hbu039.
                            
                            lda #HL_DiskWrite               ; get flag write                                            .hbu039.
                            jsr TimerDiskHandler            ; write times block #02 for the disk level number           .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; init the unused space of level time block 3 - is two levels short - contains the rest of $52 (82) level times
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$aa                        ; get empty space marker                                    .hbu039.
                            ldy #<HL_TimerBuf_Empty - $06   ; get empty space offset                                    .hbu039.
SetNextUnusedTimerBufByte   sta HL_TimerBuf,y               ; mark additional empty buffer space                        .hbu039.
                            
                            iny                             ; inc empty space offset                                    .hbu039.
                            cpy #<HL_TimerBuf_Empty         ; test max empty space offset                               .hbu039.
                            bne SetNextUnusedTimerBufByte   ; check: EQ - no: continue                                  .hbu039.
; --------------------------------------------------------------------------------------------------------------------- ;
; set and write the timer block number 03
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_TimerBuf_BlockNum_03    ; get times disk block number 03 (255) for WRITE            .hbu039.
                            sty HL_TimerBuf_BlockNum        ; set times buffer number byte                              .hbu039.
                            
                            lda #HL_DiskWrite               ; get flag write                                            .hbu039.
                            jmp TimerDiskHandler            ; write times block #03 for the disk level number and return.hbu039.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageStart          Does    : initialize and load/save a game from/to the save game block
;                           Expects : .A="L" - load a game
;                                   : .A="S" - save a game
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ; 
GameStorageStart           .block                           ;                                                           .hbu028.
                            pha                             ; save the action key                                       .hbu028.
                            
                            jsr GameStorageBlockRead        ; read the game save block from disk                        .hbu028.
                            
                            ldx #>HL_ScreenGfxDisplay       ; get gfx display screen                                    .hbu028.
                            stx HLZ_TargetGfxOutput         ; control gfx screen output - display=$20(00) hidden=$40(00).hbu028.
; --------------------------------------------------------------------------------------------------------------------- ; 
; dispatch load or save
; --------------------------------------------------------------------------------------------------------------------- ; 
                            pla                             ; restore action key                                        .hbu028.
                            cmp #$aa                        ; test "L"                                                  .hbu028.
                            bne GameSaveHandler             ; check: EQ - no: was "S"                                   .hbu028.
                            
                            jmp GameLoadHandler             ; was "L"                                                   .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ; 
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSaveHandler           Does    : in game command: save or delete a game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSaveHandler            .block                           ; 
                            jsr GameStorageList             ; show the game save slot selection list                    .hbu028.
                            
GameSaveHandlerShowTitle    jsr LED_CursorPosHome           ; set cursor home                                           .hbu028.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; S ADD A GAME  TO  THE LIST                                .hbu028.
                            .byte "s" | $80 ;               ; D DEL A GAME FROM THE LIST                                .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;  <R/S> CONTINUES THE GAME                                 .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "h" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "f" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "h" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "/" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "c" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "u" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "h" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                             
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player input
; --------------------------------------------------------------------------------------------------------------------- ;
WaitPlayerInput             jsr PlayerCheckInput            ; look for player input                                     .hbu028.
                            bcc WaitPlayerInput             ; none so far - continue waiting                            .hbu028.
                            
                            ldx #HL_KeyNew_None             ; get initial value                                         .hbu028.
                            stx HL_KeyNew                   ; discard key pressed                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check player input
; --------------------------------------------------------------------------------------------------------------------- ;
TestChar_Save               cmp #$0d                        ; test "S"                                                  .hbu028.
                            bne TestChar_Delete             ; check: EQ - no: next test                                 .hbu028.
                            
                            jmp GameStorageSlotAdd          ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
TestChar_Delete             cmp #$12                        ; test "D"                                                  .hbu028.
                            bne TestChar_RunStop            ; check: EQ - no: next test                                 .hbu028.
                            
                            jmp GameStorageSlotDel          ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
TestChar_RunStop            cmp #$3f                        ; test <RUN/STOP>                                           .hbu028.
                            bne CmdKeyInputError            ; check: EQ - no: error wrong command key                   .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; break - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp GameStorageFinish           ; cleanup and do a level restart                            .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
CmdKeyInputError            jsr EditorErrorBeep             ;                                                           .hbu028.
                            jmp WaitPlayerInput             ; wait for a valid command                                  .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLoadHandler           Does    : in game command: load a saved game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLoadHandler            .block                           ; 
                            jsr GameStorageList             ; show the game save slot selection list                    .hbu028.
                            
GameLoadTitleLine           jsr LED_CursorPosHome           ; set cursor home                                           .hbu028
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;     LOAD AND PLAY A GAME                                  .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;       ENTRY   >      <                                    .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;        <R/S> TO ABORT                                     .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "p" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "/" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "b" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set load cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_ScreenRow               ; screen row ($00-$0f)                                      .hbu028.
                            lda #$0f                        ; get input cursor column number                            .hbu028.
                            sta HLZ_ScreenCol               ; screen col ($00-$1b)                                      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; get a load entry name
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; clear buffer first                                        .hbu028.
                            ldy #HL_SaveGameBuf_Name_Len    ;                                                           .hbu028.
                            jsr GameGetInputText            ;                                                           .hbu028.
                            bcs AbortBreak                  ; check: <RUN/STOP> abort - yes                             .hbu028.
                            beq GameLoadTitleLine           ; check: text input - no: empty name - redisplay title      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; try to load an entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameStorageEntryFind        ; .C=0 - name not found   .C=1 - name found                 .hbu028.
                            bcs RestoreSavedEntryData       ; name found in list - restore all the values               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; beep error entry not found
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output an error beep signal                               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
ShowSaveGameListTitle       jmp GameLoadTitleLine           ; redisplay title                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; break - exit
; --------------------------------------------------------------------------------------------------------------------- ;
AbortBreak                  jmp GameLoadHandlerX            ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore the saved data
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreSavedEntryData       tay                             ; set list offset                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Lives,y ; restore number of lives                      .hbu028.
                            sta HL_NumLives                 ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; discount a live after every load
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ;                                                           .hbu028.
                            sbc #$01                        ; discount a live for every load                            .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Lives,y ; set new reduced number of lives              .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore scores
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Score_Hi,y    ; restore scores                         .hbu028.
                            sta HL_Score_Hi                 ;                                                           .hbu028.
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Score_Mi_Hi,y ;                                        .hbu028.
                            sta HL_Score_Mid_Hi             ;                                                           .hbu028.
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Score_Mi_Lo,y ;                                        .hbu028.
                            sta HL_Score_Mid_Lo             ;                                                           .hbu028.
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Score_Lo,y    ;                                        .hbu028.
                            sta HL_Score_Lo                 ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore game modes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Flag_Debug,y ; restore mode flags                      .hbu028.
                            sta HL_ModeDebugUsed            ; set flag debug mode used                                  .hbu028.
                            
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Flag_Mirror,y ;                                        .hbu028.
                            sta HL_ModeMirror               ; set flag mirror mode                                      .hbu028.
                            
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_Flag_RND,y ;                                           .hbu028.
                            sta HL_ModeRnd                  ; set flag random mode                                      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; restore game/disk level numbers - force level reload
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_SaveGameBuf + <HL_SaveGameBuf_Level,y ; restore game level num (001-250)             .hbu028.
                            stx HL_LevelNumGame             ; set game level num (001-250)                              .hbu028.
                            stx HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk.hbu028.
                            dex                             ; get disk level num (000-249)                              .hbu028.
                            stx HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a random field block needs to be restored
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_RND_BAM_Num,y ; get a possible RND block number        .hbu028.
                            beq ForceLevelReload            ; check: HL_ModeRnd_Off - yes: do not restore a RND block   .hbu028.
                            
                            stx HL_BufRndLevelNumOff        ; set new random number table offset                        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; isolate the required RND disk block number (000-009)
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #~HL_SaveGameBuf_RND_BAM_Num_Used ; remove RND BAM used flag                            .hbu028.
                            tax                             ;                                                           .hbu028.
                            jsr GameRandomBlockRead         ; load the required random level number block               .hbu028.
                            
                            ldy HL_BufRndLevelNumOff        ; set new random number table offset                        .hbu028.
                            lda HL_BufRndLevelNum,y         ; get next RND level number from table                      .hbu028.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; force a level block reload
; --------------------------------------------------------------------------------------------------------------------- ;
ForceLevelReload            lda #HL_LevelReload_Force       ; get flag force level reload                               .hbu028.
                            sta HL_LevelReload              ; set flag force level reload - reload if NE HL_LevelNumDisk.hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; remove save game list entry if all lives are used up
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_NumLives                 ; get number of lives                                       .hbu028.
                            cmp #$01                        ; test last life                                            .hbu028.
                            bne WriteSaveLst                ; check: EQ - no: keep entry                                .hbu028.
                            
                            jsr GameStorageEntryDel         ; yes - delete entry from list                              .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; write save list back to disk
; --------------------------------------------------------------------------------------------------------------------- ;
WriteSaveLst                jsr GameStorageBlockWrite       ; save the modified save games list                         .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset a posssible cheat flag - always good as saves are disallowed after cheating
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_Cheated_No              ; get initial value                                         .hbu028.
                            sta HL_Cheated                  ; reset a possible cheat flag to reallow game saves         .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; clear stack
; --------------------------------------------------------------------------------------------------------------------- ;
GameLoadHandlerX            pla                             ; remove return address of GameInputHandler                 .hbu028.
                            pla                             ;                                                           .hbu028.
                            
                            pla                             ; remove return address of LodeRuMoveHandler                .hbu028.
                            pla                             ;                                                           .hbu028.

                            jmp GameStorageFinish           ; cleanup and do a level restart                            .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageList           Does    : show the game save slot selection list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageList            .block                           ; 
                            lda #>HL_ScreenGfxDisplay       ; get gfx prepare screen                                    .hbu028.
                            sta HLZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000         .hbu028.
                            
                            jsr GameStorageBlockCheck       ; check "HBU" id - init block otherwise                     .hbu028.
                            jsr ScreenDisplayClear          ; clear the display grafic screen                           .hbu028.
                            
                            lda #HR_YELLOW_LT_GREY          ; get colors                                                .hbu028.
                            tax                             ;                                                           .hbu028.
                            ldy #WHITE                      ;                                                           .hbu028.
                            jsr ColorLevelHandler           ; set colors for level and status row                       .hbu028.
                            jsr ColorGameStorageHeader      ; set fix colors for game storage list header               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor and display list header
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ;                                                           .hbu028.
                            sta HLZ_ScreenCol               ; screen col ($00-$1b)                                      .hbu028.
                            lda #$04                        ;                                                           .hbu028.
                            sta HLZ_ScreenRow               ; screen row ($00-$0f)                                      .hbu028.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;  NAME  LVL MEN  SCORES  TYP                               .hbu028.
                            .byte "n" | $80 ;               ; ------ --- --- -------- ---                               .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "v" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "c" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte "p" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte "-" | $80 ;               ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial value                                         .hbu028.
                            sty HLZ_SaveGameDataOff         ; ini offset save game data                                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; display the save game list entries
; --------------------------------------------------------------------------------------------------------------------- ;
InitNextListIdLen           lda #HL_SaveGameBuf_Name_Len    ; get initial value                                         .hbu028.
                            sta HLZ_SaveGameDataNameLen     ; ini name length                                           .hbu028.
                            
GetNextListIdOff            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            lda HL_SaveGameBuf,y            ;                                                           .hbu028.
                            bne OutListIdChar               ; check: ent of save game list - no: continue               .hbu028.
                            
                            jmp GameStorageListX            ; no further entries - end of save game list reached        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
OutListIdChar               jsr TextOutCharHandler          ; control the output of a single char                       .hbu028.
                            
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            dec HLZ_SaveGameDataNameLen     ; dec name length                                           .hbu028.
                            bne GetNextListIdOff            ; check: min - no                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the save game level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - one blank separator column     .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            
                            lda HL_SaveGameBuf,y            ; get level number                                          .hbu028.
                            jsr StatusOutDigitBin           ; output a binary digit to status row                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the save game number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - one blank separator column     .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            
                            lda HL_SaveGameBuf,y            ; get number of lives                                       .hbu028.
                            jsr StatusOutDigitBin           ; output a binary digit to status row                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the save game scores
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - one blank separator column     .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            lda HL_SaveGameBuf,y            ; get score                                                 .hbu028.
                            jsr StatusOutDigitBCD           ; ouput the 1st two score digits                            .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            lda HL_SaveGameBuf,y            ; get score                                                 .hbu028.
                            jsr StatusOutDigitBCD           ; ouput the 2nd two score digits                            .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            lda HL_SaveGameBuf,y            ; get score                                                 .hbu028.
                            jsr StatusOutDigitBCD           ; ouput the 3rd two score digits                            .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            lda HL_SaveGameBuf,y            ; get score                                                 .hbu028.
                            jsr StatusOutDigitBCD           ; ouput the 4th two score digits                            .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; output the save game type
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - one blank separator column     .hbu028.
                            
                            ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the debug mode flag
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDebugMode                ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            
                            lda HL_SaveGameBuf,y            ; get debug mode flag                                       .hbu028.
                            beq AdrMirrorMode               ; check: HL_ModeDebug_Off - yes                             .hbu028.
                            
                            lda #"D"                        ;                                                           .hbu028.
                            jsr TextOutCharHandler          ; set debug mode marker                                     .hbu028.
                            jmp ChkMirrorMode               ; bypass column advance                                     .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the mirror mode flag
; --------------------------------------------------------------------------------------------------------------------- ;
AdrMirrorMode               inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - blank out debug mode column    .hbu028.
                            
ChkMirrorMode               ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            
                            lda HL_SaveGameBuf,y            ; get mirror mode flag                                      .hbu028.
                            beq AdrRandomMode               ; check: HL_ModeMirror_Off - yes                            .hbu028.
                            
                            lda #"M"                        ;                                                           .hbu028.
                            jsr TextOutCharHandler          ; set mirror mode marker                                    .hbu028.
                            jmp ChkRandomMode               ; bypass column advance                                     .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the random mode flag
; --------------------------------------------------------------------------------------------------------------------- ;
AdrRandomMode               inc HLZ_ScreenCol               ; inc screen col ($00-$1b) - blank out debug mode column    .hbu028.
                            
ChkRandomMode               ldy HLZ_SaveGameDataOff         ; get offset save game data                                 .hbu028.
                            inc HLZ_SaveGameDataOff         ; inc offset save game data                                 .hbu028.
                            
                            lda HL_SaveGameBuf,y            ; get random mode flag                                      .hbu028.
                            beq OutNewLine                  ; check: HL_ModeRnd_Off - yes                               .hbu028.
                            
                            lda #"R"                        ;                                                           .hbu028.
                            jsr TextOutCharHandler          ; set random mode marker                                    .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor to start of next row
; --------------------------------------------------------------------------------------------------------------------- ;
OutNewLine                  jsr TextCharOutNewLine          ; set the cursor to the next output line                    .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check buffer maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_SaveGameDataOff         ; get ptr save game data                                    .hbu028.
                            cmp #HL_SaveGameBuf_Len         ; test max reached - $0a entries of $10 bytes               .hbu028.
                            beq GameStorageListX            ; check: EQ - yes: exit                                     .hbu028.
                            
                            jmp InitNextListIdLen           ; continue with next row                                    .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageListX            rts                             ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageBlockCheck     Does    : check the game save block for a valid ID
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageBlockCheck      .block                           ;                                                           .hbu028.
                            lda HL_SaveGameBuf_Id_01        ;                                                           .hbu028.
                            cmp #HL_SaveGameBuf_Id_Char_01  ; "H"                                                       .hbu028.
                            bne GameStorageBlockClear       ; wrong id - clear and write back                           .hbu028.
                            
                            lda HL_SaveGameBuf_Id_02        ;                                                           .hbu028.
                            cmp #HL_SaveGameBuf_Id_Char_02  ; "B"                                                       .hbu028.
                            bne GameStorageBlockClear       ; wrong id - clear and write back                           .hbu028.
                            
                            lda HL_SaveGameBuf_Id_03        ;                                                           .hbu028.
                            cmp #HL_SaveGameBuf_Id_Char_03   ; "U"                                                      .hbu028.
                            bne GameStorageBlockClear       ; wrong id - clear and write back                           .hbu028.
                            
                            rts                             ; good list                                                 .hbu028.
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageBlockClear     Does    : initialize the game save block if it is invalid
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageBlockClear      .block                           ; 
                            ldx #$00                        ; get buffer offset                                         .hbu028.
                            txa                             ; get init value                                            .hbu028.
ClearNextListsDataByte      sta HL_SaveGameBuf,x            ;                                                           .hbu028.
                            
                            inx                             ; inc buffer offset                                         .hbu028.
                            bne ClearNextListsDataByte      ; check: max - no: continue                                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; init the RND block number control table
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #HL_SaveGameBuf_RND_BAM_Len - $01 ; ini RND block number table offset                   .hbu028.
                            lda #HL_SaveGameBuf_RND_BAM_Free; get flag RND block number table free                      .hbu028.
IniNextRndTabByte           sta HL_SaveGameBuf_RND_BAM,x    ; ini the RND block table of 10 entries                     .hbu028.
                            
                            dex                             ; dec RND table offset                                      .hbu028.
                            bpl IniNextRndTabByte           ; check: min - no: continue                                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; fill in the correct ID HBU
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_SaveGameBuf_Id_Char_01  ; "H"                                                       .hbu028.
                            sta HL_SaveGameBuf_Id_01        ;                                                           .hbu028.
                            lda #HL_SaveGameBuf_Id_Char_02  ; "B"                                                       .hbu028.
                            sta HL_SaveGameBuf_Id_02        ;                                                           .hbu028.
                            lda #HL_SaveGameBuf_Id_Char_03  ; "U                                                        .hbu028.
                            sta HL_SaveGameBuf_Id_03        ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; write back the initialized save games buffer block to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp GameStorageBlockWrite       ; write buffer back to disk and return                      .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageSlotAdd        Does    : save a new entry in the save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageSlotAdd         .block                           ; 
                            jsr LED_CursorPosHome           ; set cursor home                                           .hbu028.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;   SAVE A GAME IN PROGRESS                                 .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;       ENTRY  >      <                                     .hbu028.
                            .byte "s" | $80 ;               ;       <R/S>  TO ABORT                                     .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "v" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "m" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "i" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "p" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "g" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "/" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "b" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set save game input cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0e                        ; get input cursor column number                            .hbu028.
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)                                  .hbu028.
                            dec HLZ_ScreenRow               ; dec screen row ($00-$0f)                                  .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; get a save entry name 
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set flag: clear buffer first                              .hbu028.
                            ldy #HL_SaveGameBuf_Name_Len    ; get input buffer length                                   .hbu028.
                            jsr GameGetInputText            ; get a name                                                .hbu028.
                            bcs ShowSaveGameListTitle       ; check: <RUN/STOP> abort - yes                             .hbu028.
                            beq ShowSaveGameListTitle       ; check: text input - no: empty name                        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; try to save an entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameStorageEntryFind        ; .C=0 - name not found   .C=1 - name found                 .hbu028.
                            bcs SaveGameListError           ; check: name found in list - yes: error                    .hbu028.
                            
                            jsr GameStorageEntryFindFree    ; .C=0 - no free slot  .C=1 - free slot found  .A=position  .hbu028.
                            bcs FillSaveGameNameIni         ; check: free slot found - yes                              .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; beep error save game list full/name already used
; --------------------------------------------------------------------------------------------------------------------- ;
SaveGameListError           jsr EditorErrorBeep             ; output an error beep signal                               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
ShowSaveGameListTitle       jmp GameSaveHandler.GameSaveHandlerShowTitle  ;                                             .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy save game entry name
; --------------------------------------------------------------------------------------------------------------------- ;
FillSaveGameNameIni         pha                             ; save save list offset                                     .hbu028.
                            
                            tay                             ; set save list offset                                      .hbu028.
                            ldx #$00                        ; ini buffer offset                                         .hbu028.
GetNextNameChar             lda HL_InputBuffer,x            ; get name char                                             .hbu028.
                            sta HL_SaveGameBuf_Name,y       ; set name char                                             .hbu028.
                            
                            iny                             ; inc list offset                                           .hbu028.
                            inx                             ; inc buffer offset                                         .hbu028.
                            cpx #HL_SaveGameBuf_Name_Len    ; test name length                                          .hbu028.
                            bcc GetNextNameChar             ; check: LT - yes: continue                                 .hbu028.
                            
                            pla                             ; restore save list offset                                  .hbu028.
                            tay                             ; set as save list offset                                   .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy save game level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumGame             ; get game level number (001-250)                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Level,y ; set geme level number                        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy save game number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_NumLives                 ; get number of lives                                       .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Lives,y ; set number of lives                          .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy save game scores
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_Score_Hi                 ;                                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Score_Hi,y ;                                           .hbu028.
                            lda HL_Score_Mid_Hi             ;                                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Score_Mi_Hi,y ;                                        .hbu028.
                            lda HL_Score_Mid_Lo             ;                                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Score_Mi_Lo,y ;                                        .hbu028.
                            lda HL_Score_Lo                 ;                                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Score_Lo,y ;                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; copy save game modes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ModeDebugUsed            ; get flag debug mode used                                  .hbu028.
                            and #~HL_ModeDebugUsed_Level    ; reset flag debug mode was used for this level             .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Flag_Debug,y ; set flag debug mode used                .hbu028.
                            
                            lda HL_ModeMirror               ; get mirror mode                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Flag_Mirror,y ; set mirror mode                        .hbu028.
                            
                            lda HL_ModeRnd                  ; get random mode                                           .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_Flag_RND,y ; save random mode                          .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a random field block needs to be written
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq WriteSaveLst                ; check: HL_ModeRnd_Off - yes: do not save a random block   .hbu028.
                            
                            jsr GameRandomBlockWrite        ; write the random level number block to disk               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; write save entry list back to disk - buffer adress initialized in GameStorageStart
; --------------------------------------------------------------------------------------------------------------------- ;
WriteSaveLst                jsr GameStorageBlockWrite       ; save the modified save games list                         .hbu028.
                            
                            jmp GameSaveHandler             ; show the new list                                         .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageSlotDel        Does    : delete an existing entry from save game list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageSlotDel         .block                           ; 
                            jsr LED_CursorPosHome           ; set cursor home                                           .hbu028.
                            jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;       DELETE AN ENTRY                                     .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;       ENTRY  >      <                                     .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;       <R/S>  TO ABORT                                     .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "d" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "l" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "e" | $80 ;               ;                                                           .hbu028.
                            .byte "n" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "y" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte CR  | $80 ; <RETURN>      ; <NL>                                                      .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "<" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "/" | $80 ;               ;                                                           .hbu028.
                            .byte "s" | $80 ;               ;                                                           .hbu028.
                            .byte ">" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte "a" | $80 ;               ;                                                           .hbu028.
                            .byte "b" | $80 ;               ;                                                           .hbu028.
                            .byte "o" | $80 ;               ;                                                           .hbu028.
                            .byte "r" | $80 ;               ;                                                           .hbu028.
                            .byte "t" | $80 ;               ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu028.
                            
                            .byte $00 ; EndOfText                                                                       .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set delete cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0e                        ; get input cursor column number                            .hbu028.
                            sta HLZ_ScreenCol               ; screen col ($00-$1b)                                      .hbu028.
                            dec HLZ_ScreenRow               ; screen row ($00-$0f)                                      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; input an entry name to delete
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set flag: clear buffer first                              .hbu028.
                            ldy #HL_SaveGameBuf_Name_Len    ; get input buffer length                                   .hbu028.
                            jsr GameGetInputText            ; get a name                                                .hbu028.
                            bcs ShowSaveGameListTitle       ; check: <RUN/STOP> abort - yes                             .hbu028.
                            beq ShowSaveGameListTitle       ; check: text input - no: empty name                        .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; try to delete an entry 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameStorageEntryDel         ;                                                           .hbu028.
                            bcs WriteSaveLst                ; check: name line deleted - yes: write list back           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; beep error name not found
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output an error beep signal                               .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
ShowSaveGameListTitle       jmp GameSaveHandler.GameSaveHandlerShowTitle ; restart                                      .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; write back and print the modified list - buffer adress initialized in GameStorageStart
; --------------------------------------------------------------------------------------------------------------------- ;
WriteSaveLst                jsr GameStorageBlockWrite       ; save the modified save games list                         .hbu028.
                            
                            jmp GameSaveHandler             ; redisplay list                                            .hbu028.
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageBlockWrite     Does    : write the save games list block to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageBlockWrite      .block                           ; 
                            lda HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            pha                             ; save disk level num (000-249)                             .hbu028.
                            
                            lda DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; get output target memory block pointer       .hbu028.
                            pha                             ; save the output target memory block pointer               .hbu028.
                            
                            lda #>HL_SaveGameBuf            ; get address save game list buffer HI                      .hbu028.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; set the output target memory block pointer   .hbu028.

                            lda #HL_LevelNumDisk_Saves      ; get save game level num (t=$0d s=$00)                     .hbu028.
                            sta HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu002.
                            
                            lda #HL_DiskWrite               ; get flag write level data block to disk                   .hbu028.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu028.
                            
                            pla                             ; restore the output target memory block pointer            .hbu028.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ;                                              .hbu028.
                            
                            pla                             ; restore disk level num (000-249)                          .hbu028.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            
                            rts
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageBlockRead      Does    : read the save games list block from disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageBlockRead       .block                           ; 
                            lda HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            pha                             ; save disk level num (000-249)                             .hbu028.
                            
                            lda DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; get the input target memory block pointer      .hbu028.
                            pha                             ; save the output target memory block pointer               .hbu028.
                            
                            lda #>HL_SaveGameBuf            ; get address save game list buffer HI                      .hbu028.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; set the input target memory block pointer      .hbu028.
                            
                            lda #HL_LevelNumDisk_Saves      ; get save game level num (t=$0d s=$00)                     .hbu028.
                            sta HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu002.
                            
                            lda #HL_DiskRead                ; get flag read level data block from disk                  .hbu028.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu028.
                            
                            pla                             ; get the input target memory block pointer                 .hbu028.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; restore the input target memory block pointer  .hbu028.
                            
                            pla                             ; restore disk level num (000-249)                          .hbu028.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            
                            rts
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageEntryFind      Does    : find an entry name in the game save block
;                           Expects : 
;                           Returns : .C=0 - name not found in list
;                                   : .C=1 - name found in list  
;                                   : .A=start offset of name in list
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageEntryFind       .block                           ; 
                            ldy #$00                        ; ini save list buffer offset                               .hbu028.
InitNextFind                ldx #$00                        ; ini input buffer offset                                   .hbu028.
CheckNextEntry              lda HL_SaveGameBuf,y            ; get a save list buffer byte                               .hbu028.
                            cmp HL_InputBuffer,x            ; test wit input buffer byte                                .hbu028.
                            bne SetNextEntry                ; check: EQ - no: different                                 .hbu028.
                            
                            iny                             ; inc save list buffer offset                               .hbu028.
                            inx                             ; inc input buffer offset                                   .hbu028.
                            cpx #HL_SaveGameBuf_Name_Len    ; test max                                                  .hbu028.
                            bne CheckNextEntry              ; check: EQ - no: continue                                  .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; entry found
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; save name already existing                                .hbu028.
                            and #$f0                        ; get buffer position                                       .hbu028.
                            
                            sec                             ; set flag: save name found                                 .hbu028.
                            rts                             ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; actual save name differs from entered name so check next entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEntry                tya                             ;                                                           .hbu028.
                            and #$f0                        ;                                                           .hbu028.
                            clc                             ;                                                           .hbu028.
                            adc #HL_SaveGameBuf_Entry_Len   ; point offset to next buffer pos                           .hbu028.
                            tay                             ; set offset to next buffer pos                             .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check last entry processed
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_SaveGameBuf_Len         ; test max                                                  .hbu028.
                            bne InitNextFind                ; check: EQ - no: continue                                  .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; entry not found
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; set flag: name not found in save game list                .hbu028.
                            rts                             ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageEntryFindFree  Does    : find next free slot in the save game list
;                           Expects : 
;                           Returns : .C=0 - list already full - no free slot available
;                                   : .C=1 - free slot found
;                                   : .A=offset of free slot
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageEntryFindFree   .block                           ; 
                            ldy #$00                        ; ini save list buffer offset                               .hbu028.
IniNextEntryFind            ldx #HL_SaveGameBuf_Name_Len    ; get entry length                                          .hbu028.
GetNextEntryChar            lda HL_SaveGameBuf,y            ; get an entry name char                                    .hbu028.
                            bne SetNextEntry                ; check: <ZERO> - no: set next entry                        .hbu028.
                            
                            iny                             ; inc save list buffer offset                               .hbu028.
                            dex                             ; dec entry length                                          .hbu028.
                            bne GetNextEntryChar            ; check: min - no: continue                                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; free slot found
; --------------------------------------------------------------------------------------------------------------------- ;
FreeEntry                   tya                             ; save name already existing                                .hbu028.
                            and #$f0                        ; get buffer position                                       .hbu028.
                            
                            sec                             ; set fleg: free slot found found                           .hbu028.
                            rts                             ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; actual save game slot is already occupied
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEntry                tya                             ; get offset                                                .hbu028.
                            and #$f0                        ; isolate record count                                      .hbu028.
                            clc                             ;                                                           .hbu028.
                            adc #HL_SaveGameBuf_Entry_Len   ; point offset to next buffer pos                           .hbu028.
                            tay                             ; set offset to next buffer pos                             .hbu028.
                            
                            cmp #HL_SaveGameBuf_Len         ; test max                                                  .hbu028.
                            bne IniNextEntryFind            ; check: EQ - no: continue                                  .hbu028.
                            
                            clc                             ; set flag: list is full - no free slot available           .hbu028.
                            rts                             ;                                                           .hbu028.
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageEntryDel       Does    : try to delete an entry from the game save list
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageEntryDel        .block                           ;                                                           .hbu028.
                            jsr GameStorageEntryFind        ; .C=0 - name not found   .C=1 - name found                 .hbu028.
                            bcc GameStorageEntryDelX        ; check: entry found - no: exit with .C=0 - no entry found  .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; fetch and save the random level save block number before overwriting the entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get the offset to the entry to be deleted                 .hbu028.
                            lda HL_SaveGameBuf + <HL_SaveGameBuf_RND_BAM_Num,y ; get the RND level save block number    .hbu028.
                            pha                             ; save it                                                   .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; delete the entry by moving the whole list one position up
; --------------------------------------------------------------------------------------------------------------------- ;
MoveNextEntryUp             lda HL_SaveGameBuf + HL_SaveGameBuf_Entry_Len,y ;                                           .hbu028.
                            sta HL_SaveGameBuf,y            ; overwrite entry found                                     .hbu028.
                            
                            iny                             ; inc offset                                                .hbu028.
                            cpy #HL_SaveGameBuf_Len         ; test max                                                  .hbu028.
                            bcc MoveNextEntryUp             ; check: EQ - no: continue                                  .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a random field block needs to be freed
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore the random level save block number                .hbu028.
                            beq SetSuccess                  ; check: used - no: skip BAM free                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; mark the RND BAM entry as available again
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #~HL_SaveGameBuf_RND_BAM_Num_Used ; reset RND BAM used flag - isolate BAM block number  .hbu028.
                            tay                             ; set block number as an offset                             .hbu028
                            lda #HL_SaveGameBuf_RND_BAM_Free;                                                           .hbu028
                            sta HL_SaveGameBuf_RND_BAM,y    ; mark BAM block as free again                              .hbu028
                            
SetSuccess                  sec                             ; set flag: entry found and overwritten                     .hbu028.
                            
GameStorageEntryDelX        rts                             ;                                                           .hbu028.
                           .bend                            ;                                                           .hbu028.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStorageFinish         Does    : in game command: cleanup load or save
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStorageFinish          .block                           ;                                                           .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ; 
; restore the old colors
; --------------------------------------------------------------------------------------------------------------------- ; 
                            jsr ScreenDisplayClear          ; clear the display grafic screen                           .hbu028.
                            jsr ColorLevelSelect            ; select a new color combination every 10th level           .hbu028.
                            jsr StatusAreaSetup             ; display the status row with separator and text            .hbu028.
                            jsr ColorStatus                 ; fill the status row with the selected colors              .hbu028.
                            
                            jmp LevelStart                  ; start all over                                            .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameRandomBlockRead       Does    : restore a random level number block
;                           Expects : .X=RND block number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameRandomBlockRead        .block                           ; 
                            lda HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu028.
                            pha                             ; save disk level num (000-249)                             .hbu028.
                            
                            lda DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; get the input target memory block pointer      .hbu028.
                            pha                             ; save the input target memory block pointer                .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; set RND level number block address
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>HL_BufRndLevelNum         ; get RND number table buffer address HI                    .hbu028.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; set store buffer address HI                    .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; read in random level block
; --------------------------------------------------------------------------------------------------------------------- ;
                            stx HL_LevelNumDisk             ; set save RND level number block number (000-009)          .hbu028.
                            
                            lda #HL_DiskRead | HL_DiskForce_RND ; set flag read RND level number block from disk        .hbu028.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; reset to level data block address
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; get the input target memory block pointer                 .hbu028.
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi ; restore the input target memory block pointer  .hbu028.
                            
                            pla                             ; restore disk level num (000-249)                          .hbu028.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            
                            rts                             ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameRandomBlockWrite      Does    : write the random level number block to disk
;                           Expects : .Y=offset to save game list buffer entry
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameRandomBlockWrite       .block                           ; 
                            tya                             ; get offset to save game list buffer entry                 .hbu028.
                            pha                             ; save offset to save game list buffer entry                .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; find the next free RND BAM entry - there should always be at least one available
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; ini table entry counter                                   .hbu028.
                            ldy #$00                        ; ini table entry offset                                    .hbu028.
GetNextBAMEntry             lda HL_SaveGameBuf_RND_BAM,y    ; get an BAM table entry                                    .hbu028.
                            bmi FreeEntryFound              ; check: HL_SaveGameBuf_RND_BAM_Free - yes                  .hbu028.
                            
                            inx                             ; inc table entry counter                                   .hbu028.
                            iny                             ; inc table entry offset                                    .hbu028.
                            bne GetNextBAMEntry             ; allways (hopefully)                                       .hbu028.
                            
FreeEntryFound              pla                             ; restore offset to save game list buffer entry             .hbu028.
                            tay                             ; set offset to save game list buffer entry                 .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; update the control table entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get RND save level block number                           .hbu028.
                            ora #HL_SaveGameBuf_RND_BAM_Num_Used ; insert flag BAM number used                          .hbu028.
                            sta HL_SaveGameBuf + <HL_SaveGameBuf_RND_BAM_Num,y ; set RND block num in save level block  .hbu028.
                            
                            lda #HL_SaveGameBuf_RND_BAM_Used; get flag entry used                                       .hbu028.
                            sta HL_SaveGameBuf_RND_BAM,x    ; mark status table RND level number block as used          .hbu028.
; --------------------------------------------------------------------------------------------------------------------- ;
; write the RND level number block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu028.
                            pha                             ; save disk level num (000-249)                             .hbu028.
                            
                            lda DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; get output target memory block pointer       .hbu028.
                            pha                             ; save the output target memory block pointer               .hbu028.
                            
                            lda #>HL_BufRndLevelNum         ; get RND number table block address                        .hbu028.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; set output target memory block pointer       .hbu028.
                            
                            stx HL_LevelNumDisk             ; set save RND level number block number (000-009)          .hbu028.
                            
                            lda #HL_DiskWrite | HL_DiskForce_RND ; set flag write RND level number block to disk        .hbu028.
                            jsr DiskOperationHandler        ; read or write a game data block from disk                 .hbu028.
                            
                            pla                             ; restore the output target memory block pointer            .hbu028.
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ;                                              .hbu028.
                            
                            pla                             ; restore disk level num (000-249)                          .hbu028.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu028.
                            
                            rts                             ;                                                           .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelNumDecHandler    Does    : control the level number decrease
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelNumDecHandler     .block                           ; 
                            lda HL_ModeRnd                  ; get flag: random mode                                     .hbu021.
                            bpl SelPrevLevelNum             ; check: random mode - no                                   .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; select previous random level number                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RND_GetPrevLevelNumber      ; get next random number from table                         .hbu021.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu021.
                                                                                                                        
                            inx                             ; inc disk level num (000-249)                              .hbu021.
                            stx HL_LevelNumGame             ; set game level num (001-250)                              .hbu021.
                                                                                                                        
                            rts                             ;                                                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; set previous normal level number                            
; --------------------------------------------------------------------------------------------------------------------- ;
SelPrevLevelNum             dec HL_LevelNumDisk             ; dec disk level num (000-249)                              .hbu002.
                            
                            ldy HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu002.
                            cpy #$ff                        ; test min                                                  .hbu002.
                            bne GameLevelNumIncHandler.SetLevelNum ; check: .NE. - yes: set it                          .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate level number to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_LevelNumDisk_Max        ; get max level num                                         .hbu002.
                            jmp GameLevelNumIncHandler.SetLevelNum ;                                                    .hbu002.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelNumIncHandler    Does    : control the level number increase
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelNumIncHandler     .block                           ; 
                            lda HL_ModeRnd                  ; get flag: random mode                                     .hbu021.
                            bpl SelNextLevelNum             ; check: random mode - no                                   .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; select next random level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RND_GetNextLevelNumber      ; get next random number from table                         .hbu021.
                            sta HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu021.
                                                              
                            inx                             ; inc disk level num (000-249)                              .hbu021.
                            stx HL_LevelNumGame             ; set game level num (001-250)                              .hbu021.
                                                              
                            rts                             ;                                                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; select next normal level number                            
; --------------------------------------------------------------------------------------------------------------------- ;
SelNextLevelNum             ldy HL_LevelNumDisk             ; get disk level num (000-249)                              .hbu002.
                            cpy #HL_LevelNumDisk_Max        ; test max                                                  .hbu002.
                            beq SetLevelNum_Min             ; check: .EQ. - yes: get min                                .hbu002.
                            
                            iny                             ; inc disk level num (000-249)                              .hbu002.
                            jmp SetLevelNum                 ; set it                                                    .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate level number to minimum
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelNum_Min             ldy #HL_LevelNumDisk_Min        ;                                                           .hbu002.
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag last level passed successfully
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #HL_LastLevelPassed_Yes     ; get flag all 250 levels solved                            .hbu041.
;                           sta HL_LastLevelPassed          ; set flag all 250 levels solved                            .hbu041.
                            inc HL_LastLevelPassed          ; get flag all 250 levels solved                            .hbu041.
; --------------------------------------------------------------------------------------------------------------------- ;
; set the new level number
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelNum                 sty HL_LevelNumDisk             ; set disk level num (000-249)                              .hbu002.
                            iny                             ;                                                           .hbu002.
                            sty HL_LevelNumGame             ; set game level num (001-250)                              .hbu002.
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetJoystickAction     Does    : get and set joystick shoot or move directions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetJoystickAction      .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne ChkJoystickMoves            ; check: shoot - no: check move directions
; --------------------------------------------------------------------------------------------------------------------- ;
; was shoot - handle mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuShootMode         ; get shoot mode
                            eor HL_LodeRuShootMode          ; isolate shoot mode
                            bpl ShootLeft                   ; check: shoot mode HLZ_LodeRuShootMode_Back - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$44                        ; get a demo move: shoot right                              .hbu034.
                            sta HLZ_RecordDemoMove          ; set a demo move: shoot right                              .hbu034.
                            
                            lda #HL_JoystickShoot_Ri        ; get shoot right
                            sta HL_JoystickMoveDirY         ; set shoot right Y
                            sta HL_JoystickMoveDirX         ; set shoot right X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot left and exit
; --------------------------------------------------------------------------------------------------------------------- ;
ShootLeft                   lda #$55                        ; get a demo move: shoot left                               .hbu034.
                            sta HLZ_RecordDemoMove          ; set a demo move: shoot left                               .hbu034.
                            
                            lda #HL_JoystickShoot_Le        ; get shoot left
                            sta HL_JoystickMoveDirY         ; set shoot left Y
                            sta HL_JoystickMoveDirX         ; set shoot left X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick directional moves
; --------------------------------------------------------------------------------------------------------------------- ;
ChkJoystickMoves            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            sta HLZ_WorkJoystickMove        ; save CIA value
                            
                            and #CIAPRA_JOY_DO              ; Bit 1: Joystick 2 - Down  0=pressed
                            beq GetJoystickMove_Down        ; check: down - yes: set down
                            
                            lda HLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_UP              ; Bit 0: Joystick 2 - Up    0=pressed
                            beq GetJoystickMove_Up          ; check: up - yes: set up
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move up_down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$06                        ; get demo move none                                        .hbu034.
                            stx HLZ_RecordDemoMove          ; set demo move none                                        .hbu034.
                            
                            ldx #HL_JoystickMoveDir_None    ; get no move
                            stx HL_JoystickMoveDirY         ; ini move up_down
                            beq ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; set move up
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Up          ldx #$00                        ; get demo move up                                          .hbu034.
                            stx HLZ_RecordDemoMove          ; set demo move up                                          .hbu034.
                            
                            ldx #HL_JoystickMoveDirY_Up     ; get move up
                            stx HL_JoystickMoveDirY         ; set move up
                            bne ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; set move down
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Down        ldx #$02                        ; get demo move down                                        .hbu034.
                            stx HLZ_RecordDemoMove          ; set demo move down                                        .hbu034.
                            
                            ldx #HL_JoystickMoveDirY_Do     ; get move down
                            stx HL_JoystickMoveDirY         ; set move down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkMoves_Left_Right         lda HLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_RI              ; Bit 3: Joystick 2 - Right 0=pressed
                            beq GetJoystickMove_Right       ; check: right - yes: set right
                            
                            lda HLZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_LE              ; Bit 2: Joystick 2 - Left  0=pressed
                            beq GetJoystickMove_Left        ; check: left - yes: set left
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move left_right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_RecordDemoMove          ; get prepared demo move                                    .hbu034.
                            ora #$60                        ; insert demo move none                                     .hbu034.
                            sta HLZ_RecordDemoMove          ; set compound demo move                                    .hbu034.
                            
                            ldx #HL_JoystickMoveDir_None    ; get move none
                            stx HL_JoystickMoveDirX         ; set move none
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set move right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Right       lda HLZ_RecordDemoMove          ; get prepared demo move                                    .hbu034.
                            ora #$30                        ; insert demo move right                                    .hbu034.
                            sta HLZ_RecordDemoMove          ; set compound demo move                                    .hbu034.
                            
                            ldx #HL_JoystickMoveDirX_Ri     ; get move right
                            stx HL_JoystickMoveDirX         ; set move right
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set move left and exit
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Left        lda HLZ_RecordDemoMove          ; get prepared demo move                                    .hbu034.
                            ora #$10                        ; insert demo move left                                     .hbu034.
                            sta HLZ_RecordDemoMove          ; set compound demo move                                    .hbu034.
                            
                            ldx #HL_JoystickMoveDirX_Le     ; get move left
                            stx HL_JoystickMoveDirX         ; set move left
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; in game commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdChar              = *       ; 
                            .byte $9e ; U        - Next level
                            .byte $a9 ; P        - Previous level                                                       .hbu014.
                            .byte $be ; Q        - Quit level test                                                      .hbu019.
                            .byte $95 ; F        - Increase lives
                            .byte $3f ; RUN/STOP - Pause
                            .byte $91 ; R        - Resign
                            .byte $8a ; A        - Suicide - Restart the level
                            .byte $a2 ; J        - Joystick control
                            .byte $a5 ; K        - Keyboard control
                            
                            .byte $9f ; V        - Load levels mirrored                                                 .hbu018.
                            .byte $8c ; Z        - Random (Zufall) level mode                                           .hbu021.
                            
                            .byte $aa ; L        - load game                                                            .hbu028.
;                           .byte $8d ; S        - save game (only available at game start)                             .hbu028. removed
                            
                            .byte $9a ; G        - Debug: Set all gold collected                                        .hbu022.
                            .byte $8d ; S        - Debug: Inc scores                                                    .hbu022.
                            .byte $aa ; L        - Debug: Dec number of lives                                           .hbu018.
                            
                            .byte $2b ; +        - Inc game speed
                            .byte $28 ; -        - Dec game speed
                            
                            .byte $92 ; D        - Toggle shoot mode
                            
                            .byte $00 ; end of game command table
; --------------------------------------------------------------------------------------------------------------------- ;
; in game command routines
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdAddress           .word IGC_LevelNext   - $01 ; U        - try Next Level
                            .word IGC_LevelPrev   - $01 ; P        - try Previous Level                                 .hbu014.
                            .word IGC_TestQuit    - $01 ; Q        - quit level test and return to editor               .hbu019.
                            .word IGC_IncNumLife  - $01 ; F        - increase number of lives
                            .word IGC_Pause       - $01 ; RUN/STOP - pause the game
                            .word IGC_Resign      - $01 ; R        - resign the game
                            .word IGC_Suicide     - $01 ; A        - commit suizide
                            .word IGC_SetJoystick - $01 ; J        - set joystick control
                            .word IGC_SetKeyboard - $01 ; K        - set keyboard control
                            
                            .word IGC_SetMirror   - $01 ; V        - set mirror level load mode                         .hbu018.
                            .word IGC_SetRandom   - $01 ; Z        - set random (zufall) level mode                     .hbu021.
                            
                            .word IGC_SetLoad     - $01 ; L        - load a game from its save game block               .hbu028.
;                           .word IGC_SetSave     - $01 ; S        - save a game to   its save game block               .hbu028. moved to game start
                            
                            .word IGC_DebugGold   - $01 ; G        - debug: set all gold collected                      .hbu022.
                            .word IGC_DebugScore  - $01 ; S        - debug: inc scores in steps of 1075                 .hbu022.
                            .word IGC_DebugLives  - $01 ; L        - debug: dec number of lives                         .hbu022.
                            
                            .word IGC_IncSpeed    - $01 ; +        - inc game speed
                            .word IGC_DecSpeed    - $01 ; -        - dec game speed
                            
                            .word IGC_ShootMode   - $01 ; D        - toggle shoot mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetImageAndPosXY    Does   : get loderunner image number and PosXY
;                           Expects : 
;                           Returns : .A=loderunner image number
;                                   : .X=loderunner PosX
;                                   : .Y=loderunner PosY
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetImageAndPosXY     .block                           ; 
                            ldx HLZ_LodeRuCol               ; get actual col loderunner
                            ldy HLZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; add horizontal gfx screen image offset
                            
                            stx HLZ_WorkImgOffsetPosX       ; save horizontal offset
                            
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            ldx HLZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            jsr ScreenAddGfxOnImagePosY     ; add vertical gfx screen image offset
                            
                            ldx HLZ_LodeRuSprtNum           ; get loderunner sprite number
                            lda TabNumSpriteLodeRu,x        ; get loderunner image number
                            
                            ldx HLZ_WorkImgOffsetPosX       ; restore horizontal offset
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGold             Does    : let loderunner pick up a piece of gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGold               .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosX         ; get loderunner on image PosX
                            cmp #HLZ_LodeRuOnImgPosX_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner on image PosY
                            cmp #HLZ_LodeRuOnImgPosY_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; lode runner is PosX/PosY centered
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Gold            ; test gold
                            bne LodeRuGetGoldX              ; check: EQ - no: exit
                            
                            lsr HL_LodeRuGetGold            ; set flag loderunner just gets gold
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare a randomized got gold jingle
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$10                        ; get bottom limit
                            ldy #$20                        ; get upper limit
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            
                            sta TabGoldJinglePart_01 + $01  ; set 1st tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_02 + $01  ; set 2nd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_03 + $01  ; set 3rd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_04 + $01  ; set 4th tune data pointer voice 2
                            
                            jsr LodeRuSetGetGoldJingle      ; jingle data must follow directly
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart           = *       ; 
TabGoldJinglePart_01        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $b0 ; tune s/r/volume  (not used)
TabGoldJinglePart_Len       = * - TabGoldJinglePart ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_02        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_03        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $90 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_04        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
                            
                            .byte $00 ; end of tune marker
; --------------------------------------------------------------------------------------------------------------------- ;
; discount picked up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_GoldToCollect            ; discount gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row/col to loderunner row/col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy HLZ_LodeRuCol               ; get actual col loderunner
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get empty space
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #HL_TileNum_Gold            ; get gold
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; score gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>HL_Score_Gold             ; score add value HI - gold scores 250 points
                            lda #<HL_Score_Gold             ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                            
LodeRuGetGoldX              rts                             ; exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveSpriteNumRotate Does    : rotate loderunner sprite number between minimum and maximum values
;                           Expects : .A=sprite number min
;                                   : .X=sprite number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveSpriteNumRotate  .block                           ; 
                            inc HLZ_LodeRuSprtNum           ; inc sprite number to next phase
                            
                            cmp HLZ_LodeRuSprtNum           ; test lower limit
                            bcc ChkUpperLimit               ; check: LT - yes: check max
                            
SetToMinValue               sta HLZ_LodeRuSprtNum           ; reset to min value
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpx HLZ_LodeRuSprtNum           ; test upper limit
                            bcc SetToMinValue               ; check: LT - yes: reset to lower limit
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCaughtHandler       Does    : control loderunner caught by an enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCaughtHandler        .block                           ; 
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            lda HLZ_LodeRuEnemyCollision    ; get sprite collision  $01=lr caught
                            beq LodeRuCaughtHandlerX        ; check: caught - no: exit
                            
                            lda HL_LodeRuGetGold            ; get flag gold  $00=just gets it
                            beq LodeRuCaughtHandlerX        ; check: just picking up gold - yes
                            
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
LodeRuCaughtHandlerX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosX     Does    : center loderunnner on screen image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosX      .block                           ; 
                            lda HLZ_LodeRuOnImgPosX         ; get loderunner PosX on image
                            cmp #HLZ_LodeRuOnImgPosX_Mid    ; test center
                            bcc IncPosX                     ; check: LT - yes: left of center
                            beq LodeRuCenterImagePosXX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; right of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_LodeRuOnImgPosX         ; GT - dec loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; left of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosX                     inc HLZ_LodeRuOnImgPosX         ; inc loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosXX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosY     Does    : center loderunnner on screen image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosY      .block                           ; 
                            lda HLZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #HLZ_LodeRuOnImgPosY_Mid    ; test center
                            bcc IncPosY                     ; check: LT - yes: above center
                            beq LodeRuCenterImagePosYX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; below center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_LodeRuOnImgPosY         ; GT - dec loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; above center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosY                     inc HLZ_LodeRuOnImgPosY         ; lower - inc loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosYX      rts                             ; equal - nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootFinish         Does    : open a hole in shoot direction - shoot finished successfully
;                           Expects : .X=colum number
;                           Returns : .C=1 - success
;                                   : .C=0 - failed
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootFinish          .block                           ; 
                            lda #HL_LodeRuShoot_No          ; get initial value
                            sta HL_LodeRuShoot              ; ini shoot to off
                            
                            ldy HLZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step to row below loderunner
                            
                            stx HLZ_ScreenCol               ; set screen col ($00-$1b)
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store an empty level tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get empty space
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #HL_TileNum_Empty           ; get emtpy tile
                            jsr ScreenImageOutToPrepare     ; clear tile under loderunner
                            
                            dec HLZ_ScreenRow               ; set screen row above hole
                            lda #HL_TileNum_Empty           ; get empty tile
                            jsr ScreenImageOutToDisplay     ; clear tile above hole
                            inc HLZ_ScreenRow               ; restore screen row to hole
                            
                            ldx #$ff                        ; preset WA offset to -1 to allow next inx
; --------------------------------------------------------------------------------------------------------------------- ;
; search a free slot in open hole time work area
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextHoleOpenTimeOff      inx                             ; inc WA offset
                            cpx #HL_WA_HoleMax              ; test max WA length
                            beq LodeRuOpenShootHoleX        ; check: EQ - yes: max slots reached - exit fault
                            
                            lda HL_WA_HoleOpenTime,x        ; get hole open time tab
                            bne SetNextHoleOpenTimeOff      ; check: already used - yes: continue search
; --------------------------------------------------------------------------------------------------------------------- ;
; a free slot found - occupy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_ScreenRow               ; get screen row ($00-$0f)
                            sta HL_WA_HoleRow,x             ; save in hole row tab
                            
                            lda HLZ_ScreenCol               ; get screen col ($00-$1b)
                            sta HL_WA_HoleCol,x             ; save in hole column tab
                            
                            lda #HL_WA_HoleOpenTime_Ini     ; get initial value
                            sta HL_WA_HoleOpenTime,x        ; ini hole open time tab entry
                            
                            sec                             ; set flag success
                            
LodeRuOpenShootHoleX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveHandler          Does    : control all enemy moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveHandler           .block                           ; 
                            ldx HL_EnemyCount               ; get number of enemies ($00-$05)
                            beq EnemyMoveHandlerX           ; check: is there any enemy to move - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; handle enemy zero page move control tab offset - values were calculated from game speed/enemy count in MainLoopInit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyMoveCycleOff       ; inc offset actual enemy move cycle values
                            
                            ldy HLZ_EnemyMoveCycleOff       ; get offset actual enemy move cycle values
                            cpy #HLZ_EnemyMoveCycleOff_Max  ; test max
                            bcc GetNextMoveCycle            ; check: LT - yes: try a move
                            
                            ldy #HLZ_EnemyMoveCycleOff_Min  ; get initial value
                            sty HLZ_EnemyMoveCycleOff       ; ini offset enemy move cycle values
; --------------------------------------------------------------------------------------------------------------------- ;
; get an enemy move control table value
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextMoveCycle            lda HLZ_EnemyMoveCycle,y        ; get enemy move cycle value
                            sta HLZ_EnemyMoveCycleWork      ; set enemy move cycle work
                            
ShiftNextMoveEnableBit      lsr HLZ_EnemyMoveCycleWork      ; shift out an enemy move control bit
                            bcc GetEnemyMoveCtrlFlags       ; check: was move bit set - no: check if finished
                            
                            jsr EnemyMove                   ; move an enemy if move bit was set
                            
                            lda HL_LodeRuState              ; get loderunner heartbeat
                            beq EnemyMoveHandlerX           ; check: still alive - no: was caught - exit
                            
GetEnemyMoveCtrlFlags       lda HLZ_EnemyMoveCycleWork      ; get enemy move cycle work
                            bne ShiftNextMoveEnableBit      ; check: still move bits available - yes: continue
                            
EnemyMoveHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; offset to table values calculated in MainLoopInit: HL_GameSpeedCtrl + HL_EnemyCount
; actual values store in zero page HLZ_EnemyMoveCycle
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCycles          = *             ; 
TabEnemyMoveCycle_01        = * + $00       ; 
TabEnemyMoveCycle_02        = * + $01       ; 
TabEnemyMoveCycle_03        = * + $02       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_00  = *             ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_01  = *             ; values for default speed and max 5 enemies
                            .byte %00000000 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_02  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_03  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_04  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
TabEnemyMoveCyclesBlock_05  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_06  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_07  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_08  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_09  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0a  = *             ; max game speed
                            .byte %00000111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0b  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0c  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0d  = *             ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0e  = *             ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0f  = *             ; max game speed + max enemy number
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_10  = *             ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_11  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_12  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_13  = *             ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_14  = *             ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteEnemy           = * ; 
TabNumSpriteEnemy_RuLe_00   .byte NumTile_Enemy           ; $08 --> $00 - Run  Le 00 = Level Tile Enemy                 .hbu000.
                            .byte NumSprite_Enemy_RuLe_01 ; $2b --> $01 - Run  Le 01                                    .hbu000.
TabNumSpriteEnemy_RuLe_02   .byte NumSprite_Enemy_RuLe_02 ; $2c --> $02 - Run  Le 02                                    .hbu000.
TabNumSpriteEnemy_PoLe_00   .byte NumSprite_Enemy_PoLe_00 ; $30 --> $03 - Pole Le 00                                    .hbu000.
                            .byte NumSprite_Enemy_PoLe_01 ; $31 --> $04 - Pole Le 01                                    .hbu000.
TabNumSpriteEnemy_PoLe_02   .byte NumSprite_Enemy_PoLe_02 ; $32 --> $05 - Pole Le 02                                    .hbu000.
TabNumSpriteEnemy_Fall_Le   .byte NumSprite_Enemy_Fall_Le ; $36 --> $06 - Fall Le                                       .hbu000.
TabNumSpriteEnemy_RuRi_00   .byte NumSprite_Enemy_RuRi_00 ; $28 --> $07 - Run  Ri 00                                    .hbu000.
                            .byte NumSprite_Enemy_RuRi_01 ; $29 --> $08 - Run  Ri 01                                    .hbu000.
TabNumSpriteEnemy_RuRi_02   .byte NumSprite_Enemy_RuRi_02 ; $2a --> $09 - Run  Ri 02                                    .hbu000.
TabNumSpriteEnemy_PoRi_00   .byte NumSprite_Enemy_PoRi_00 ; $2d --> $0a - Pole Ri 00                                    .hbu000.
                            .byte NumSprite_Enemy_PoRi_01 ; $2e --> $0b - Pole Ri 01                                    .hbu000.
TabNumSpriteEnemy_PoRi_02   .byte NumSprite_Enemy_PoRi_02 ; $2f --> $0c - Pole Ri 02                                    .hbu000.
TabNumSpriteEnemy_Fall_Ri   .byte NumSprite_Enemy_Fall_Ri ; $35 --> $0d - Fall Ri                                       .hbu000.
TabNumSpriteEnemy_Ladr_00   .byte NumSprite_Enemy_Ladr_00 ; $33 --> $0e - Ladder 00                                     .hbu000.
TabNumSpriteEnemy_Ladr_01   .byte NumSprite_Enemy_Ladr_01 ; $34 --> $0f - Ladder 01                                     .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; set min/max values for EnemyMoveSpriteNumRotate
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteEnemy_RuLe_Min  = TabNumSpriteEnemy_RuLe_00 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_RuLe_Max  = TabNumSpriteEnemy_RuLe_02 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_PoLe_Min  = TabNumSpriteEnemy_PoLe_00 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_PoLe_Max  = TabNumSpriteEnemy_PoLe_02 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_RuRi_Min  = TabNumSpriteEnemy_RuRi_00 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_RuRi_Max  = TabNumSpriteEnemy_RuRi_02 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_PoRi_Min  = TabNumSpriteEnemy_PoRi_00 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_PoRi_Max  = TabNumSpriteEnemy_PoRi_02 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_Ladr_Min  = TabNumSpriteEnemy_Ladr_00 - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_Ladr_Max  = TabNumSpriteEnemy_Ladr_01 - TabNumSpriteEnemy ;                                           .hbu000.
                            
TabNumSpriteEnemy_FaLe_Min  = TabNumSpriteEnemy_Fall_Le - TabNumSpriteEnemy ;                                           .hbu000.
TabNumSpriteEnemy_FaRi_Min  = TabNumSpriteEnemy_Fall_Ri - TabNumSpriteEnemy ;                                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMove                 Does    : select and move the next enemy
;                           Expects : 
;                           Returns : 
;                           Remark  : 1st: check if enemy is still locked up in a hole
;                                   :      continue getting him out
;                                   : 2nd: check the tile under enemy
;                                   :      Ladder/Pole                      --> EnemyMoveDispatcher
;                                   : 3rd: check the tile below enemy
;                                   :      Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                                   :      BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMove                  .block                           ; 
                            inc HL_EnemyToMoveNum           ; inc count to next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate the enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_EnemyCount               ; get number of enemies ($00-$05)
                            cpx HL_EnemyToMoveNum           ; test with number of enemy to move
                            bcs RestoreEnemyStatus          ; check: GE - no: max not reached - bypass reset
                            
                            ldx #HL_EnemyToMoveNum_Min      ; get reset to first enemy
                            stx HL_EnemyToMoveNum           ; init enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
; reactivate the selected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyStatus          jsr EnemyMoveStatusRestore      ; restore enemy status from save area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is still captured in a hole or still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyHoleGoldTime       ; get either has gold or locked in a hole time
                            bmi EnemyMovable                ; check: still carries gold - yes
                            beq EnemyMovable                ; check: gold/hole time up - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; positive - enemy is still trapped in a hole - reduce the in hole time
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyHoleGoldTime       ; discount enemy is locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; test in hole time final seconds - eventually shiver/get him out
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            cpy #HLZ_EnemyHoleGoldTime_Shake; test 1st mark - start shaking out of hole
                            bcs ChkEnemyRebirthTime         ; check: GE - yes: bring him back to live
                            
                            jmp EnemyShiverOutOfHole        ; exit - shiver enemy out of hole
; --------------------------------------------------------------------------------------------------------------------- ;
; test enemy rebirth time - eventually continue waiting for rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyRebirthTime         ldx HL_EnemyToMoveNum           ; get number of enemy to move
                            lda HL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq GoEnemyDisplayAndDisable    ; check: did rebirth time ran out - yes: display and disable him
                            
                            jmp EnemyMoveStatusSave         ; store his status to save area again
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyDisplayAndDisable    jmp EnemyDisplayAndDisable      ; display enemy and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy not locked up in a hole
;           actual row: Ladder/Pole                      --> EnemyMoveDispatcher - on a pole enemy must be centerd first
; row below actual row: Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                       BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovable                ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> dispatch next enemy move
; Pole   --> fall down to image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a ladder - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: skip test - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a pole - wait for image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            bne ChkEnemyOnImageCenter       ; check: NE - yes: test image center position for a fall
; --------------------------------------------------------------------------------------------------------------------- ;
; was pole - fall down to image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Mid     ; test center
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy tile position - let him fall further down if not
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyOnImageCenter       lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Mid     ; test center
                            bcc EnemyFallDownHandler        ; check: LT - yes: still above center - let him fall
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is below the image center - check if on last row - end of fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            cpy #HLZ_ScreenRow_Max          ; test enemy on max row already
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: end of fall - dispatch next enemy move
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set game/ctrl data pointers to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data ptr LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data ptr LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data ptr HI
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty      --> let enemy fall down
; LodeRunner --> let enemy fall down
; Enemy      --> dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is empty - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a loderunner - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: dispatch next enemy move
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> dispatch next enemy move
; SolidBrick  --> dispatch next enemy move
; Ladder      --> dispatch next enemy move
; All other   --> let enemy fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a normal brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a solid brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a ladder - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne EnemyFallDownHandler        ; check: EQ - no: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch next enemy move if he stands on a BrickSoft/BrickHard/Ladder/Enemy
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveDispatcher       jmp EnemyMoveDispatcher         ; try to move this enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDownHandler      Does    : control enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDownHandler       .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
                            
                            lda #TabNumSpriteEnemy_FaLe_Min ; preset sprite number fall left                            .hbu000.
                            
                            ldy HLZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            bmi SetEnemySprtNum             ; check: left - yes
                            
                            lda #TabNumSpriteEnemy_FaRi_Min ; get sprite number fall right                              .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; set the view dir dependend sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemySprtNum             sta HLZ_EnemySprtNum            ; set actual enemy sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; step enemy on screen image down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyOnImgPosY          ; step actual enemy on image down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy has left the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Max + $01 ; test max
                            bcs EnemyFallDown               ; check: GE - yes: enemy has left this screen image downwards
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy is in the center of the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Mid     ; test center
                            bne EnemyDisplayAndDisable      ; check: EQ - no: wait - display and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy has fallen into a hole
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> captured in a hole - init timer - score digging in
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a normal brick - yes: captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne EnemyDisplayAndDisable      ; check: EQ - no: display and disable him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy sitting in a hole still has gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl IniEnemyHoleTime            ; check: still carries gold - no
; --------------------------------------------------------------------------------------------------------------------- ;
; timer is negative - enemy still has gold for some reason
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_GoldToCollect            ; some gold has vanished - discount gold to collect
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy in hole time value
; --------------------------------------------------------------------------------------------------------------------- ;
IniEnemyHoleTime            lda HL_EnemyInHoleTime          ; get initial time value taken from TabEnemyInHoleTime
                            sta HLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; a digged in enemy scores 75 points
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>HL_Score_EnemyDigIn       ; score add value HI
                            lda #<HL_Score_EnemyDigIn       ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyDisplayAndDisable    Does    : display and deactivate enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDisplayAndDisable     .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDown             Does    : let an enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDown              .block                           ; 
                            lda #HLZ_EnemyOnImgPosY_Min     ; get intial value 
                            sta HLZ_EnemyOnImgPosY          ; ini actual enemy pos on image up/down
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a normal brick - yes: empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne CopyCtrlTileToGameTile      ; check: NE - yes: skip replacemanet
; --------------------------------------------------------------------------------------------------------------------- ;
; replace ctrl normal brick tile by empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get empty tile substitution
                            
CopyCtrlTileToGameTile      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; let enemy fall down - step enemy row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyRow                ; let enemy fall down a row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> caught - set loderunner death flag
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is loderunner - yes: caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne GetCtrlDataTile             ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; got loderunner - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; loderunner caught - set HL_LodeRuState_Death
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlDataTile             lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> locked up in a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: locked up in a hole - drop gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne InsEnemyTileIntoGameData    ; check: NE - yes: not in hole - deactivate him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; if an enemy is directly on a normal brick in ctrl data - captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl InsEnemyTileIntoGameData    ; check: still locked in hole - yes: deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy has fallen into a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            dey                             ; step one row up
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen col to enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; the tile directly above an enemy must be empty - otherwise his gold cannot be dropped
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> drop the gold he carries
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is empty - yes: drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq EnemyDropsHisGold           ; check: EQ - yes: drop gold to it
; --------------------------------------------------------------------------------------------------------------------- ;
; loose this piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_GoldToCollect            ; a piece of gold was lost
                            jmp ResetLevelDataPointer       ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; drop gold directly above enemy 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDropsHisGold           lda #HL_TileNum_Gold            ; get gold
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #HL_TileNum_Gold            ; get gold
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
ResetLevelDataPointer       ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize enemy in hole timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyHoleGoldTime_None ; get initial value
                            sta HLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; insert enemy tile number to game data - deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
InsEnemyTileIntoGameData    lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyShiverOutOfHole      Does    : shiver the enemy in a hole just before he leaves
;                           Expects : .Y=enemy in hole time (here: $0c-$07 - counted down)
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyShiverOutOfHole       .block                           ; 
                            cpy #HLZ_EnemyHoleGoldTime_Shake_X ; test shake out of hole phase end
                            bcc EnemyMoveDispatcher         ; check: LE - yes: get him out
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; use the remaining HLZ_EnemyHoleGoldTime ($0c-$07) value as offset for TabEnemyShake
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            lda TabEnemyShake - HLZ_EnemyHoleGoldTime_Shake_X,y ; get shiver out of hole value
                            sta HLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyShake               = *       ; let enemy shiver from left to right before leaving a hole
                            .byte $02 ; $05 - $07 - offset exit value - HLZ_EnemyHoleGoldTime_Shake_X
                            .byte $01 ; $04 - $08
                            .byte $02 ; $03 - $09
                            .byte $03 ; $02 - $0a
                            .byte $02 ; $01 - $0b
                            .byte $01 ; $00 - $0c
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDispatcher       Does    : get an enemy move direction proposal and call the approriate move handler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDispatcher        .block                           ; 
                            ldx HLZ_EnemyCol                ; get actual enemy col
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            
                            jsr EnemyMoveGetDirProposal     ; get a possible enemy move direction
                            
                            asl a                           ; move dir *2
                            tay                             ; set as table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; push enemy move dir routine to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemyMoveDir + $01,y     ; get address move routine HI
                            pha                             ; push as return address to stack
                            lda TabEnemyMoveDir + $00,y     ; get address move routine LO 
                            pha                             ; push as return address to stack
                            
                            rts                             ; dispatch enemy move routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveDir             = *                          ; 
                            .word EnemyMoveStatusSave -1 ; $00 - HL_EnemyMoveDir_None - save enemy status to save area
                            
                            .word EnemyMoveLeftHandler  -1 ; $01 - HL_EnemyMoveDir_Le
                            .word EnemyMoveRightHandler -1 ; $02 - HL_EnemyMoveDir_Ri
                            .word EnemyMoveUpHandler    -1 ; $03 - HL_EnemyMoveDir_Up
                            .word EnemyMoveDownHandler  -1 ; $04 - HL_EnemyMoveDir_Do
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpBlocked        Does    : deactivate this enemy - eventually count up enemy locked in a hole time
;                                   : enemy does not move anymore and is fixed in this positions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpBlocked         .block                           ; 
                            lda HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq EnemyMoveUpBlockedX         ; check: in hole time up - yes
                            bmi EnemyMoveUpBlockedX         ; check: still carries gold - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; correct enemy in hole time to HLZ_EnemyHoleGoldTime_Shake_X ($07) again
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyHoleGoldTime       ; count up enemy locked in a hole time
                            
EnemyMoveUpBlockedX         jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpHandler        Does    : try to move enemy up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpHandler         .block                           ; 
                            ldy HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #HLZ_EnemyOnImgPosY_Mid + $01 ; test beyond center
                            bcs MoveUpPrepare               ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved up a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if already on top row
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq EnemyMoveUpBlocked          ; check: check top row - yes: care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; step one row up
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> path up blocked - move up impssible
; BrickHard  --> path up blocked - move up impssible
; BrickTrap  --> path up blocked - move up impssible
; Enemy      --> path up blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a normal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a trap door - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile above enemy is suitable for a move up
; --------------------------------------------------------------------------------------------------------------------- ;
MoveUpPrepare               jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image position up a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            bpl EnemyMoveUpPickGold         ; check: max up: no: eventually pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a normal brick - yes: empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne CopyCtrlTileToGameTile      ; check: EQ - no: bypass substitution
                            
                            lda #HL_TileNum_Empty           ; get empty space substitution
                            
CopyCtrlTileToGameTile      sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; let enemy climb up - step enemy row one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyRow                ; let enemy climb up
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointers to new row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on new row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> caught - set loderunner death flag
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on new row above enemy row is loderunner - yes: caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: NE - yes: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image to max PosY for the new tile entered from below
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyOnImgPosY_Max     ; get max PosY
                            sta HLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            bne EnemyMoveSpriteUpDo         ; always - handle enemy sprite images for move up or down
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpPickGold       Does    : eventually let the enemy pick up gold - enemy move up/down exit point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpPickGold        .block                           ; 
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteUpDo       Does    : handle enemy sprite images for move up or down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteUpDo        .block                           ; 
                            lda #TabNumSpriteEnemy_Ladr_Min ; get sprite num min                                        .hbu000.
                            ldx #TabNumSpriteEnemy_Ladr_Max ; get sprite num max                                        .hbu000.
                            jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDownHandler      Does    : try to move enemy down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownHandler       .block                           ; 
                            ldy HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #HLZ_EnemyOnImgPosY_Mid     ; test beyond center
                            bcc MoveDownPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved down a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on bottom row - yes: disable him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #HLZ_ScreenRow_Max          ; test bottom row
                            bcs EnemyMoveDownDisable        ; check: GE - yes: exit - disable hime
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row below enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; step one row down
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickHard  --> path down blocked - exit - move down impssible
; Enemy      --> path down blocked - exit - move down impssible
; BrickSoft  --> path down blocked - exit - move down impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne MoveDownPrepare             ; check: EQ - no: not blocked - try to move him down
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownDisable        jmp EnemyMoveStatusSave         ; exit - save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile below enemy is suitable for a move down
; --------------------------------------------------------------------------------------------------------------------- ;
MoveDownPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos down a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Max + $01 ; test max down
                            bcc GoEnemyMoveUpPickGold       ; check: LT - yes: eventualy pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #HL_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new row number one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyRow                ; inc actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get data tile on enemy col of new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image to min PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyOnImgPosY_Min     ; get min PosY
                            sta HLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            jmp EnemyMoveSpriteUpDo         ; handle enemy sprite images for move up or down
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveUpPickGold       jmp EnemyMoveUpPickGold         ; eventually pick up gold - handle sprite images
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveLeftHandler      Does    : try to move enemy left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftHandler       .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #HLZ_EnemyOnImgPosX_Mid + $01 ; test beyond center
                            bcs MoveLeftPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            beq EnemyMoveLeftDisable        ; check: already max left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of col left of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path left blocked - move left impssible
; BrickSoft  --> path left blocked - move left impssible
; BrickHard  --> path left blocked - move left impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            bne MoveLeftPrepare             ; check: EQ - no: all free - try to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftDisable        jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile left of enemy is suitable for a move left
; --------------------------------------------------------------------------------------------------------------------- ;
MoveLeftPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #HLZ_EnemyViewDir_Le        ; get view dir left
                            sta HLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos left a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            bpl EnemyMoveLeftWithGold       ; check: max left: no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #HL_TileNum_Empty           ; get empty space substitution
                            
SetGameDataTile             sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyCol                ; dec actual enemy col
                            dey                             ; dec row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
SetEnemyImageNum            lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image max PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyOnImgPosX_Max     ; get 
                            sta HLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            bne GoEnemyMoveLeftPickGold     ; always
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveLeftWithGold       jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveLeftPickGold     ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get run sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabNumSpriteEnemy_RuLe_Min ; get run sprite num min                                    .hbu000.
                            ldx #TabNumSpriteEnemy_RuLe_Max ; get run sprite num max                                    .hbu000.
                            bne EnemyMoveSpriteLeft         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get hang sprite
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumPole            lda #TabNumSpriteEnemy_PoLe_Min ; get pole sprite num min                                   .hbu000.
                            ldx #TabNumSpriteEnemy_PoLe_Max ; get pole sprite num max                                   .hbu000.
                            
EnemyMoveSpriteLeft         jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveRightHandler     Does    : try to move enemy right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightHandler      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #HLZ_EnemyOnImgPosX_Mid     ; test beyond center
                            bcc MoveRightPrepare            ; check: LT - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            cpy #HLZ_ScreenCol_Max          ; test max right
                            beq EnemyMoveRightDisable       ; check: already max right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path right blocked - move right impssible
; BrickSoft  --> path right blocked - move right impssible
; BrickHard  --> path right blocked - move right impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is an enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Enemy           ; test enemy
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            bne MoveRightPrepare            ; check: EQ - no: not blocked - try to move right
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightDisable       jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile right of enemy is suitable for a move right
; --------------------------------------------------------------------------------------------------------------------- ;
MoveRightPrepare            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #HLZ_EnemyMoveDir_Le        ; get move dir left
                            sta HLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos right a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            lda HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #HLZ_EnemyOnImgPosX_Max + $01 ; test max right
                            bcc EnemyMoveRightWithGold      ; check: LT - no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let this enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #HL_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_EnemyCol                ; inc actual enemy col
                            iny                             ; inc row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr HL_LodeRuState              ; set HL_LodeRuState_Death
                            
SetEnemyImageNum            lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image min PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyOnImgPosX_Min     ; get 
                            sta HLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            beq EnemyMoveRightWithoutGold   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveRightWithGold      jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightWithoutGold   ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get run sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabNumSpriteEnemy_RuRi_Min ; get run sprite num min                                    .hbu000.
                            ldx #TabNumSpriteEnemy_RuRi_Max ; get run sprite num max                                    .hbu000.
                            bne EnemyMoveSpriteRight        ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get hang sprite
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumPole            lda #TabNumSpriteEnemy_PoRi_Min ; get pole sprite num min                                   .hbu000.
                            ldx #TabNumSpriteEnemy_PoRi_Max ; get pole sprite num max                                   .hbu000.
                            
EnemyMoveSpriteRight        jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDirProposal   Does    : return an enemy move direction for the move dispatcher
;                           Expects : .X=actual enemy col number (from HLZ_EnemyCol)
;                                   : .Y=actual enemy row number (from HLZ_EnemyRow)
;                           Returns : .A=enemy move direction
;                           Remark  : 1st - test if the enemy is locked up in a hole
;                                           --> Return move dir up
;                                   : 2nd - test if enemy/loderunner rows are same
;                                   :       test on which side of the loderunner this enemy is located
;                                   :       loop until scan col left/right EQ loderunner col
;                                   :         if loderunner col is reached    <-- return move dir left/right
;                                   :         if col is without a Ladder/Pole
;                                   :           check col on row below enemy row
;                                   :           if col is Empty/BrickTrap     <-- exit to enemy/loderunner rows differ
;                                   :             no move le/ri if an Empty/BrickTrap uncovered by a Ladder/Pole is in his way
;                                   : 3rd - enemy/loderunner rows differ
;                                   :       --> EnemyMoveGetMaxColLeRi - game data: col before BrickSoft/BrickSolid    OR   (game data cares for holes)
;                                                                        ctrl data: col pair without (top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder)  OR
;                                                                                   HL_ScreenCols_Min/HL_ScreenCols_Max
;                                   :       --> EnemyMoveScanGoal      - scan row/col pos of enemy for a possible move down or right
;                                   :       --> EnemyMoveScanWingLeft  - scan left  side of enemy for a possible move left
;                                   :       --> EnemyMoveScanWingRight - scan right side of enemy for a possible move up
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDirProposal    .block                           ; 
                            stx HLZ_EnemyMoveColStart       ; set fix actual enemy col - copied from HLZ_EnemyCol
                            sty HLZ_EnemyMoveRowStart       ; set fix actual enemy row - copied from HLZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st: look if the enemy is locked up in a hole
;        game data tile under the enemy is empty
;        ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            bne ChkEnemyAndLodeRuRowSame    ; check: EQ - no: test if this enemy is on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is locked up in a hole - check: enemy carries gold/locked in a hole timer is expired
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq ChkEnemyAndLodeRuRowSame    ; check: still in hole  - no : check if on loderunner row
                            bmi ChkEnemyAndLodeRuRowSame    ; check: still has gold - yes: check if on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; positive: exit with move_up - get this enemy up out of the hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_EnemyMoveDir_Up         ; get move up - step enemy climb out of hole
                            rts                             ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd: look if loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
ChkEnemyAndLodeRuRowSame    ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            cpy HLZ_LodeRuRow               ; test actual row loderunner
                            beq EnemyAndLodeRuRowSame       ; check: EQ - yes: both on same row
                            
                            jmp EnemyAndLodeRuRowDiffer     ; loderunner and enemy are not on the same row
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowSame       ldy HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            sty HLZ_EnemyMoveLodeRuColGap   ; ini col gap between enemy and loderunner
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; test on which side of the loderunner the enemy is located
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
                            cpy HLZ_LodeRuCol               ; test actual col loderunner
                            bcs ScanNextEnemyColLeft        ; check: loderunner left of enemy - no: right
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the left side of loderunner - check if it is possible to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl data tiles right from enemy col towards loderunner col for Ladder/Pole
;   an enemy does not move right if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColRight       inc HLZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan of row below actual row
; Pole   --> continue with next col right - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next ctrl tile right on enemy is a ladder - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile right of enemy is a pole - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile right of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles right below enemy row from enemy col to loderunner col
;   an enemy does not move right if a hole/trap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is Empty - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is BrickTrap - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan right has reached loderunner col - exit with enemy move_right
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColRight    ldy HLZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
                            cpy HLZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColRight       ; check: NE - yes: continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan right towards loderunner col finished - return move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_EnemyMoveDir_Ri         ; get enemy move_right
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the right side of loderunner - check if it is possible to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left from enemy col towards loderunner col for Ladder/Pole
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColLeft        dec HLZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from left
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan of row below actual row
; Pole   --> continue with next col left - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a ladder - skip scan below - check if loderunner column is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a pole - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: bottom reached - move left is possible 
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile left of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left below of enemy from enemy col to loderunner col
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is Empty - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is BrickTrap - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan left has reached loderunner col - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColLeft     ldy HLZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
                            cpy HLZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColLeft        ; check: NE - yes: continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; scan left towards loderunner col finished - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_EnemyMoveDir_Le         ; get enemy move_left
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd: loderunner and enemy are not on same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowDiffer     lda #HLZ_EnemyMoveDir_Ini       ; get initial value
                            sta HLZ_EnemyMoveDir            ; ini actual enemy move direction
                            
                            lda #HLZ_EnemyMoveDistMin_Ini   ; get initial value - guarantees a successful 1st check
                            sta HLZ_EnemyMoveDistMin        ; ini enemy move target max distance
                            
                            ldx HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; Set      : HLZ_EnemyMoveMaxCol_Le = max col left  for 
;          : HLZ_EnemyMoveMaxCol_Ri = max col right for 
;          : 
; which is : col before blocking BrickSoft/BrickSolid  OR
;          : col pair without (top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder)  OR
;          : min screen col/max screen col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveGetMaxColLeRi      ; scan game/ctrl data for enemy max left/right move columns
; --------------------------------------------------------------------------------------------------------------------- ;
; for this enemy the playfield is now split into three parts
;   goal       - scan one enemy col position
;   left  wing - scan cols from enemy max col left  towards enemy col
;   right wing - scan cols from enemy max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveScanGoal           ; scan row/col pos of enemy for a possible move down or right
                            jsr EnemyMoveScanWingLeft       ; scan left  side  of enemy for a possible move left
                            jsr EnemyMoveScanWingRight      ; scan right side  of enemy for a possible move up
                            
                            lda HLZ_EnemyMoveDir            ; return the enemy move direction found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeftX    Does    : exit point of EnemyMoveScanWingLeft
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeftX     .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeft     Does    : scan left side of enemy for a possible move left
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Le EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_left
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_left
;                                   : step EnemyMoveMaxCol_Le towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeft      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col left towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColLeft          ldy HLZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from HLZ_EnemyCol
                            beq EnemyMoveScanWingLeftX      ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            cpy #HLZ_ScreenRow_Max          ; test bottom row
                            beq CheckOnRow_Top              ; check: EQ - yes: skip scan of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move left - continue with top row handling
; BrickHard --> skip evaluation move left - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: skip set move left
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Le        ; get move dir left
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Le       ; check: top row - yes: step scan col to the right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move left - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col left on enemy row is a ladder - yes: evaluate a new move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Le       ; check: EQ - no: skip move evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            ldx HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Le       ; check: GE - yes: advance col position from left towards enemy
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Le        ; get move dir left
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Le       inc HLZ_EnemyMoveMaxCol_Le      ; step scan col to the next column right
                            
                            jmp GetNextScanColLeft          ; continue scan from max col left to actual enemy col
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRightX   Does    : exit point of EnemyMoveScanWingRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRightX    .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRight    Does    : scan right side of enemy for a possible move up
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Ri EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_up
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_up
;                                   : step EnemyMoveMaxCol_Ri towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRight     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColRight         ldy HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from HLZ_EnemyCol
                            beq EnemyMoveScanWingRightX     ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            beq CheckOnRow_Top              ; check: EQ - yes: bottom reached - check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move up - continue with top row handling
; BrickHard --> skip evaluation move up - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: check if on top row
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Up        ; get move dir up
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Ri       ; check: max up reached - yes: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move up - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col right on enemy row is a ladder - yes: evaluate a new move up
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Ri       ; check: EQ - no: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            ldx HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Ri       ; check: GE - yes: reduce scan col to next pos right
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Up        ; get move dir up
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from right towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Ri       dec HLZ_EnemyMoveMaxCol_Ri      ; dec enemy possible max col right
                            jmp GetNextScanColRight         ; continue scan right
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanGoal         Does    : scan enemy col position on enemy row for a possible move down or right
;                           Expects : 
;                           Returns : 
;                           Remark  : scan tile of enemy col on enemy row
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_down
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_right
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoal          .block                           ; 
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #HLZ_ScreenRow_Max          ; test bottom row
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: further down impossible - check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from HLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip scan down - continue with scan up
; BrickHard --> skip scan down - continue with scan up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a solid brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckEnemyOnRow_Top         ; check: GE - yes: check if on top row
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_down for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Do        ; get enemy move down
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - exit routine
; --------------------------------------------------------------------------------------------------------------------- ;
CheckEnemyOnRow_Top         ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            beq EnemyMoveScanGoalX          ; check: top row - yes: skip row test - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne EnemyMoveScanGoalX          ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get max top row for enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            ldy HLZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from HLZ_EnemyRow
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx HLZ_EnemyMoveColStart       ; get fix actual enemy col - copied from HLZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from target col or from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp HLZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs EnemyMoveScanGoalX          ; check: GE - yes: skip set new move dir
                            
                            sta HLZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_right for the new min distance
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyMoveDir_Ri        ; get move dir right
                            sta HLZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoalX          rts                             ; 
                            
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDistance      Does    : get enemy distance from target col or loderunner row
;                           Expects : .A=enemy target row - max is the actual loderunner row
;                                   : .X=enemy target col
;                           Returns : if enemy target row and loderunner row same  : .A=distance enemy col from enemy max col le/ri
;                                   : if enemy target row and loderunner row differ: .A=distance enemy row from loderunner row with up/do marker added
;                           Remark  : called from EnemyMoveScanGoal      with .A=EnemyMoveGetMaxRowBot .X=HLZ_EnemyMoveColStart
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=HLZ_EnemyMoveColStart
;                                   : called from EnemyMoveScanWingLeft  with .A=EnemyMoveGetMaxRowBot .X=HLZ_EnemyMoveMaxCol_Le
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=HLZ_EnemyMoveMaxCol_Le
;                                   : called from EnemyMoveScanWingRight with .A=EnemyMoveGetMaxRowBot .X=HLZ_EnemyMoveMaxCol_Ri
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=HLZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDistance       .block                           ; 
                            sta HLZ_WorkEnemyParmSave       ; save a possible row subtraction value
                            
                            cmp HLZ_LodeRuRow               ; test enemy target row with actual loderunner row
                            bne ChkTargRowBelowLodeRuRow    ; check: EQ - no: check if higher/lower loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max target row is same as loderunner row - choose direction le/ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpx HLZ_EnemyCol                ; test enemy target col with actual enemy col
                            bcc EnemyIsRightOfTargetCol     ; check: taget col LT - yes: 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is left of target col - subtract actual enemy col from target col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get enemy target col
                            sec                             ; 
                            sbc HLZ_EnemyCol                ; sub actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is right of target col - subtract target col from actual enemy col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyIsRightOfTargetCol     stx HLZ_WorkEnemyParmSave       ; save enemy target col for subtraction
                            
                            lda HLZ_EnemyCol                ; get actual enemy col
                            sec                             ; 
                            sbc HLZ_WorkEnemyParmSave       ; sub enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max row and actual loderunner row differ - choose direction up/do
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTargRowBelowLodeRuRow    bcc EnemyTargRowAboveLodeRuRow  ; check: enemy target row LT actual loderunner row - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is below actual loderunner row - subtract loderunner row from target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc HLZ_LodeRuRow               ; sub actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is below actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $02                  ; add move up marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with up value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is above actual loderunner row - subtract target row from loderunner row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyTargRowAboveLodeRuRow  lda HLZ_LodeRuRow               ; get actual row loderunner
                            sec                             ; 
                            sbc HLZ_WorkEnemyParmSave       ; sub enemy target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is above actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $01                  ; add move down marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with down value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTopX    Does    : exit point - return enemy row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTopX     .block                           ; 
                            lda HLZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTop     Does    : return the maximum top row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row up
;                           Remark  : entered if this enemy has reached a ladder on his way up
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=HLZ_EnemyMoveColStart  .Y=HLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=HLZ_EnemyMoveMaxCol_Le .Y=HLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=HLZ_EnemyMoveMaxCol_Ri .Y=HLZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row up at the given enemy col
;                                   :   loop until scan row LT top row
;                                   :     tile of scan row is NOT a Ladder                    --> exit with actual scan row
;                                   :     tile of scan row is     a Ladder
;                                   :       step scan row one up
;                                   : 
;                                   :     tile left of scan col on scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile left of scan col on decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   : 
;                                   :     tile right of scan col on row below decreased scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile right of decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTop      .block                           ; 
                            sty HLZ_EnemyMoveScanRow        ; ini scan row to enemy row
                            stx HLZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextCtrlDataPtr          lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne EnemyMoveGetMaxRowTopX      ; check: EQ - no: exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; step scan row one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_EnemyMoveScanRow        ; step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
                            beq ScanTargetCol_Ri            ; check: already max left - yes: start check right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row - row above actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get new actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on decreased row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left of scan col on decreased row is Pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            bne ScanTargetCol_Ri            ; check: EQ - no: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Le     ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            sty HLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=HLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is GT enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy HLZ_EnemyMoveScanCol        ; get scan col
                            cpy #HLZ_ScreenCol_Max          ; test already max right
                            beq ChkEndOfScanTop             ; check: EQ - yes: end of scan right - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get decreased scan row
                            
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: max scan row LE LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            bne ChkEndOfScanTop             ; check: EQ - no: skip LR exit check - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Ri     ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            sty HLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=HLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner row is below enemy row right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: top row reached - end of scan - exit with .A=HLZ_EnemyMoveScanRow
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfScanTop             ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #HLZ_ScreenRow_Min + $01    ; test top row
                            bcc ReturnMoveTargetRowTop      ; check: LT - yes: exit
                            
                            jmp SetNextCtrlDataPtr          ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowTop      tya                             ; return top row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda HLZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; return point for EnemyMoveGetMaxRowBot if scan below reveals a BrickSoft/BrickHard
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveScanRow           lda HLZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowBot     Does    : return the maximum bottom row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row down
;                           Remark  : entered if this enemy has reached a pole or a ladder on his way down
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=HLZ_EnemyMoveColStart  .Y=HLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=HLZ_EnemyMoveMaxCol_Le .Y=HLZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=HLZ_EnemyMoveMaxCol_Ri .Y=HLZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row down at the given enemy col
;                                   :   loop until scan row GT bottom row
;                                   :     tile of row below scan row is a BrickSoft/BrickHard --> exit with scan row  
;                                   :     tile of scan row is Empty
;                                   :       step scan row one down -       if max row reached --> exit with bottom row
;                                   : 
;                                   :     tile left of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile left of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   : 
;                                   :     tile right of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile right of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowBot      .block                           ; 
                            sty HLZ_EnemyMoveScanRow        ; ini scan row from enemy row
                            stx HLZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
ChkNextTargetCtrlDataRowPos lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> exit with actual scan row
; BrickHard --> exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3Q
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> advance actual scan row - check: bottom row reached - yes: exit with ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq AdvanceEnemyMoveTargetRow   ; check: EQ - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #HLZ_ScreenCol_Min          ; test max col left
                            beq ScanTargetCol_Ri            ; check: EQ - yes: check scan col max right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne ScanTargetCol_Ri            ; check: EQ - no: start scan col right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Le     ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            sty HLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=HLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=HLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; pole check right done with TabCtrlLevelDataRow_Hi and TabCtrlLevelDataRow_Hi + $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: advance scan row - check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy HLZ_EnemyMoveScanCol        ; get scan col
                            cpy #HLZ_ScreenCol_Max          ; test max right
                            bcs AdvanceEnemyMoveTargetRow   ; check: GE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to next tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            bne AdvanceEnemyMoveTargetRow   ; check: NE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Ri     ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            sty HLZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=HLZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy HLZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=HLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is LT loderunner row - step scan row further down
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMoveTargetRow   inc HLZ_EnemyMoveScanRow        ; step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: bottom row reached - end of scan - exit with .A=HLZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #HLZ_ScreenRow_Max + $01    ; test max row passed
                            bcs ReturnMoveTargetRowBottom   ; check: GE - yes: get max row and exit
                            
                            jmp ChkNextTargetCtrlDataRowPos ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowBottom   lda #HLZ_ScreenRow_Max          ; get bottom scan row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda HLZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxColLeRi    Does    : scan game/ctrl data of enemy col on enemy row for the max left/right move col
;                                   : 
;                                   ;   scan game data: return col before BrickSoft/BrickSolid  OR   (game data cares for holes)
;                                   ;   scan ctrl data: return 1st col pair without top Ladder/Pole  AND  without bottom BrickSoft/BrickSolid/Ladder
;                                   ;   none of these : return HL_ScreenCols_Min/HL_ScreenCols_Max
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : HLZ_EnemyMoveMaxCol_Le = max col left
;                                   : HLZ_EnemyMoveMaxCol_Ri = max col right
;                           Remark  : loop until scan col EQ max col left
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - start scan right
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - start scan right
;                                   :   dec HLZ_EnemyMoveMaxCol_Le
;                                   : 
;                                   : loop until scan col EQ max col right
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - exit routine
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - exit routine
;                                   :   inc HLZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxColLeRi     .block                           ; 
                            stx HLZ_EnemyMoveMaxCol_Le      ; ini enemy max col left  to actual col of this enemy
                            stx HLZ_EnemyMoveMaxCol_Ri      ; ini enemy max col right to actual col of this enemy
                            sty HLZ_EnemyMoveMaxRow         ; ini enemy max row       to actual row of this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col left reached - yes: exit scan left - start looking for max col right
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColLeft     lda HLZ_EnemyMoveMaxCol_Le      ; get actual scan max col left
                            beq GetNextEnemyScanColRight    ; check: max screen col left reached - yes: start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to next position left of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan left - start scan right
; BrickHard --> stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a normal brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a solid brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col left of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan row below enemy row
; Pole   --> continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a ladder - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a pole - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to tile one left below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; BrickHard --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; Ladder    --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; All other --> finalize scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a normal brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a solid brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a ladder - yes: continue with next col left - else: exit scan left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Le            ; check: EQ - no: done - adapt scan left max - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; step to next col position left - check: max left reached - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Le       dec HLZ_EnemyMoveMaxCol_Le      ; step actual enemy max col to the left
                            bpl GetNextEnemyScanColLeft     ; always - never gets negative
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan left - set final column left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Le            dec HLZ_EnemyMoveMaxCol_Le      ; set final possible enemy max col left
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col right reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColRight    lda HLZ_EnemyMoveMaxCol_Ri      ; get actual scan max col right
                            cmp #HLZ_ScreenCol_Max          ; test max screen col right reached
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to next position right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan right - exit scan routine
; BrickHard --> stop scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a normal brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - stop col scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a solid brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col right of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan row below enemy row
; Pole   --> continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a ladder - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a pole - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #HLZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy HLZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to tile one right below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; BrickHard --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Ladder    --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Other     --> finalize scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a normal brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: normal - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a solid brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: solid - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a ladder - yes: continue with next col right - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Ri            ; check: EQ - no: mark scan right max - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col position right - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Ri       inc HLZ_EnemyMoveMaxCol_Ri      ; inc actual enemy max col right
                            bpl GetNextEnemyScanColRight    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan right - set final col right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Ri            inc HLZ_EnemyMoveMaxCol_Ri      ; actual enemy possible col right
                            
EnemyMoveGetMaxColLeRiX     rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetScrnGfxPosXY  Does    : get the enemy image gfx screen position
;                           Expects : 
;                           Returns : .A=enemy image number
;                                   : .X=enemy image gfx screen horizontal offset
;                                   : .Y=enemy image gfx screen vertical offset
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetScrnGfxPosXY   .block                           ; 
                            ldx HLZ_EnemyCol                ; get actual enemy col
                            ldy HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; add horizontal gfx screen image offset
                            
                            stx HLZ_WorkImgOffsetPosX       ; save horizontal offset
                            
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            ldx HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            jsr ScreenAddGfxOnImagePosY     ; add vertical gfx screen image offset
                            
                            ldx HLZ_EnemySprtNum            ; get actual enemy sprite number
                            lda TabNumSpriteEnemy,x         ; get image number
                            ldx HLZ_WorkImgOffsetPosX       ; restore horizontal offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMovePickUpGold       Does    : eventually let enemy pick up gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGold        .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is centered completely
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #HLZ_EnemyOnImgPosX_Mid     ; test centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
                            
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Mid     ; test  centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile directly under this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under enemy is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Gold            ; test gold
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: level tile is not gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy has gold timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_EnemyHoleGoldTime       ; get enemy has gold time - counted up to $00
                            bmi EnemyMovePickUpGoldX        ; check: already carries gold - yes: do not pick up another
; --------------------------------------------------------------------------------------------------------------------- ;
; let this enemy get a piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
; randomly init enemy carries gold timer with last rebirth column value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HLZ_EnemyHoleGoldTime_Ini  ; ini enemy has gold time
                            sec                             ; 
                            sbc HL_EnemyBirthCol            ; sub enemy rebirth column - make it even more negative
                            sta HLZ_EnemyHoleGoldTime       ; set enemy has gold time - counted up to $00
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Empty           ; get gold substitution
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #HL_TileNum_Gold            ; get gold
                            jmp ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGoldX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDropGold         Does    : eventually let enemy drop his gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDropGold          .block                           ; 
                            lda HLZ_EnemyHoleGoldTime       ; get enemy carries gold time - counted up to $00
                            bpl EnemyMoveDropGoldX          ; check: carries gold - no: already dropped or none
                            
                            inc HLZ_EnemyHoleGoldTime       ; inc enemy carries gold time - counted up to $00
                            bne EnemyMoveDropGoldX          ; check: hold gold time up - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy tired of carrying around his gold - drop it
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyRow                ; get actual enemy row
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; drop the gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_EnemyCol                ; get actual enemy col
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if designated place is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
                            cmp #HL_TileNum_Empty           ; test empty space
                            bne RestoreEnemyHasGoldTime     ; check: EQ - no: drop impossible - restore timer and exit
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Gold            ; get gold
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
; --------------------------------------------------------------------------------------------------------------------- ;
; display dropped gold                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Gold            ; get gold
                            jmp ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; revert previous inc of enemy carries gold timer - is only discounted if the gold is droppable
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyHasGoldTime     dec HLZ_EnemyHoleGoldTime       ; restore enemy has gold time - counted up to $00
                            
EnemyMoveDropGoldX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteNumRotate  Does    : rotate enemy sprite numbers between minimum and maximum values
;                           Expects : .A=test sprite range number min
;                                   : .X=test sprite range number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteNumRotate   .block                           ; 
                            inc HLZ_EnemySprtNum            ; inc enemy sprite number to next phase
                            
                            cmp HLZ_EnemySprtNum            ; test actual enemy sprite number min
                            bcc ChkSpriteNumberMax          ; check: LT - yes: out of min range
                            
SetSpriteNumber             sta HLZ_EnemySprtNum            ; set min enemy sprite number
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkSpriteNumberMax          cpx HLZ_EnemySprtNum            ; test actual enemy sprite number max
                            bcc SetSpriteNumber             ; check: LT - yes
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosX  Does    : eventually step the enemy towards the center of the image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosX   .block                           ; 
                            lda HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #HLZ_EnemyOnImgPosX_Mid     ; test center
                            bcc StepEnemyRight              ; check: LT - yes: step right to center
                            beq EnemyMoveCenterImagePosXX   ; check: EQ - yes: exit
                            
                            dec HLZ_EnemyOnImgPosX          ; enemy is right of center - step him left
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyRight              inc HLZ_EnemyOnImgPosX          ; enemy is left of center - step him right
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosXX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosY  Does    : eventually step the enemy towards the center of the image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosY   .block                           ; 
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #HLZ_EnemyOnImgPosY_Mid     ; test center
                            bcc StepEnemyDown               ; check: LT - yes: step down to center
                            beq EnemyMoveCenterImagePosYX   ; check: EQ - yes: exit
                            
                            dec HLZ_EnemyOnImgPosY          ; enemy is below the center - step him up
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyDown               inc HLZ_EnemyOnImgPosY          ; enemy is above the center - step him down
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosYX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveStatusSave       Does    : save enemy status to save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusSave        .block
                            ldx HL_EnemyToMoveNum           ; get active enemy number
                            
                            lda HLZ_EnemyCol                ; get actual enemy col
                            sta HL_SA_EnemyCol,x            ; save actual enemy col
                            
                            lda HLZ_EnemyRow                ; get actual enemy row
                            sta HL_SA_EnemyRow,x            ; save actual enemy row
                            
                            lda HLZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            sta HL_SA_EnemyPosOnImgPosX,x   ; save enemy pos on image left/right tab
                            
                            lda HLZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            sta HL_SA_EnemyPosOnImgPosY,x   ; save enemy pos on image up/down tab
                            
                            lda HLZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            sta HL_SA_EnemyHoleGoldTime,x   ; save enemy either has gold or locked in a hole time
                            
                            lda HLZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            sta HL_SA_EnemyViewDir,x        ; save enemy move dir 
                            
                            lda HLZ_EnemySprtNum            ; get actual enemy sprite number
                            sta HL_SA_EnemySprtNum,x        ; save actual enemy sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveStatusRestore    Does    : restore enemy status from save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusRestore     .block                           ; 
                            ldx HL_EnemyToMoveNum           ; get activation enemy number
                            
                            lda HL_SA_EnemyCol,x            ; get enemy save area column
                            sta HLZ_EnemyCol                ; set actual enemy col
                            
                            lda HL_SA_EnemyRow,x            ; get saved adr row enemy
                            sta HLZ_EnemyRow                ; set actual enemy row
                            
                            lda HL_SA_EnemyPosOnImgPosX,x   ; get saved  pos on image left/right tab
                            sta HLZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            lda HL_SA_EnemyPosOnImgPosY,x   ; get saved  pos on image up/down tab
                            sta HLZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            lda HL_SA_EnemySprtNum,x        ; get saved  enemy sprite number
                            sta HLZ_EnemySprtNum            ; set actual enemy sprite number
                            
                            lda HL_SA_EnemyViewDir,x        ; get saved enemy move dir
                            sta HLZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
                            
                            lda HL_SA_EnemyHoleGoldTime,x   ; get enemy either has gold or locked in a hole time
                            sta HLZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameCloseHoles            Does    : close open holes and eventually kill a trapped loderunner/enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHoles             .block                           ; 
                            jsr EnemyRebirth                ; step an enemy back to life
; --------------------------------------------------------------------------------------------------------------------- ;
; advance enemmy birth column
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_EnemyBirthCol            ; inc enemy rebirth column
                            
                            lda HL_EnemyBirthCol            ; get enemy rebirth column
                            cmp #HL_EnemyBirthCol_Max       ; test max column number
                            bcc GetOpenHolesMaxOff          ; check: LT - yes
                            
                            lda #HL_EnemyBirthCol_Min       ; get initial value
                            sta HL_EnemyBirthCol            ; ini enemy rebirth column
; --------------------------------------------------------------------------------------------------------------------- ;
; scan open hole times work area
; --------------------------------------------------------------------------------------------------------------------- ;
GetOpenHolesMaxOff          ldx #HL_WA_HoleMax              ; get max number of open holes
GetNextOpenHoleTime         lda HL_WA_HoleOpenTime,x        ; get next hole open time tab entry
                            
                            stx HLZ_HoleOpenTimeTabOff      ; save open holes time tab offset
                            
                            bne DecCloseHoleOpenTime        ; check: closed already - no: tick time down
                            
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; tick open hole times down
; --------------------------------------------------------------------------------------------------------------------- ;
DecCloseHoleOpenTime        dec HL_WA_HoleOpenTime,x        ; dec open hole time count
                            beq CloseHoleComplete           ; check: open time out - yes: complete close
; --------------------------------------------------------------------------------------------------------------------- ;
; set open hole column and row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_WA_HoleCol,x             ; get hole column tab entry
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda HL_WA_HoleRow,x             ; get hole row tab entry
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 01 finished
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_WA_HoleOpenTime,x        ; get open hole time count
                            cmp #HL_WA_HoleOpenTimeStep_01  ; test 1st step close already passed
                            bne ChkCloseSecondStep          ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #NumImageCloseHole_00       ; get image close hole 1st step                             .hbu000.
                            
CloseHoleNextStep           jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #HL_TileNum_Empty           ; get empty tile
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
GoSetNextOpenHoleTabPtr     jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 02 finished
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCloseSecondStep          cmp #HL_WA_HoleOpenTimeStep_02  ; test 2nd step close already passed
                            bne GoSetNextOpenHoleTabPtr     ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #NumImageCloseHole_01       ; get image close hole 2nd step                             .hbu000.
                            bne CloseHoleNextStep           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole complete - check if occupied by loderunner or an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CloseHoleComplete           ldx HLZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            ldy HL_WA_HoleRow,x             ; get hole row tab entry
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row of open hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_WA_HoleCol,x             ; get hole column tab
                            sty HLZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile on closed hole row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            bne ChkLodeRuInHole             ; check: EQ - no: contains loderunner or an enemy
                            
                            jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuInHole             cmp #HL_TileNum_LodeRunner      ; test loderunner
                            bne ChkEnemyInHole              ; check: EQ - no: test enemy
                            
                            lsr HL_LodeRuState              ; trapped in hole - set HL_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyInHole              cmp #HL_TileNum_Enemy           ; test enemy
                            beq EnemyKill                   ; check: EQ - yes: kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Gold            ; test gold
                            bne GoGameCloseHolesFinish      ; check: EQ - no
                            
                            dec HL_GoldToCollect            ; some gold was lost - dec gold to collect
                            
GoGameCloseHolesFinish      jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; kill an enemy trapped in the closed hole
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyKill                   lda #HL_TileNum_BrickSoft       ; get normal brick
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #HL_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx HL_EnemyCount               ; get number of enemies ($00-$05)
GetNextEnemyCol             lda HL_SA_EnemyCol,x            ; get enemy save area column
                            cmp HLZ_ScreenCol               ; test screen col ($00-$1b)
                            beq GetNextEnemyRow             ; check: enemy hole column found - yes
                            
                            jmp SetNextEnemyNum             ; set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyRow             lda HL_SA_EnemyRow,x            ; get enemy save area row
                            cmp HLZ_ScreenRow               ; test screen row ($00-$0f)
                            bne SetNextEnemyNum             ; check: enemy hole row found - no: set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy hole column and row found - disable enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemySpriteDisable,x     ; get disable enemy sprite tab
                            and SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_SA_EnemyHoleGoldTime,x   ; get enemy either has gold or locked in a hole time
                            bpl EnemyHasGoldReset           ; check: enemy had gold: no
                            
                            dec HL_GoldToCollect            ; some gold was lost - dec gold to collect
                            
EnemyHasGoldReset           lda #HL_SA_EnemyHoleGoldTime_Ini; get intitial value
                            sta HL_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            stx HL_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            ldx HL_EnemyToMoveNum           ; get number of enemy to move
; --------------------------------------------------------------------------------------------------------------------- ;
; find a place for enemy rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HLZ_ScreenRow_Min + $01    ; get start with 2nd row
                            sty HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to next rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
; probably an error in the original - the ctrl data does contain empty data instead of enemy data thus causing stacked enemies
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRebirthRow           ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO                    .hbu025.
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level ctrl data pointer LO                            .hbu025.
;                           sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO                            .hbu025. removed
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3   .hbu025.
;                           lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3   .hbu025. removed
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level ctrl data pointer HI                            .hbu025.
;                           sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI                            .hbu025. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; get the next level game tile on the rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HL_EnemyBirthCol            ; get enemy rebirth column
;GetNextLevelCtrlTile       lda (HLZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)                    .hbu025. removed
GetNextLevelCtrlTile        lda (HLZ_LevelDataGamePtrRow),y ; get play level ctrl data ($0a00-$0bc3)                    .hbu025.
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_Empty           ; test empty space
                            beq EnemyRevivePosSave          ; check: EQ - yes: found a place - revive this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; advance to next col
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HL_EnemyBirthCol            ; inc enemy rebirth column
                            
                            ldy HL_EnemyBirthCol            ; get enemy rebirth column
                            cpy #HL_EnemyBirthCol_Max       ; test max column number
                            bcc GetNextLevelCtrlTile        ; check: LT - yes: get next level ctrl tile
; --------------------------------------------------------------------------------------------------------------------- ;
; all columns for this row are checked unsuccessfully - restart with the next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #HL_EnemyBirthCol_Min       ; get start column number
                            sta HL_EnemyBirthCol            ; ini enemy rebirth column
                            
                            beq GetNextRebirthRow           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; save revive position
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRevivePosSave          tya                             ; get rebirth column number
                            sta HL_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda HLZ_ScreenRow               ; get rebirth screen row ($00-$0f)
                            sta HL_SA_EnemyRow,x            ; set enemy save area row
; --------------------------------------------------------------------------------------------------------------------- ;
; init and score enemy resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_WA_EnemyBirthStep_Ini   ; get rebirth start value
                            sta HL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            lda #HL_PosOnImage_Center       ; get centered position
                            sta HL_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
                            sta HL_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            
                            lda #TabNumSpriteEnemy_RuLe_Min ; get initial value
                            sta HL_SA_EnemySprtNum,x        ; set actual enemy sprite number
                            
                            ldy #>HL_Score_EnemyRebirth     ; score add value LO - a reborn enemy scores 75 points
                            lda #<HL_Score_EnemyRebirth     ; score add value HI
                            jsr StatusOutScore              ; score and update status row
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; count down enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyNum             dex                             ; number of enemies
                            beq GameCloseHolesFinish        ; check: all processed - yes: finish close hole
                            
                            jmp GetNextEnemyCol             ; continue resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesFinish        lda #HL_TileNum_BrickSoft       ; get normal brick
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #HL_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; check if all open holes are processed
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextOpenHoleTabPtr       ldx HLZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            dex                             ; dec open holes time tab offset
                            bmi GameCloseHolesX             ; check: all open holes processed - yes: exit
                            
                            jmp GetNextOpenHoleTime         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyRebirth              Does    : step an enemy back to life
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRebirth               .block                           ; 
                            ldx HL_EnemyCount               ; get number of enemies ($00-$05)
                            beq GameCloseHoles.GameCloseHolesX ; check: none - yes: exit
                            
                            lda HL_EnemyToMoveNum           ; get number of enemy to move
                            pha                             ; save number of enemy to move
                            
GetNextEnemyRebirthTime     lda HL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq DecNumberOfEnemyToMove      ; check: rebirth time up - yes
                            
                            stx HL_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            
                            lda #HL_SA_EnemyHoleGoldTime_Ini; get initial value
                            sta HL_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            lda HL_SA_EnemyCol,x            ; get enemy save area column
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda HL_SA_EnemyRow,x            ; get enemy save area row
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy rebirth time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_WA_EnemyBirthTime,x      ; enemy rebirth step time                                   .hbu008.
                            cmp #HL_WA_EnemyBirthStep_Ini   ; start value                                               .hbu008.
                            bne DecRebirthTime              ; color only once                                           .hbu008.
                            
                            jsr EnemyMoveRebirthColor       ; set rebirth background color to enemy color               .hbu008.
                            
DecRebirthTime              dec HL_WA_EnemyBirthTime,x      ; dec enemy rebirth step time                               .hbu008.
                            beq EnemyResurrection           ; check: min - yes: reactivate resurrected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy rebirth step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            tax                             ; set as offset                                             .hbu024.
                            lda TabEnemyRevive,x            ; get rebirth step image                                    .hbu024.
                            
                            pha                             ; save rebirth step image                                   .hbu024.
;                           cmp #HL_WA_EnemyBirthStep_01    ; test first step rebirth                                          .hbu024. removed
;                           bne ChkRebirthStepTwo           ; check: already passed - no                                       .hbu024. removed
;                                                                                                                              .hbu024. removed
;                           lda #NumImageReviveEnemy_O0     ; get first step rebirth                                    .hbu000.hbu024. removed
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen                              .hbu024.
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position                          .hbu024.
                            
;                           lda #NumImageReviveEnemy_O0     ; get first step rebirth                                    .hbu000.hbu024. removed
;                           jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps           .hbu024. removed
;                           jmp GetNumberOfEnemyToMove      ; try next enemy                                                   .hbu024. removed
; --------------------------------------------------------------------------------------------------------------------- ;      .hbu024. removed
; enemy rebirth step 02                                                                                                        .hbu024. removed
; --------------------------------------------------------------------------------------------------------------------- ;      .hbu024. removed
;ChkRebirthStepTwo          cmp #HL_WA_EnemyBirthStep_02    ; test time second step rebirth                                    .hbu024. removed
;                           bne DecNumberOfEnemyToMove      ; check: already passed - no                                       .hbu024. removed
;                                                                                                                              .hbu024. removed
;                           lda #NumImageReviveEnemy_O1     ; get second step rebirth                                   .hbu000.hbu024. removed
;                           jsr ScreenImageOutToPrepare     ; direct output to preparation screen                              .hbu024. removed
;                           jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position                          .hbu024. removed
;                                                                                                                              .hbu024. removed
;                           lda #NumImageReviveEnemy_O1     ; get second step rebirth                                   .hbu000.hbu024. removed
                            pla                             ; restore rebirth step image                                       .hbu024.
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
GetNumberOfEnemyToMove      ldx HL_EnemyToMoveNum           ; get number of enemy to move
                            
DecNumberOfEnemyToMove      dex                             ; count down enemy number
                            bne GetNextEnemyRebirthTime     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore number of enemy to move
                            sta HL_EnemyToMoveNum           ; set number of enemy to move
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyResurrection         Does    : reactivate a reborn enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyResurrection          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get resurrection position from EnemyRevivePosSave - set game data row pointer to screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row          .hbu026.
;                           lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO                    .hbu026. removed
;                           sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO                            .hbu026. removed
                            
;                           lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3      .hbu026. removed
;                           sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI                            .hbu026. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; increase enemy rebirth time directly in work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_EnemyToMoveNum           ; get number of enemy to move
                            inc HL_WA_EnemyBirthTime,x      ; enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; get level game tile on rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (HLZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if this tile in level game data is still empty - but may be occupied now by a formerly hidden ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq IniRebirth                  ; check: empty - yes: put this enemy to life again          .hbu026.
                            
                            cmp #HL_TileNum_Ladder          ; test for an appeared hidden ladder                        .hbu026.
                            beq IniRebirth                  ; check: EQ - yes: exchange ladder by the newborn enemy     .hbu026.
                            bne EnemyRebirth.DecNumberOfEnemyToMove ; otherwise discard this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; a free rebirth place was found - clear game level data and insert the reborn enemy
; --------------------------------------------------------------------------------------------------------------------- ;
IniRebirth                  lda #HL_TileNum_Empty           ; get empty space                                           .hbu026.
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked game level data ($0800-$09c3)                .hbu026.
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set unpacked ctrl level data ($0800-$09c3)                .hbu026.
                            
                            lda #HL_TileNum_Enemy           ; get enemy
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear enemy image on both hires screens
; --------------------------------------------------------------------------------------------------------------------- ;
ClrRebirthPosition          lda #HL_TileNum_Empty           ; get empty space                                           .hbu000.hbu026.
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #HL_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; init reborn enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value 
                            ldx HL_EnemyToMoveNum           ; get number of enemy to move
                            sta HL_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta HL_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; display reborn enemy tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_TileNum_Enemy           ; get enemy
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; enable reborn enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HL_EnemyToMoveNum           ; get number of enemy to move
                            lda TabEnemySpriteEnable,x      ; get enable enemy sprite tab
                            ora SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            jmp EnemyRebirth.DecNumberOfEnemyToMove ; go set next enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteEnable        = *       ; 
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $10 ; ...#....
                            .byte $40 ; .#......
                            .byte $80 ; #.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteDisable       = *       ; 
                            .byte $00 ; ........
                            .byte $fb ; #####.##
                            .byte $f7 ; ####.###
                            .byte $ef ; ###.####
                            .byte $bf ; #.######
                            .byte $7f ; .#######
; --------------------------------------------------------------------------------------------------------------------- ;
; HL_WA_EnemyBirthTime counter ticks down from HL_WA_EnemyBirthStep_Ini to $00
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyRevive               = *                        ;                                                               .hbu024.
                            .byte NumImageReviveEnemy0b ; $00                                                           .hbu024.
                            
                            .byte NumImageReviveEnemy0b ; $01                                                           .hbu024.
                            .byte NumImageReviveEnemy0a ; $02                                                           .hbu024.
                            .byte NumImageReviveEnemy0a ; $03                                                           .hbu024.
                            .byte NumImageReviveEnemy09 ; $04                                                           .hbu024.
                            .byte NumImageReviveEnemy09 ; $05                                                           .hbu024.
                            .byte NumImageReviveEnemy08 ; $06                                                           .hbu024.
                            .byte NumImageReviveEnemy08 ; $07                                                           .hbu024.
                            .byte NumImageReviveEnemy07 ; $08                                                           .hbu024.
                            .byte NumImageReviveEnemy07 ; $09                                                           .hbu024.
                            .byte NumImageReviveEnemy06 ; $0a                                                           .hbu024.
                            .byte NumImageReviveEnemy06 ; $0b                                                           .hbu024.
                            .byte NumImageReviveEnemy05 ; $0c                                                           .hbu024.
                            .byte NumImageReviveEnemy05 ; $0d                                                           .hbu024.
                            .byte NumImageReviveEnemy04 ; $0e                                                           .hbu024.
                            .byte NumImageReviveEnemy04 ; $0f                                                           .hbu024.
                            .byte NumImageReviveEnemy03 ; $10                                                           .hbu024.
                            .byte NumImageReviveEnemy03 ; $11                                                           .hbu024.
                            .byte NumImageReviveEnemy02 ; $12                                                           .hbu024.
                            .byte NumImageReviveEnemy02 ; $13                                                           .hbu024.
                            .byte NumImageReviveEnemy01 ; $14                                                           .hbu024.
                            .byte NumImageReviveEnemy01 ; $15                                                           .hbu024.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveRebirthColor     Does    : set screen background color to enemy color on rebirth position
;                           Expects : enemy col/row in HLZ_ScreenCol/HLZ_ScreenRow
;                           Returns : 
; ` ------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRebirthColor      .block                           ;                                                           .hbu008.
                            txa                             ;                                                           .hbu008.
                            pha                             ; save enemy number in .X                                   .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; get enmemy rebirth color row count
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f) - enemy rebirth row              .hbu008.
                            lda TabBirthColorRowCount,y     ; get number of rows to be colored                          .hbu008.
                            sta HLZ_BirthColorRowCount      ; set number of rows to be colored                          .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to multi color screen output address
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabBirthColorRowNum,y       ; get color row number for actual row                       .hbu008.
                            sta HL_EnemyBirthColorRowNum    ; set color row number for actual row                       .hbu008.
                            tay                             ; set as table offset                                       .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to multi color screen output address
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextRebirthColorPtr      lda TabBirthColorScrnRowAdr_Lo,y;                                                           .hbu008.
                            sta HLZ_BirthColorRowPtr_Lo     ;                                                           .hbu008.
                            lda TabBirthColorScrnRowAdr_Hi,y;                                                           .hbu008.
                            sta HLZ_BirthColorRowPtr_Hi     ;                                                           .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; point to multi color screen output address
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_ScreenCol               ; get screen col  ($00-$1b) - enemy rebirth col             .hbu008.
                            lda TabBirthColorScrnColOff,y   ; get color offset for the actual column                    .hbu008.
                            clc                             ;                                                           .hbu008.
                            adc HLZ_BirthColorRowPtr_Lo     ; add the row pointer                                       .hbu008.
                            sta HLZ_BirthColorRowPtr_Lo     ;                                                           .hbu008.
                            bcc InitRebirthColor            ; check: overflow - no                                      .hbu008.
                            inc HLZ_BirthColorRowPtr_Hi     ;                                                           .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the rebirth screen position
; --------------------------------------------------------------------------------------------------------------------- ;
InitRebirthColor            ldy #$01                        ; get color position count                                  .hbu008.
ClrNextBirthColorRowByte    lda (HLZ_BirthColorRowPtr),y    ; get  old color byte                                       .hbu008.
                            and #$0f                        ; del old background color                                  .hbu008.
                            sta (HLZ_BirthColorRowPtr),y    ; set new background color                                  .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; get this enemies color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_EnemyToMoveNum           ; get actual enemy number                                   .hbu008.
                            tax                             ; set as offset                                             .hbu008.
                            lda TabSpriteNumber,x           ; get enemy sprite number                                   .hbu008.
                            clc                             ;                                                           .hbu008.
                            adc HL_EnemyColorTabRowNum      ; add actual color table row address from GameColorEnemySprites .hbu008.
                            tax                             ; set as offset                                             .hbu008.
                            lda TabSpriteColorSets,x        ; get this enemies color                                    .hbu008.
                            asl a                           ; shift to left nibble - prepare insertion                  .hbu008.
                            asl a                           ;                                                           .hbu008.
                            asl a                           ;                                                           .hbu008.
                            asl a                           ;                                                           .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; insert the color into the rebirth screen position
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora (HLZ_BirthColorRowPtr),y    ; insert hires screen color to enemy color                  .hbu008.
                            sta (HLZ_BirthColorRowPtr),y    ; set new hires screen color byte                           .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; discout color positions
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; dec color count                                           .hbu008.
                            bpl ClrNextBirthColorRowByte    ; check: min - no: handle 2nd position                      .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; set 2nd row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_EnemyBirthColorRowNum    ; color the 2nd row above the 1st one                       .hbu008.
                            ldy HL_EnemyBirthColorRowNum    ;                                                           .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; discount color row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HLZ_BirthColorRowCount      ; dec color amount                                          .hbu008.
                            bpl SetNextRebirthColorPtr      ; check: min - no: continue                                 .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ;                                                           .hbu008.
                            tax                             ; restore enemy number to .X                                .hbu008.
                            
                            rts                             ;                                                           .hbu008.
                           .bend                            ;                                                           .hbu008.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy color row number substitutions for the actual enemy HLZ_ScreenRow
; --------------------------------------------------------------------------------------------------------------------- ;
TabBirthColorRowNum         = *       ; 
                            .byte $01 ; $00 $028 2 - never used - scan starts with row $01                              .hbu008.
                            .byte $02 ; $01 $050 2                                                                      .hbu008.
                            
                            .byte $04 ; $02 $0a0 3                                                                      .hbu008.
                            .byte $05 ; $03 $0c8 2                                                                      .hbu008.
                            .byte $06 ; $04 $0f0 2                                                                      .hbu008.
                            
                            .byte $08 ; $05 $140 3                                                                      .hbu008.
                            .byte $09 ; $06 $168 2                                                                      .hbu008.
                            .byte $0a ; $07 $190 2                                                                      .hbu008.
                            
                            .byte $0c ; $08 $1e0 3                                                                      .hbu008.
                            .byte $0d ; $09 $208 2                                                                      .hbu008.
                            
                            .byte $0f ; $0a $258 3                                                                      .hbu008.
                            .byte $10 ; $0b $280 2                                                                      .hbu008.
                            .byte $11 ; $0c $2a8 2                                                                      .hbu008.
                            
                            .byte $13 ; $0d $2f8 3                                                                      .hbu008.
                            .byte $14 ; $0e $320 2                                                                      .hbu008.
                            .byte $15 ; $0f $348 2 - never used - at least one free place in row $14                    .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; number of subsequent rows to be colored for the actual enemy HLZ_ScreenRow
; --------------------------------------------------------------------------------------------------------------------- ;
TabBirthColorRowCount       = *       ;                                                                                 .hbu008.
                            .byte $02 ; $00                                                                             .hbu008.
                            .byte $02 ; $01                                                                             .hbu008.
                            .byte $03 ; $02                                                                             .hbu008.
                            
                            .byte $02 ; $03                                                                             .hbu008.
                            .byte $02 ; $04                                                                             .hbu008.
                            .byte $03 ; $05                                                                             .hbu008.
                            
                            .byte $02 ; $06                                                                             .hbu008.
                            .byte $02 ; $07                                                                             .hbu008.
                            .byte $03 ; $08                                                                             .hbu008.
                            
                            .byte $02 ; $09                                                                             .hbu008.
                            .byte $03 ; $0a                                                                             .hbu008.
                            
                            .byte $02 ; $0b                                                                             .hbu008.
                            .byte $02 ; $0c                                                                             .hbu008.
                            .byte $03 ; $0d                                                                             .hbu008.
                            
                            .byte $02 ; $0e                                                                             .hbu008.
                            .byte $02 ; $0f                                                                             .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; multi color screen row addresses high
; --------------------------------------------------------------------------------------------------------------------- ;
TabBirthColorScrnRowAdr_Lo  = *       ; 
                            .byte $00 ; $00                                                                             .hbu008.
                            .byte $28 ; $01                                                                             .hbu008.
                            .byte $50 ; $02                                                                             .hbu008.
                            .byte $78 ; $03                                                                             .hbu008.
                            .byte $a0 ; $04                                                                             .hbu008.
                            .byte $c8 ; $05                                                                             .hbu008.
                            .byte $f0 ; $06                                                                             .hbu008.
                            
                            .byte $18 ; $07                                                                             .hbu008.
                            .byte $40 ; $08                                                                             .hbu008.
                            .byte $68 ; $09                                                                             .hbu008.
                            .byte $90 ; $0a                                                                             .hbu008.
                            .byte $b8 ; $0b                                                                             .hbu008.
                            .byte $e0 ; $0c                                                                             .hbu008.
                            
                            .byte $08 ; $0d                                                                             .hbu008.
                            .byte $30 ; $0e                                                                             .hbu008.
                            .byte $58 ; $0f                                                                             .hbu008.
                            .byte $80 ; $10                                                                             .hbu008.
                            .byte $a8 ; $11                                                                             .hbu008.
                            .byte $d0 ; $12                                                                             .hbu008.
                            .byte $f8 ; $13                                                                             .hbu008.
                            
                            .byte $20 ; $14                                                                             .hbu008.
                            .byte $48 ; $15                                                                             .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; multi color screen row addresses high
; --------------------------------------------------------------------------------------------------------------------- ;
TabBirthColorScrnRowAdr_Hi  = *                           ; 
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $00 ;                                                             .hbu008.
                            
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $01 ;                                                             .hbu008.
                            
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $02 ;                                                             .hbu008.
                            
                            .byte (>HL_MemScreenMC) + $03 ;                                                             .hbu008.
                            .byte (>HL_MemScreenMC) + $03 ;                                                             .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
; multi color screen row column offsets (24 positions - the first and the last 2 bytes of a row are unused)
; --------------------------------------------------------------------------------------------------------------------- ;
TabBirthColorScrnColOff     = *       ; 
                            .byte $02 ; $00                                                                             .hbu008.
                            .byte $03 ; $01                                                                             .hbu008.
                            
                            .byte $05 ; $02                                                                             .hbu008.
                            .byte $06 ; $03                                                                             .hbu008.
                            .byte $07 ; $04                                                                             .hbu008.
                            .byte $08 ; $05                                                                             .hbu008.
                            
                            .byte $0a ; $06                                                                             .hbu008.
                            .byte $0b ; $07                                                                             .hbu008.
                            .byte $0c ; $08                                                                             .hbu008.
                            .byte $0d ; $09                                                                             .hbu008.
                            
                            .byte $0f ; $0a                                                                             .hbu008.
                            .byte $10 ; $0b                                                                             .hbu008.
                            .byte $11 ; $0c                                                                             .hbu008.
                            .byte $12 ; $0d                                                                             .hbu008.
                            
                            .byte $14 ; $0e                                                                             .hbu008.
                            .byte $15 ; $0f                                                                             .hbu008.
                            .byte $16 ; $10                                                                             .hbu008.
                            .byte $17 ; $11                                                                             .hbu008.
                            
                            .byte $19 ; $12                                                                             .hbu008.
                            .byte $1a ; $13                                                                             .hbu008.
                            .byte $1b ; $14                                                                             .hbu008.
                            .byte $1c ; $15                                                                             .hbu008.
                            
                            .byte $1e ; $16                                                                             .hbu008.
                            .byte $1f ; $17                                                                             .hbu008.
                            .byte $20 ; $18                                                                             .hbu008.
                            .byte $21 ; $19                                                                             .hbu008.
                            
                            .byte $23 ; $1a                                                                             .hbu008.
                            .byte $24 ; $1b                                                                             .hbu008.
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenClearBoth           Does    : clear the display and prepare screen hires screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenClearBoth            .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            jsr ScreenPrepareClear          ; clear prepare grafic screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusAreaSetup           Does    : display the status row with separator and text
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusAreaSetup            .block                           ; 
                            ldx #$22                        ; get length of status row separator line
                            
                            lda HLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cmp #>HL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq SeparatorOutToPrepScreen    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separator line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0a                        ; get grafic byte for separator line left end
                            sta HL_StatusRowSepDisp_Le_00   ; set left end 0
                            sta HL_StatusRowSepDisp_Le_01   ; set left end 1
                            sta HL_StatusRowSepDisp_Le_02   ; set left end 2
                            sta HL_StatusRowSepDisp_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta HL_StatusRowSepDisp_Ri_00   ; set right end 0
                            sta HL_StatusRowSepDisp_Ri_01   ; set right end 1
                            sta HL_StatusRowSepDisp_Ri_02   ; set right end 2
                            sta HL_StatusRowSepDisp_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusDispMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepDispMid_Lo    = * + $01                       ; 
smAdrStatusSepDispMid_Hi    = * + $02                       ; 
SetNextStatusDispMidPart    sta HL_StatusRowSepDisp_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusDispMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance display screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepDispMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepDispMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusDispMidCount       ; check: overflow - no
                            inc smAdrStatusSepDispMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusDispMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusDispMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>HL_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Hi    ; set start address HI
                            lda #<HL_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Lo    ; set start address LO
                            bne StatusLineTextOut           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output prepare screen status row separater line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
SeparatorOutToPrepScreen    lda #$0a                        ; get grafic byte for separator line left end
                            sta HL_StatusRowSepPrep_Le_00   ; set left end 0
                            sta HL_StatusRowSepPrep_Le_01   ; set left end 1
                            sta HL_StatusRowSepPrep_Le_02   ; set left end 2
                            sta HL_StatusRowSepPrep_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta HL_StatusRowSepPrep_Ri_00   ; set right end 0
                            sta HL_StatusRowSepPrep_Ri_01   ; set right end 1
                            sta HL_StatusRowSepPrep_Ri_02   ; set right end 2
                            sta HL_StatusRowSepPrep_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusPrepMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepPrepMid_Lo    = * + $01                       ; 
smAdrStatusSepPrepMid_Hi    = * + $02                       ; 
SetNextStatusPrepMidPart    sta HL_StatusRowSepPrep_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusPrepMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance preparation screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepPrepMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepPrepMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusPrepMidCount       ; check: overflow - no
                            inc smAdrStatusSepPrepMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusPrepMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusPrepMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>HL_StatusRowSepPrep_Mi_00 ; restore old value HI
                            sta smAdrStatusSepPrepMid_Hi    ; 
                            
                            lda #<HL_StatusRowSepPrep_Mi_00 ; restore old value LO
                            sta smAdrStatusSepPrepMid_Lo    ;  
; --------------------------------------------------------------------------------------------------------------------- ;
; write out the status row text
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor
; --------------------------------------------------------------------------------------------------------------------- ;
StatusLineTextOut           jsr LED_CursorPosStatus         ;                                                           .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; check level test mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            bmi BaseLineEdit                ; check: HL_LevelTest_On - yes: bypass mode test            .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
; check level edit mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu009.
                            cmp #HL_GameMode_Edit           ; test edit mode                                            .hbu009.
                            bne BaseLineGame                ; check: EQ - no: out game base line                        .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
; output edit/test base line
; --------------------------------------------------------------------------------------------------------------------- ;
BaseLineEdit                jsr TextOutHandler              ; control the output of a $00 terminated text string        .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "l" | $80 ;               ; LEVEL    MSG                                              .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "v" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "l" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "m" | $80 ;               ;                                                           .hbu009.
                            .byte "s" | $80 ;               ;                                                           .hbu009.
                            .byte "g" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            
                            .byte $00 ; EndOfText                                                                       .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelNumGame             ; get game level number (001-250)
                            ldx #HL_StatusRow_Col_Score     ; in edit/test mode at score position in base row
                            jmp StatusOutLevelVar           ; output game level number to variable col of status row
; --------------------------------------------------------------------------------------------------------------------- ;
BaseLineGame                jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "s" | $80 ;               ; SCORE                                                     .hbu009.
                            .byte "c" | $80 ;               ;                                                           .hbu009.
                            .byte "o" | $80 ;               ;                                                           .hbu009.
                            .byte "r" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            
                            .byte $00 ; EndOfText                                                                       .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutMenLevel         Does    : Output a separation and a status line
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutMenLevel          .block                           ; 
                            jsr TextOutHandler              ; control the output of a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "m" | $80 ;               ; MEN    LEVEL                                              .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "n" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte "l" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "v" | $80 ;               ;                                                           .hbu009.
                            .byte "e" | $80 ;               ;                                                           .hbu009.
                            .byte "l" | $80 ;               ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            .byte " " | $80 ; <SHIFT_SPACE> ;                                                           .hbu009.
                            
                            .byte $00 ; EndOfText                                                                       .hbu009.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_BLACK_BLACK             ; get clear color                                           .hbu009.
                            
                            cmp HL_ScreenMC_MsgColor        ; test with status line msg part color                      .hbu009.
                            bne FillBaseLine                ; check: EQ - no: bypass recolor                            .hbu009.
                            
                            lda HL_ColorStatus              ; get old status line color                                 .hbu009.
                            jsr StatusMsgTextColor          ; recolor after clear message                               .hbu009.
                            
FillBaseLine                jsr StatusOutLives              ; out number of lives                                       .hbu009.
                            jsr StatusOutLevel              ; out level number                                          .hbu009.
                            
                            lda #$00                        ; get no score to add
                            tay                             ; 
                            jmp StatusOutScore              ; display score and return
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutValues           Does    : output actual level/lives/score to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutValues            .block                           ; 
                            jsr StatusOutLives              ; write out actual lives and level numbers
                            jsr StatusOutLevel              ; write out level number
; --------------------------------------------------------------------------------------------------------------------- ;
; add zero to score and output the score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; score add value LO - no score to add
                            tay                             ; score add value HI
                            jmp StatusOutScore              ; output actual score
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLives            Does    : write out number of lives to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLives             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            beq OutLivesNum                 ; check: HL_LevelTest_Off - yes: normal output of lives     .hbu019.
                                                                                                                        
                            rts                             ; no lives output in level test mode                        .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
OutLivesNum                 lda HL_NumLives                 ; get value to be converted
                            ldx #HLZ_ScreenCol_Status_Lives ; get screen output col
; --------------------------------------------------------------------------------------------------------------------- ;
; entered from StatusOutLevel      
; --------------------------------------------------------------------------------------------------------------------- ;
StatusRowOut                stx HLZ_ScreenCol               ; set screen output col (00-1b)
                            
                            jsr ConvertHexToDec             ; result in HL_Digit_100/HL_Digit_10/HL_Digit_1
                            
                            lda #HLZ_ScreenRow_Status_Sep   ; get status separator row number
                            sta HLZ_ScreenRow               ; set screen row (00-0f)
                            
                            lda HL_Digit_100                ; get digit 100 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutDigitBCD         Does    : output a BCD encoded digit to the status row
;                           Expects : .A=BCD digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutDigitBCD          .block                           ;                                                           .hbu028.
                            pha                             ; save BCD                                                  .hbu028.
                            
                            lsr                             ; isoate left nibble                                        .hbu028.
                            lsr                             ;                                                           .hbu028.
                            lsr                             ;                                                           .hbu028.
                            lsr                             ;                                                           .hbu028.
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu028.
                            
                            pla                             ; restore BCD                                               .hbu028.
                            and #$0f                        ; isolate right nibble                                      .hbu028.
                            jmp StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu028.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutDigitBin         Does    : output a binary digit to the status row
;                           Expects : .A=binary digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutDigitBin          .block                           ; 
                            jsr ConvertHexToDec             ; result in HL_Digit_100/HL_Digit_10/HL_Digit_1             .hbu009.
                            
BinaryOut_100               lda HL_Digit_100                ;                                                           .hbu009.
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu009.
                            
BinaryOut_10                lda HL_Digit_10                 ;                                                           .hbu009.
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu009.
                            
BinaryOut_1                 lda HL_Digit_1                  ;                                                           .hbu009.
                            jmp StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen   .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLevelVar         Does    : output game level number to a variable column of the status row
;                           Expects : .A=game level number
;                                   : .X=output column number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLevelVar          .block                           ; 
                            stx HLZ_ScreenCol               ; set screen col  ($00-$1b)                                 .hbu009.
                            
                            ldx #HL_StatusRowNum            ; get status row num                                        .hbu009.
                            stx HLZ_ScreenRow               ; set screen row  ($00-$0f)                                 .hbu009.
                            
                            jmp StatusOutDigitBin           ; output a binary digit to status row                       .hbu009.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLevel            Does    : write out the level number to status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLevel             .block                           ; 
                            lda HL_LevelNumGame             ; get game level number (001-250)
                            ldx #HLZ_ScreenCol_Status_Level ; get output column
                            
                            bne StatusOutLives.StatusRowOut ; always write out number of lives
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutScore            Does    : update the games status row with the actual score
;                           Expects : .A=score add value LO
;                                   : .Y=score add value HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutScore             .block                           ; 
                            ldx HL_LevelTest                ; get flag: level testmode on/off                           .hbu019.
                            beq ShowScores                  ; check: HL_LevelTest_Off - yes: normal output of scores    .hbu019.
                            
                            rts                             ; no scores in level test mode                              .hbu019.
; --------------------------------------------------------------------------------------------------------------------- ;
ShowScores                  clc                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; decimal addition of the new score
; --------------------------------------------------------------------------------------------------------------------- ;
                            sed                             ; 
                            adc HL_Score_Lo                 ; .A has 10th
                            sta HL_Score_Lo                 ; set score 
                            
                            tya                             ; .Y has 100th
                            adc HL_Score_Mid_Lo             ; 
                            sta HL_Score_Mid_Lo             ; set score
                            
                            lda #$00                        ; add carry
                            adc HL_Score_Mid_Hi             ; 
                            sta HL_Score_Mid_Hi             ; set score
                            
                            lda #$00                        ; add carry
                            adc HL_Score_Hi                 ; 
                            sta HL_Score_Hi                 ; set score
                            cld                             ; 
                            
                            lda #HLZ_ScreenCol_Status_Score ; get score output column
                            sta HLZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda #HLZ_ScreenRow_Status_Sep   ; get status separator row number
                            sta HLZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda HL_Score_Hi                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda HL_Digit_1                  ; get digit 1 part - use only right nibble discard left nibble
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Score_Mid_Hi             ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Score_Mid_Lo             ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Score_Lo                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                            
                            lda HL_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreSplitDigit           Does    : split a byte compressed decimal into two bytes
;                           Expects : .A=BCD coded digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSplitDigit            .block                           ; 
                            sta HL_Digit_10                 ; set store score byte - digit 10 part
                            
                            and #$0f                        ; isolate right nibble
                            sta HL_Digit_1                  ; set digit 1 part
                            
                            lda HL_Digit_10                 ; get digit 10 part
                            lsr a                           ; isolate left  nibble
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            sta HL_Digit_10                 ; set digit 10 part
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ConvertHexToDec           Does    : set up a three char decimal value from a hex digit
;                           Expects : .A=hex value
;                           Returns : result in HL_Digit_100/HL_Digit_10/HL_Digit_1
; --------------------------------------------------------------------------------------------------------------------- ;
ConvertHexToDec            .block                           ; 
                            ldx #$00                        ; get init value
                            stx HL_Digit_10                 ; ini digit 10 part
                            stx HL_Digit_100                ; ini digit 100 part
                            
Count_100s                  cmp #$64                        ; test 100
                            bcc Count_10s                   ; check: underflow - yes: stop counting 100s
                            
                            inc HL_Digit_100                ; count digit 100 part
                            
                            sbc #$64                        ; sub 100
                            bne Count_100s                  ; always
                            
Count_10s                   cmp #$0a                        ; test 10
                            bcc Count_1s                    ; check: underflow - yes: stop counting 10s
                            
                            inc HL_Digit_10                 ; count digit 10 part
                            
                            sbc #$0a                        ; sub 10
                            bne Count_10s                   ; always
                            
Count_1s                    sta HL_Digit_1                  ; set remaining digit 1 count
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutDigitHandler     Does    : output a digit to the status row of the selected gfx screen
;                           Expects : .A=decimal value
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutDigitHandler      .block                           ; 
                            clc                             ; 
                            adc #NumDigit_0                 ; make it a digit image                                     .hbu000.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DigitCharOutHandler       Does    : control output of a single digit char
;                           Expects : .A=prepared digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DigitCharOutHandler        .block                           ; 
                            ldx HLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>HL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq OutToScreenPrepare          ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
OutToScreenPrepare          jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharPrepare           Does    : prepare a text char for output
;                                   : the loderunner char values are slightly higher than the PETSCII ones
;                           Expects : .A=char vlaue to correct
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharPrepare            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check range A-Z
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #"a" | $80                  ; test <SHIFT> + A
                            bcc ChkCharSubstitution         ; check: LT - yes: not in range <SHIFT> A-Z ($c1-$dc)
                            
                            cmp #"z" | $80 + $01            ; test <SHIFT + Z + 1
                            bcc SubCorrectionValue          ; check: LT - yes: char in range <SHIFT> A-Z ($c1-$dc)
; --------------------------------------------------------------------------------------------------------------------- ;
; substitute the defined non A-Z chars
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCharSubstitution         ldx #$80 - (NumChar_A - "a")    ; get dislocation value of LR "A" and PETSCII "A"
                            
                            cmp #" " | $80                  ; test <SHIFT_SPACE>
                            beq SetSubstitutionValue        ; check: EQ - yes: directly substitute from .X
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the loderunner special chars directly following 'Z'
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"z" | $80 + $01            ; get substitution start value
                            
                            cmp #">" | $80                  ; test <SHIFT> + ">"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"." | $80                  ; test <SHIFT> + "."
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"(" | $80                  ; test <SHIFT> + "("
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #")" | $80                  ; test <SHIFT> + ")"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"/" | $80                  ; test <SHIFT> + "/"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"-" | $80                  ; test <SHIFT> + "-"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"<" | $80                  ; test <SHIFT> + "<"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value                                    .hbu011.
                            cmp #":" | $80                  ; test <SHIFT> + ":"                                        .hbu011.
                            beq SetSubstitutionValue        ; check: EQ - yes: map to NumSpecial_Colon                  .hbu011.
                            
                            inx                             ; inc substitution value                                    .hbu020.
                            cmp #"!" | $80                  ; test <SHIFT> + "!" - new special character                .hbu020.
                            beq SetSubstitutionValue        ; check: EQ - yes: map to NumSpecial_Colon                  .hbu020.
; --------------------------------------------------------------------------------------------------------------------- ;
; check character numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #NumCharDigit_Min           ; test char "0"                                             .hbu011.
                            bcc GetDefault                  ; check: LT - yes: replace it                               .hbu011.
                                                                                                                        
                            cmp #NumCharDigit_Max + $1      ; test char "9" + 1                                         .hbu011.
                            bcc TextCharPrepareX            ; check: LT - yes: bypass substitution                      .hbu011.
; --------------------------------------------------------------------------------------------------------------------- ;
; replace all undefined characters with a blank - the old value of $10 is wrong (TabSpriteData_LodeRu_RuRi01)
; --------------------------------------------------------------------------------------------------------------------- ;
;GetDefault                 lda #$10                        ; substitute all others                                     .hbu011.
GetDefault                  lda #$00                        ; substitute all others                                     .hbu011.
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSubstitutionValue        txa                             ; set selected substitution value
                            
SubCorrectionValue          sec                             ; 
                            sbc #$80 - (NumChar_A - "a")    ; sub dislocation value of LR "A" and PETSCII "A"
                            
TextCharPrepareX            rts                             ;                                                           .hbu011.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutCharHandler        Does    : control the output of a single char
;                           Expects : .A=output char
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutCharHandler         .block                           ; 
                            cmp #$8d                        ; test <NEWLINE>
                            beq TextCharOutNewLine          ; check: EQ - yes
                            
                            jsr TextCharPrepare             ; prepare and substitute char for output
                            
                            ldx HLZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>HL_ScreenGfxPrepare       ; test gfx prepare screen
                            beq CharOutToScreenPrep         ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CharOutToScreenPrep         jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc HLZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharOutNewLine        Does    : set text cursor to start of a new line
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharOutNewLine         .block                           ; 
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #HLZ_ScreenCol_Min          ; get initial value
                            sta HLZ_ScreenCol               ; ini screen col ($00-$1b)
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutHandler            Does    : control the output of a $00 terminated text string
;                           Expects : 
;                           Returns : 
;                           Remark  : returns to the statement directly behind the EoT marker $00
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutHandler             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start with the text directly following the subroutine call
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; pull the text start address LO from stack
                            sta HLZ_InputTextOutPtr_Lo      ; set input text pointer LO
                            
                            pla                             ; pull the text start address HI from stack
                            sta HLZ_InputTextOutPtr_Hi      ; set input text pointer HI
                            bne IncTextPointer              ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output the text bytes until EoT
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextTextByte             ldy #$00                        ; get offset
                            lda (HLZ_InputTextOutPtr),y     ; get text byte
                            beq PrepareReturn               ; check: EoT - yes: end of text
                            
                            jsr TextOutCharHandler          ; control the output of a single char
                            
IncTextPointer              inc HLZ_InputTextOutPtr_Lo      ; inc input text pointer LO
                            bne GetNextTextByte             ; check: overflow - no 
                            inc HLZ_InputTextOutPtr_Hi      ; inc input text pointer HI
                            bne GetNextTextByte             ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push actual text pointer as new return address to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
PrepareReturn               lda HLZ_InputTextOutPtr_Hi      ; get input text end pointer HI
                            pha                             ; push the text end address HI to the stack
                            
                            lda HLZ_InputTextOutPtr_Lo      ; get input text end pointer LO
                            pha                             ; push the text end address LO to the stack
                            
                            rts                             ; return behind the input text EoT marker
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EditorErrorBeep           Does    : all editors output of an error beep signal
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EditorErrorBeep            .block                           ; 
                            sei                             ; disable interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$60                        ; get beep
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set beep output timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$38                        ; get wait time HI
                            ldx #$00                        ; get wait time LO
DecNextBeepTime             dex                             ; dec wait time LO
                            bne DecNextBeepTime             ; check: min - no: continue
                            
                            dey                             ; dec wait time HI
                            bne DecNextBeepTime             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            cli                             ; ensable interrupts
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CursorBlink           Does    : board editor: blink the input cursor while waiting for player input
;                           Expects : .A=character to blink
;                           Returns : .A=player input key
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CursorBlink            .block                           ; 
                            sta HL_DisplayChr               ; save char under cursor
                            
GetNextWaitTimeInitValue    lda #$00                        ; get intitial value
                            sta HL_WaitTime_Lo              ; set wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta HL_WaitTime_Hi              ; set wait timer HI
                            
                            lda #HL_TileNum_Empty           ; preset clear blank
                            
                            ldx HL_DisplayChr               ; restore char under cursor
                            bne CharImageOutToScreen        ; check: char - yes: bypass substitution
                            
                            lda #NumCursor_Blank_Reverse    ; get char substitution reversed blank                      .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 01 - display blank
; --------------------------------------------------------------------------------------------------------------------- ;
CharImageOutToScreen        jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
ChkNextPlayerAction_Blank   jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec HL_WaitTime_Lo              ; dec wait time LO
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
                            
                            dec HL_WaitTime_Hi              ; dec wait time HI
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 02 - display char under cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DisplayChr               ; get byte under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #$00                        ; get initial value
                            sta HL_WaitTime_Lo              ; ini wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta HL_WaitTime_Hi              ; ini wait timer HI
                            
ChkNextPlayerAction         jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec HL_WaitTime_Lo              ; dec timer LO
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            dec HL_WaitTime_Hi              ; dec timer HI
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            jmp GetNextWaitTimeInitValue    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SavePlayerInput             pha                             ; save player input key
; --------------------------------------------------------------------------------------------------------------------- ;
; redisplay character under cursor in case of a player input in the blank blink phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_DisplayChr               ; get redisplay chr under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            pla                             ; restore player input key
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerCheckInput          Does    : look for player input
;                           Expects : 
;                           Returns : .C=0 - flag no player action
;                                   : .C=1 - flag player action
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerCheckInput           .block                           ; 
                            lda #HL_PlayerInputType_Keyboard; get keyboard                                              .hbu027.
                            sta HL_PlayerInputType          ; preset input was from keyboard                            .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_KeyNew                   ; get actual key                                            .hbu027.
                            bne SetFlagPlayerReacted        ; check: new key - yes                                      .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick moves
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_MOVE            ; isolate joystick move bits: bit3=right  bit2=left  bit1=down  bit0=up
                            eor #CIAPRA_JOY_MOVE            ; reverse move bits - now 1=pressed
;                           bne SetFlagPlayerReacted        ; check: pressed move - yes                                 .hbu027. removed
                            bne SetPlayerInputJoystick      ; user joystick moves                                       .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick fire
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            eor #CIAPRA_JOY_FIRE            ; reverse fire button                                       .hbu027.
;                           beq SetFlagPlayerReacted        ; check: pressed fire - yes                                 .hbu027. removed
                            bne SetPlayerInputJoystick      ; check: fire button pressed - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda HL_KeyNew                   ; get actual key                                            .hbu027. removed
;                           bne SetFlagPlayerReacted        ; check: new key - yes                                      .hbu027. removed
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; flag no player action
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerInputJoystick      dec HL_PlayerInputType          ; set joystick user interaction                             .hbu027.
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerReacted        sec                             ; flag player action
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToDisplay   Does    : set screen display as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToDisplay    .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in edit mode - select a different loderunner tile then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test Loderunner image                                     .hbu033.
                            bne SetImageNumberDisp          ; check: EQ - no: bypass editor mode test                   .hbu033.
                            
                            ldx HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu033.
                            cpx #HL_GameMode_Edit           ; test edit mode                                            .hbu033.
                            bne SetImageNumberDisp          ; check: edit - no: set the standard loderunner tile        .hbu033.

                            lda #HL_TileNum_LodeRunner_Edit ; get the white loderunner tile for edit                    .hbu033.
                            
SetImageNumberDisp          sta HLZ_ImageNumber             ; set level input tile ($00-$09)
                            
                            lda #>HL_ScreenGfxDisplay       ; get adr gfx display screen HI
                            bne ScreenImageOut              ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToPrepare   Does    : set screen prepare as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToPrepare    .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in edit mode - select a different loderunner tile then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #HL_TileNum_LodeRunner      ; test Loderunner image                                     .hbu033.
                            bne SetImageNumberPrep          ; check: EQ - no: bypass editor mode test                   .hbu033.
                            
                            ldx HL_GameMode                 ; get game mode - $00=start $01=demo $02=play $05=edit      .hbu033.
                            cpx #HL_GameMode_Edit           ; test edit mode                                            .hbu033.
                            bne SetImageNumberPrep          ; check: edit - no: set the standard loderunner tile        .hbu033.

                            lda #HL_TileNum_LodeRunner_Edit ; get the white loderunner tile for edit                    .hbu033.
                            
SetImageNumberPrep          sta HLZ_ImageNumber             ; set level input tile ($00-$09)
                            
                            lda #>HL_ScreenGfxPrepare       ; get adr gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOut            Does    : output an image byte to its correct grafic screen location
;                           Expects : .A=target output screen address HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOut             .block                           ; 
                            sta HLZ_ImageOutputScreen       ; set target output  $20=$2000 $40=$4000
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx HLZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            sty HLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            stx HLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            lda TabGfxImageClearLeft,x      ; get insert image left tab  (4 different image positions)
                            sta HLZ_GfxImageClearLeft       ; set isolate right grafic part
                            
                            lda TabGfxImageClearRight,x     ; get insert image right tab (4 different image positions)
                            sta HLZ_GfxImageClearRight      ; set isolate left grafic part
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to HLZ_ImageBuffer
                            
                            lda #HL_ImageHeight             ; get height of each image
                            sta HLZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini offset to image buffer byte
                            
                            lda HLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs InsNextImageGfxByteLong     ; check: GE - yes: never true as HLZ_ScreenGfxPartPosY is $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
; insert image byte to its grafic screen location
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByte         ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (HLZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and HLZ_GfxImageClearLeft       ; clear the left gfx part
                            ora HLZ_ImageBufferRowPos_01,x  ; insert new image byte from pos_01
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda (HLZ_ScreenGfxDisplayPtr),y ; get grafic screen image byte
                            and HLZ_GfxImageClearRight      ; clear the right grafic part
                            ora HLZ_ImageBufferRowPos_01,x  ; insert image buffer byte part 01
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set write grafic screen image byte
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - always empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte of image buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec HLZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByte         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as HLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByteLong     ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (HLZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and HLZ_GfxImageClearLeft       ; clear the left gfx part
                            ora HLZ_ImageBuffer,x           ; insert new image byte from pos_01
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - middle part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda HLZ_ImageBuffer,x           ; get image buffer byte
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set middle part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $03 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc offset to offset image byte pos_03
                            
                            ldy #$10                        ; get offset image right part
                            lda (HLZ_ScreenGfxDisplayPtr),y ; get right part of gfx image
                            and HLZ_GfxImageClearRight      ; clear the right image part
                            ora HLZ_ImageBuffer,x           ; insert new image byte from pos_03
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set right part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec HLZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByteLong     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearLeft        = *       ; 
                            .byte $00 ; ........
                            .byte $c0 ; ##......
                            .byte $f0 ; ####....
                            .byte $fc ; ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearRight       = *       ; 
                            .byte $3f ; ..######
                            .byte $0f ; ....####
                            .byte $03 ; ......##
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageUpdate         Does    : process steps for shoot and close holes
;                                   : clear collected gold
;                           Expects : .A=image number
;                                   : .Y=image screen offset PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageUpdate          .block                           ; 
                            sty HLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta HLZ_ImageNumber             ; set level input tile ($00-$09)
                            
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta HLZ_WorkSpritePosX          ; 
                            stx HLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to HLZ_ImageBuffer
                            
                            ldx #HL_ImageHeight             ; get image height
                            stx HLZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini image buffer offset
                            
;                           lda HLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)       .hbu001. removed
;                           cmp #$05                        ; test row positions needs an additional offset of $08            .hbu001. removed
;                           bcs UpdNextImageGfxByteLong     ; check: GE - yes: never true as HLZ_ScreenGfxPartPosY is $00-$03 .hbu001. removed
                            
GetNextGfxRowOffset         ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda HLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (HLZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (HLZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image right part
                            lda HLZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (HLZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (HLZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec HLZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as HLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
;UpdNextImageGfxByteLong    ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset                           .hbu001. removed
;                           jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens        .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           ldy #$00                        ; get offset image left part                                .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           eor #$ff                        ; flip all bits                                             .hbu001. removed
;                           and (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           ora (HLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer byte                           .hbu001. removed
;                           
;                           ldy #$08                        ; get offset image middle part                              .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           eor #$ff                        ; flip all bits                                             .hbu001. removed
;                           and (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           ora (HLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer byte                           .hbu001. removed
;                           
;                           ldy #$10                        ; get offset image right part                               .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           eor #$ff                        ; flip all bits                                             .hbu001. removed
;                           and (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           ora (HLZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer triplet                        .hbu001. removed
;                           
;                           inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset                           .hbu001. removed
;                           
;                           dec HLZ_ImageHeight             ; dec image height                                          .hbu001. removed
;                           bne UpdNextImageGfxByteLong     ; check: min - no: continue                                 .hbu001. removed
;                           
;                           rts                             ;                                                           .hbu001. removed
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutSpecial     Does    : show loderunner and enemy sprites
;                                   : show images for hidden ladders/shoot sparks/gold/enemy rebirth steps
;                           Expects : .A=image number
;                                   ; .Y=grafic screen column pos on row
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutSpecial      .block                           ; 
                            sty HLZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta HLZ_ImageNumber             ; set level input tile ($00-$09)
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta HLZ_WorkSpritePosX          ; 
                            stx HLZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of 4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to HLZ_ImageBuffer
                            
                            lda #HL_ImageHeight             ; get image height
                            sta HLZ_ImageHeight             ; ini image height
                            
                            ldx #$00                        ; get initial value
                            stx HLZ_LodeRuEnemyCollision    ; ini loderunner-enemy sprite collision  $01=lr caught
                            
;                           lda HLZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)       .hbu001. removed
;                           cmp #$05                        ; test row positions needs an additional offset of $08            .hbu001. removed
;                           bcs InsNextImageGfxByteLongSprt ; check: GE - yes: never true as HLZ_ScreenGfxPartPosY is $00-$03 .hbu001. removed
                            
GetNextGfxRowOffset         ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda HLZ_ImageBuffer,x           ; get image byte
                            ora (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda HLZ_ImageBuffer,x           ; get image byte
                            ora (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec HLZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as HLZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
;InsNextImageGfxByteLongSprt ldy HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset                          .hbu001. removed
;                           jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens        .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           ldy #$00                        ; get offset image left part                                .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           ora (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer byte                           .hbu001. removed
;                           
;                           ldy #$08                        ; get offset image middle part                              .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           ora (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer byte                           .hbu001. removed
;                           
;                           ldy #$10                        ; get offset image right part                               .hbu001. removed
;                           lda HLZ_ImageBuffer,x           ; get image byte                                            .hbu001. removed
;                           ora (HLZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte                                .hbu001. removed
;                           sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte                            .hbu001. removed
; --------------------------------------------------------------------------------------------------------------------- ;
;                           inx                             ; point to next image buffer triplet                        .hbu001. removed
;                           
;                           inc HLZ_ScreenGfxRowPosY        ; inc gfx screen image row offset                           .hbu001. removed
;                           
;                           dec HLZ_ImageHeight             ; dec image height                                          .hbu001. removed
;                           bne InsNextImageGfxByteLongSprt ; check: min - no: continue                                 .hbu001. removed
;                           
;                           rts                             ;                                                           .hbu001. removed
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageGetBytes       Does    : get the appropriate image byte from tabled data
;                           Expects : .X=values $00-$03 for the 4 different image types
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageGetBytes        .block                           ; 
                            stx HL_ImageColType             ; save image column type - 4 differerent positions          .hbu000.
; --------------------------------------------------------------------------------------------------------------------- .hbu008
; set image data pointer                                                                                                .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx HLZ_WorkImageNumber         ; get image number                                          .hbu000.
                            lda HL_ImageAdr_Lo,x            ;                                                           .hbu000.
                            sta HLZ_ImageDataOffPtr_Lo      ;                                                           .hbu000.
                            lda HL_ImageAdr_Hi,x            ;                                                           .hbu000.
                            sta HLZ_ImageDataOffPtr_Hi      ;                                                           .hbu000.
                            
                            ldy #ImageData_Len - 1          ; get image data offset                                     .hbu000.
GetNextImageBytes           lda (HLZ_ImageDataOffPtr),y     ; get the 3 bytes making an image row                       .hbu000.
                            sta HLZ_ImageBuffer,y           ;                                                           .hbu000.
                            dey                             ; dec image data lenght                                     .hbu000.
                            
                            lda (HLZ_ImageDataOffPtr),y     ;                                                           .hbu000.
                            sta HLZ_ImageBuffer,y           ;                                                           .hbu000.
                            dey                             ; dec image data offset                                     .hbu000.
                            
                            lda (HLZ_ImageDataOffPtr),y     ; always zero so far - but neccessary                       .hbu000.
                            sta HLZ_ImageBuffer,y           ;                                                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; care for the four possible output positions                                                                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get actual image offset                                   .hbu000.
                            tax                             ; set as shift offset                                       .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; check image pos $00                                                                                                   .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_ImageColType             ; get image column position                                 .hbu000.
                            beq SetNewImageRow              ; check: pos $00 - omit the bit shift                       .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; check image pos $01-$03                                                                                               .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$01                        ;                                                           .hbu000.
                            beq ShiftImageRow2              ; check: pos $01 - 2bit shift                               .hbu000.
                            cmp #$02                        ;                                                           .hbu000.
                            beq ShiftImageRow4              ; check: pos $02 - 4bit shift                               .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; shift image bits for one of the three missing hires output positions                                                  .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
ShiftImageRow6              lsr HLZ_ImageBuffer,x           ; was    pos $03 - 6bit shift                               .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            dex                             ;                                                           .hbu000.
                            lsr HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            dex                             ;                                                           .hbu000.
                            
ShiftImageRow4              lsr HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            dex                             ;                                                           .hbu000.
                            lsr HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            dex                             ;                                                           .hbu000.
                            
ShiftImageRow2              lsr HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            dex                             ;                                                           .hbu000.
                            lsr HLZ_ImageBuffer,x           ;                                                           .hbu000.
                            inx                             ;                                                           .hbu000.
                            ror HLZ_ImageBuffer,x           ;                                                           .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
; set next image row                                                                                                    .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
SetNewImageRow              dey                             ; dec image data length                                     .hbu000.
                            bpl GetNextImageBytes           ; check: min - no: continue with next image data row triplet.hbu000.
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
;TabImageDataAdr_Hi         = *                               ; hi address of the 4 different image position types
;                           .byte >TabImageDataPos_01_Part_01 ; $00 - from $A000                                        .hbu000. removed
;                           .byte >TabImageDataPos_02_Part_01 ; $01 - from $A200                                        .hbu000. removed
;                           .byte >TabImageDataPos_03_Part_01 ; $02 - from $A400                                        .hbu000. removed
;                           .byte >TabImageDataPos_04_Part_01 ; $03 - from $A600                                        .hbu000. removed
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDisplayHandler      Does    : eventually display sprites and get loderunner sprite/sprite collision value
;                           Expects : .X=screen image column offset
;                           Returns : 
;                           Remark  : does not return to caller if a sprite was set up
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandler       .block                           ; 
                            lda HL_SpriteShow               ; get control sprite show - $05=no sprite display in edit mode
                            bne SpriteDisplayHandlerX       ; check: HL_SpriteShow_Off - yes: no sprite display - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the images sprite number replacement value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_ImageNumber             ; get image number
                            cmp #NumImageCloseHole_00 + $02 ; test max image number                                     .hbu000.
                            bcs SpriteDisplayHandlerX       ; check: GE - yes: no display - exit
                            
                            tay                             ; set image number as offset
                            lda TabImageToSpriteNumValue,y  ; get image is sprite flag
                            bmi SpriteDisplayHandlerX       ; check: flag no sprite - yes: no display - exit
                            beq SetSpriteColOff             ; check: flag loderunner - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return to caller from here
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta HLZ_ImageNumber             ; set enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteColOff             stx HLZ_WorkSpritePosX          ; save grafic row column offset from ScreenGetGfxPosXY
                            jsr SpriteDataBufferFill        ; fill the appropriate sprite buffer with sprite image data
; --------------------------------------------------------------------------------------------------------------------- ;
; .X=VIC sprite SPnX register offset
; --------------------------------------------------------------------------------------------------------------------- ;
; calc sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HLZ_WorkSpritePosX          ; restore grafic PosX from ScreenGetGfxPosXY
                            clc                             ; 
                            adc #VICSCN_MINX_40 / $02       ; add half of screen border width
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta SP0X,x                      ; set VIC($D000) Sprite 0 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            bcc SpriteClearMSB              ; check: MSB PosX to be set - no: clear PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprite_MSB_Set,x         ; get sprite set x pos msb tab
                            ora MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            
                            jmp SetSpritePosY               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteClearMSB              lda TabSprite_MSB_Clear,x       ; get sprite clear x pos msb tab
                            and MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpritePosY               lda HLZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            clc                             ; 
                            adc #VICSCN_MINY_25 - $01       ; add screen border width
                            sta SP0Y,x                      ; VIC($D001) Sprite 0 Y-Pos (Bits 0-7)
; --------------------------------------------------------------------------------------------------------------------- ;
; get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPSPCL                      ; VIC($D01E) Sprite-Sprite Collision - Cleared on read
                            and #SPSPCL_M0M                 ; .......# - isolate bit 0
                            sta HLZ_LodeRuEnemyCollision    ; set loderunner-enemy sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; do not return to caller
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; discard the return address
                            pla                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit point for no sprite display
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandlerX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprite_MSB_Set           = * + $00 ; 
TabSprite_MSB_Clear         = * + $01 ; 
                            .byte %00000001 ; set   - sprite x pos msb tab
                            .byte %11111110 ; clear - sprite x pos msb tab
                            
                            .byte %00000010 ; set   - sprite x pos msb tab
                            .byte %11111101 ; clear - sprite x pos msb tab
                                  
                            .byte %00000100 ; set   - sprite x pos msb tab
                            .byte %11111011 ; clear - sprite x pos msb tab
                                  
                            .byte %00001000 ; set   - sprite x pos msb tab
                            .byte %11110111 ; clear - sprite x pos msb tab
                                  
                            .byte %00010000 ; set   - sprite x pos msb tab
                            .byte %11101111 ; clear - sprite x pos msb tab
                                  
                            .byte %00100000 ; set   - sprite x pos msb tab
                            .byte %11011111 ; clear - sprite x pos msb tab
                                  
                            .byte %01000000 ; set   - sprite x pos msb tab
                            .byte %10111111 ; clear - sprite x pos msb tab
                                  
                            .byte %10000000 ; set   - sprite x pos msb tab
                            .byte %01111111 ; clear - sprite x pos msb tab
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageToSpriteNumValue    = *       ; 
                            .byte $ff ; $00 - Level Tile Blank         - no sprite
                            .byte $ff ; $01 - Level Tile Wall Weak     - no sprite
                            .byte $ff ; $02 - Level Tile Wall Hard     - no sprite
                            .byte $ff ; $03 - Level Tile Ladder        - no sprite
                            .byte $ff ; $04 - Level Tile Pole          - no sprite
                            .byte $ff ; $05 - Level Tile Wall Trap     - no sprite
                            .byte $ff ; $06 - Level Tile Ladder Secret - no sprite
                            .byte $ff ; $07 - Level Tile Gold          - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $0b ; $08 - Level Tile Enemy      - Run Le  00
                            .byte $00 ; $09 - Level Tile Loderunner - Run Ri  00
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $0a - Blank Reverse             - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $0b - Loderunner Run  Le 00    
                            .byte $00 ; $0c - Loderunner Run  Le 01    
                            .byte $00 ; $0d - Loderunner Run  Le 02    
                            .byte $00 ; $0e - Loderunner Ladder  00    
                            .byte $00 ; $0f - Loderunner Fire Le    
                            .byte $00 ; $10 - Loderunner Run  Ri 01
                            .byte $00 ; $11 - Loderunner Run  Ri 02
                            .byte $00 ; $12 - Loderunner Ladder  01
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $1b - Shoot Spark Le    00 - no sprite
                            .byte $ff ; $1c - Shoot Spark Le    01 - no sprite
                            .byte $ff ; $1d - Shoot Spark Le/Ri 02 - no sprite
                            .byte $ff ; $1e - Shoot Spark Le/Ri 03 - no sprite
                            .byte $ff ; $1f - Shoot Melt Ground 00 - no sprite
                            .byte $ff ; $20 - Shoot Melt Ground 01 - no sprite
                            .byte $ff ; $21 - Shoot Melt Ground 02 - no sprite
                            .byte $ff ; $22 - Shoot Melt Ground 03 - no sprite
                            .byte $ff ; $23 - Shoot Melt Ground 04 - no sprite
                            .byte $ff ; $24 - Shoot Melt Ground 05 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $25 - Loderunner Fire Ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $26 - Shoot Spark Ri    00 - no sprite lr fire Ri
                            .byte $ff ; $27 - Shoot Spark Ri    01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $09 ; $28 - Enemy Run  Ri 00
                            .byte $10 ; $29 - Enemy Run  Ri 01
                            .byte $11 ; $2a - Enemy Run  Ri 02
                            .byte $0c ; $2b - Enemy Run  Le 01
                            .byte $0d ; $2c - Enemy Run  Le 02
                            .byte $15 ; $2d - Enemy Pole Ri 00
                            .byte $16 ; $2e - Enemy Pole Ri 01
                            .byte $17 ; $2f - Enemy Pole Ri 02
                            .byte $18 ; $30 - Enemy Pole Le 00
                            .byte $19 ; $31 - Enemy Pole Le 01
                            .byte $1a ; $32 - Enemy Pole Le 02
                            .byte $0e ; $33 - Enemy Ladder  00
                            .byte $12 ; $34 - Enemy Ladder  01
                            .byte $14 ; $35 - Enemy Fall Ri
                            .byte $13 ; $36 - Enemy Fall Le
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $37 - Close Hole Phase  00 - no sprite
                            .byte $ff ; $38 - Close Hole Phase  01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDataBufferFill      Does    : fill the appropriate sprite buffer with sprite image data
;                           Expects : .A=image number
;                           Returns : .X=VIC sprite SPnX register offset for sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDataBufferFill       .block                           ; 
                            pha                             ; save image id
                            
                            lda HLZ_WorkSpritePosX          ; get grafic xr offset from ScreenGetGfxPosXY
                            and #%00000011                  ; isolate bit 0-1 for the 4 different image types
                            tax                             ; set values $00-$03 for the 4 different image types
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to HLZ_ImageBuffer
                            
                            pla                             ; restore image id
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner always has number sprite number $00
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq SetSpriteBufferTabIndex     ; check: loderunner - yes: bypass get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
; get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda HL_EnemyToMoveNum           ; get number of enemy to move - up to $05 enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite number as sprite tables index
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteBufferTabIndex     tax                             ; set as sprite buffer table index
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite data buffer pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteBuffer_Lo,x        ; get sprite data pos LO tab
                            sta smSpriteDataBuffer_Lo       ; set modify store address LO
                            
                            lda TabSpriteBuffer_Hi,x        ; get sprite data pos HI tab
                            sta smSpriteDataBuffer_Hi       ; set modify store address HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteNumber,x           ; get sprite number
                            tax                             ; save sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; copy sprite data to its data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HL_ImageHeight * $03 - $01 ; get $03 bytes per row image height times
GetNextSpiteDataBufferByte  lda HLZ_ImageBuffer_Long,y      ; get all 33 image bytes from image buffer
smSpriteDataBuffer_Lo       = * + $01                       ; 
smSpriteDataBuffer_Hi       = * + $02                       ; 
SetSpiteDataBufferByte      sta SetSpiteDataBufferByte,y    ; set image byte to correct sprite data storage  ($0c00-$0dff)
                            
                            dey                             ; dec image byte count
                            bpl GetNextSpiteDataBufferByte  ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; calc offset VIC sprite 0-7 PosX registers
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; restore sprite number
                            asl a                           ; *2 - gives VIC sprite SPnX offset
                            tax                             ; set sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Lo           = *                    ; 
                            .byte <HL_SpriteData_00 ; $00
                            .byte <HL_SpriteData_01 ; $40 
                            .byte <HL_SpriteData_02 ; $80 
                            .byte <HL_SpriteData_03 ; $c0 
                            .byte <HL_SpriteData_04 ; $00 
                            .byte <HL_SpriteData_05 ; $40 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Hi          = *                     ; 
                            .byte >HL_SpriteData_00 ; $0c
                            .byte >HL_SpriteData_01 ; $0c
                            .byte >HL_SpriteData_02 ; $0c
                            .byte >HL_SpriteData_03 ; $0c
                            .byte >HL_SpriteData_04 ; $0d
                            .byte >HL_SpriteData_05 ; $0d
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteNumber             = *       ; 
                            .byte $00 ; loderunner
                            
                            .byte $02 ; enemy $01
                            .byte $03 ; enemy $02
                            .byte $04 ; enemy $03
                            
                            .byte $06 ; enemy $04
                            .byte $07 ; enemy $05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenGetGfxPosXY         Does    : get screen image offset in gfx screen
;                           Expects : .X=col number
;                                   : .Y=row number
;                           Returns : .X=screen image row column offset
;                                   : .Y=screen image row offset
;                           Remark  : game screen size is 40*25
;                                   : HL_ImageWidth will be expanded in ScreenRowByteColNumber and SpriteDisplayHandler
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenGetGfxPosXY          .block                           ; 
smGetScreenRowOff_Lo        = * + 1                         ;                                                           .hbu015.
smGetScreenRowOff_Hi        = * + 2                         ;                                                           .hbu015.
                            lda TabScreenRowOff,y           ; get screen image row offset
                            pha                             ; save screen image row offset
                            
                            lda TabScreenColOff,x           ; get screen image row column offset
                            tax                             ; set screen image row column offset
                            
                            pla                             ; restore screen image row offset
                            tay                             ; set screen image row offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenScoresRowOff        = *      ; new high score grouped row positions                                            .hbu015.
TabScreenScoresRowOff_01    .byte HL_ImageHeight * $00       ; $01 - $00                                                .hbu015.
TabScreenScoresRowOff_02    .byte HL_ImageHeight * $01 - $01 ; $02 - $0a                                                .hbu015.
TabScreenScoresRowOff_03    .byte HL_ImageHeight * $02 - $01 ; $03 - $15                                                .hbu015.
TabScreenScoresRowOff_04    .byte HL_ImageHeight * $03 - $01 ; $04 - $20                                                .hbu015.
TabScreenScoresRowOff_05    .byte HL_ImageHeight * $04 - $01 ; $05 - $2b                                                .hbu015.
TabScreenScoresRowOff_06    .byte HL_ImageHeight * $05 - $02 ; $06 - $35                                                .hbu015.
TabScreenScoresRowOff_07    .byte HL_ImageHeight * $06 - $01 ; $07 - $41                                                .hbu015.
TabScreenScoresRowOff_08    .byte HL_ImageHeight * $07 + $00 ; $08 - $4d                                                .hbu015.
TabScreenScoresRowOff_09    .byte HL_ImageHeight * $08 + $04 ; $09 - $5c                                                .hbu015.
TabScreenScoresRowOff_00    .byte HL_ImageHeight * $09 + $04 ; $0a - $67                                                .hbu015.
TabScreenScoresRowOff_11    .byte HL_ImageHeight * $0a + $04 ; $0b - $72                                                .hbu015.
TabScreenScoresRowOff_12    .byte HL_ImageHeight * $0b + $08 ; $0c - $81                                                .hbu015.
TabScreenScoresRowOff_13    .byte HL_ImageHeight * $0c + $08 ; $0d - $8c                                                .hbu015.
TabScreenScoresRowOff_14    .byte HL_ImageHeight * $0d + $08 ; $0e - $97                                                .hbu015.
TabScreenScoresRowOff_15    .byte HL_ImageHeight * $0e + $0c ; $0f - $a6                                                .hbu015.
TabScreenScoresRowOff_16    .byte HL_ImageHeight * $0f + $0c ; $10 - $b1                                                .hbu015.
TabScreenScoresRowOff_17    .byte HL_ImageHeight * $10 + $0c ; $11 - $bc                                                .hbu015.
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenRowOff             = * ; $0b rows per image
TabScreenRowOff_01          .byte HL_ImageHeight * $00        ; $01 - $00
TabScreenRowOff_02          .byte HL_ImageHeight * $01        ; $02 - $0b
TabScreenRowOff_03          .byte HL_ImageHeight * $02        ; $03 - $16
TabScreenRowOff_04          .byte HL_ImageHeight * $03        ; $04 - $21
TabScreenRowOff_05          .byte HL_ImageHeight * $04        ; $05 - $2c
TabScreenRowOff_06          .byte HL_ImageHeight * $05        ; $06 - $37
TabScreenRowOff_07          .byte HL_ImageHeight * $06        ; $07 - $42
TabScreenRowOff_08          .byte HL_ImageHeight * $07        ; $08 - $4d
TabScreenRowOff_09          .byte HL_ImageHeight * $08        ; $09 - $58
TabScreenRowOff_00          .byte HL_ImageHeight * $09        ; $0a - $63
TabScreenRowOff_11          .byte HL_ImageHeight * $0a        ; $0b - $6e
TabScreenRowOff_12          .byte HL_ImageHeight * $0b        ; $0c - $79
TabScreenRowOff_13          .byte HL_ImageHeight * $0c        ; $0d - $84
TabScreenRowOff_14          .byte HL_ImageHeight * $0d        ; $0e - $8f
TabScreenRowOff_15          .byte HL_ImageHeight * $0e        ; $0f - $9a
TabScreenRowOff_16          .byte HL_ImageHeight * $0f        ; $10 - $a5
TabScreenRowOff_17          .byte HL_ImageHeight * $10 + $05  ; $11 - $b5 - status row starts beyond separator line
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenColOff             = * ; $1c columns per row - force column offset to one byte
TabScreenColOff_01          .byte HL_ImageWidth * $02 / $02  ; $01 - $0a - 1st two screen columns unused
TabScreenColOff_02          .byte HL_ImageWidth * $03 / $02  ; $02 - $0f
TabScreenColOff_03          .byte HL_ImageWidth * $04 / $02  ; $03 - $14
TabScreenColOff_04          .byte HL_ImageWidth * $05 / $02  ; $04 - $19
TabScreenColOff_05          .byte HL_ImageWidth * $06 / $02  ; $05 - $1e
TabScreenColOff_06          .byte HL_ImageWidth * $07 / $02  ; $06 - $23
TabScreenColOff_07          .byte HL_ImageWidth * $08 / $02  ; $07 - $28
TabScreenColOff_08          .byte HL_ImageWidth * $09 / $02  ; $08 - $2d
TabScreenColOff_09          .byte HL_ImageWidth * $0a / $02  ; $09 - $32
TabScreenColOff_10          .byte HL_ImageWidth * $0b / $02  ; $0a - $37
TabScreenColOff_11          .byte HL_ImageWidth * $0c / $02  ; $0b - $3c
TabScreenColOff_12          .byte HL_ImageWidth * $0d / $02  ; $0c - $41
TabScreenColOff_13          .byte HL_ImageWidth * $0e / $02  ; $0d - $46
TabScreenColOff_14          .byte HL_ImageWidth * $0f / $02  ; $0e - $4b
TabScreenColOff_15          .byte HL_ImageWidth * $10 / $02  ; $0f - $50
TabScreenColOff_16          .byte HL_ImageWidth * $11 / $02  ; $10 - $55
TabScreenColOff_17          .byte HL_ImageWidth * $12 / $02  ; $11 - $5a
TabScreenColOff_18          .byte HL_ImageWidth * $13 / $02  ; $12 - $5f
TabScreenColOff_19          .byte HL_ImageWidth * $14 / $02  ; $13 - $64
TabScreenColOff_20          .byte HL_ImageWidth * $15 / $02  ; $14 - $69
TabScreenColOff_21          .byte HL_ImageWidth * $16 / $02  ; $15 - $6e
TabScreenColOff_22          .byte HL_ImageWidth * $17 / $02  ; $16 - $73
TabScreenColOff_23          .byte HL_ImageWidth * $18 / $02  ; $17 - $78
TabScreenColOff_24          .byte HL_ImageWidth * $19 / $02  ; $18 - $7d
TabScreenColOff_25          .byte HL_ImageWidth * $1a / $02  ; $19 - $82
TabScreenColOff_26          .byte HL_ImageWidth * $1b / $02  ; $1a - $87
TabScreenColOff_27          .byte HL_ImageWidth * $1c / $02  ; $1b - $8c
TabScreenColOff_28          .byte HL_ImageWidth * $1d / $02  ; $1c - $91 - last two screen columns unused
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosX   Does    : add horizontal gfx screen image offset
;                           Expects : .X=col number
;                                   : .Y=on image posX number
;                           Returns : .X=vertical position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosX    .block                           ; 
                            tya                             ; get on image posX number
                            pha                             ; save on image posX number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; restore on image posX number
                            tay                             ; set on image posX number
                            
                            txa                             ; get image column offset
                            clc                             ; 
                            adc TabOnGfxImagePosX,y         ; add on image offset value
                            tax                             ; set image column offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosX           = *       ; 
                            .byte $fe ; -2
                            .byte $ff ; -1
                            .byte $00 ;  0
                            .byte $01 ; +1
                            .byte $02 ; +2
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosY   Does    : add vertical gfx screen image offset
;                           Expects : .Y=row number
;                                   : .X=on image posY number
;                           Returns : .Y=horizontal position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosY    .block                           ; 
                            txa                             ; get on image posY number
                            pha                             ; save on image posY number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; 
                            tax                             ; restore on image posY number
                            
                            tya                             ; get image row offset
                            clc                             ; 
                            adc TabOnGfxImagePosY,x         ; add on image offset value
                            tay                             ; set horizontal position on image
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosY           = *       ; 
                            .byte $fb ; -4
                            .byte $fd ; -2
                            .byte $00 ;  0 - center
                            .byte $02 ; +2
                            .byte $04 ; +4
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenRowByteColNumber    Does    : calculate hires row column byte number
;                           Expects : .X=screen image col offset
;                           Returns : .A=number of bytes to be bypassed
;                                   : .X=rest of (screen image col offset) MOD 4
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenRowByteColNumber     .block                           ; 
                            lda #$00                        ; get initial value
                            sta HL_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                            
                            txa                             ; get screen image col offset
                            pha                             ; save screen image col offset
                            
                            and #$03                        ; ......## - .X MOD 4
                            tax                             ; set the rest of division by 4
                            
                            pla                             ; restore screen image col offset
                            
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            rol HL_HiresRowColNumAdd_Hi     ; screen start of row column number HI
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta HL_HiresRowColNumAdd_Lo     ; set screen start of row column number LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetLevelDataPtrsToRow Does    : set level data pointers to start of selected row
;                           Expects : .Y=row number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetLevelDataPtrsToRow  .block                           ; 
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta HLZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta HLZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta HLZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta HLZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetRowPointerStart  Does    : set grafic screen pointer to row start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointerStart   .block                           ; 
                            lda #$00                        ; get initial value
                            sta HL_HiresRowColNumAdd_Lo     ; ini screen start of row column number LO
                            sta HL_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetRowPointer       Does    : set grafic screen pointer to the output rows column
;                           Expects : .Y=screen grafic row PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointer        .block                           ; 
                            lda HL_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc HL_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta HLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            lda HL_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc HL_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora HLZ_ImageOutputScreen       ; graphic output  (20=2000-2fff  40=4000-4fff)
                            sta HLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetGfxPtrBoth       Does    : set grafic pointers for display an prepare screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetGfxPtrBoth        .block                           ; 
                            lda HL_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc HL_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta HLZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            sta HLZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            
                            lda HL_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc HL_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora #>HL_ScreenGfxDisplay       ; ..#..... - point to $2000-$3fff  (display screen)
                            sta HLZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            eor #>(HL_ScreenGfxPrepare + HL_ScreenGfxDisplay) ; .##..... - point to $4000-$5fff  (prepare screen)
                            sta HLZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenEditorClear         Does    : clear grafic display screen for editor command input
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenEditorClear          .block                           ; 
                            lda #>HL_ScreenGfxDisplay + ($140 * $07) ; get start hires gfx display screen HI ($2000-$3fff) .hbu020.
                            
                            ldx #SPENA_ALL_OFF              ; get disable all sprites                                   .hbu020.
                            stx SPENA                       ; VIC($D015) Sprite Enable Register                         .hbu020.
                            
                            ldx #>HL_ScreenGfxDisplayEnd + $01 ; get end hires gfx display screen HI                    .hbu020.
                            bne ScreenClearSelected         ; always                                                    .hbu020.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenDisplayClear        Does    : clear grafic display screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenDisplayClear         .block                           ; 
                            lda #>HL_ScreenGfxDisplay       ; get start hires gfx display screen HI ($2000-$3fff)
                            
                            ldx #SPENA_ALL_OFF              ; get disable all sprites
                            stx SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldx #>HL_ScreenGfxDisplayEnd + $01 ; get end hires gfx display screen HI
                            bne ScreenClearSelected         ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenPrepareClear        Does    : clear grafic prepare screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenPrepareClear         .block                           ; 
                            lda #>HL_ScreenGfxPrepare       ; get start hires gfx prepare screen HI ($4000-$5fff)
                            ldx #>HL_ScreenGfxPrepareEnd + $01 ; get end hires gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenClearSelected       Does    : clear selected grafic screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenClearSelected        .block                           ; 
                            sta HLZ_ScreenGfxPtr_Hi         ; set screen grafic HI pointer
                            
                            ldy #$00                        ; get initial value
                            sty HLZ_ScreenGfxPtr_Lo         ; set screen grafic LO pointer
                            
                            tya                             ; get blank
ClrNextGraficScreenByte     sta (HLZ_ScreenGfxPtr),y        ; set screen grafic pointer byte
                            
                            iny                             ; inc byte offset
                            bne ClrNextGraficScreenByte     ; check: min - no: continue
                            
                            inc HLZ_ScreenGfxPtr_Hi         ; set next page
                            
                            cpx HLZ_ScreenGfxPtr_Hi         ; test upper border
                            bne ClrNextGraficScreenByte     ; check: EQ - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelDataRow_Lo          = * ; offset start of game/ctrl level data rows LO
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte <HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameLevelDataRow_Hi      = * ; offset start of game level data rows pointer $0800-$09c3
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte >HL_LevelGameData + ((HL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabCtrlLevelDataRow_Hi      = * ; offset start of ctrl level data rows pointer  $0a00-$0bc3
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $00)       ; $00 - $0a00
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $01)       ; $01 - $0a1c
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $02)       ; $02 - $0a38
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $03)       ; $03 - $0a54
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $04)       ; $04 - $0a70
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $05)       ; $05 - $0a8c
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $06)       ; $06 - $0aa8
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $07)       ; $07 - $0ac4
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $08)       ; $08 - $0ae0
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0b00
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $0b1c
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0b38
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0b54
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0b70
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $0b8c
                            .byte >HL_LevelCtrlData + ((HL_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $0ba8
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelExitLadderShow       Does    : show the hidden exit ladders
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelExitLadderShow        .block                           ; 
GetNextExitLadderCount      ldx HL_ExitLadderCount          ; get count hidden ladders to display                       .hbu030.
                            cpx #$ff                        ; test min or nothing                                       .hbu030.
                            beq SetGoldUnderflow            ; check: min - yes: exit no (more) secret ladders to show   .hbu030.
                            
GetHiddenLadderRow          lda HL_WA_ExitLadderRow,x       ; get row number of hidden ladder                           .hbu030.
                            sta HLZ_ScreenRow               ; set screen row  (00-0f)                                   .hbu030.
                            
                            tay                             ; set row number                                            .hbu030.
                            jsr GameSetLevelDataPtrsToRow   ; set both expanded level data pointers                     .hbu030.
                            
                            lda HL_WA_ExitLadderCol,x       ; get column number of hidden ladder                        .hbu030.
                            sta HLZ_ScreenCol               ; set screen col  ($00-$1b)                                 .hbu030.
; --------------------------------------------------------------------------------------------------------------------- ;
; replace hidden ladder by a normal ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get row as index                                          .hbu030.
                            lda #HL_TileNum_Ladder          ; get hidden ladder tile replacement                        .hbu030.
                            sta (HLZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)                    .hbu030.
                            sta (HLZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)                     .hbu030.
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen                       .hbu030.
                            
                            ldx HLZ_ScreenCol               ; get screen col  ($00-$1b)                                 .hbu030.
                            ldy HLZ_ScreenRow               ; get screen row  ($00-$0f)                                 .hbu030.
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset       .hbu030.
                            
                            lda #HL_TileNum_Ladder          ; get hidden ladder tile replacement                        .hbu030.
                            jsr ScreenImageOutSpecial       ; sprites/hidden ladders/shoot sparks/gold/rebirth steps    .hbu030.
                            
                            dec HL_ExitLadderCount          ; dec hidden ladders count                                  .hbu030.
                            jmp GetNextExitLadderCount      ; check: min - no: continue                                 .hbu030.
; --------------------------------------------------------------------------------------------------------------------- ;
; set HL_GoldToCollect to $ff to avoid to be in MainLoop_CheckLrRow more than once
; --------------------------------------------------------------------------------------------------------------------- ;
SetGoldUnderflow            dec HL_GoldToCollect            ;                                                           .hbu030.
                            
                            rts                             ;                                                           .hbu030.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GetNewKey                 Does    : wait for a input key set in IRQ
;                           Expects : 
;                           Returns : .A=key got
; --------------------------------------------------------------------------------------------------------------------- ;
GetNewKey                  .block                           ; 
WaitForNewKey               lda HL_KeyNew                   ; get a new key
                            beq WaitForNewKey               ; check: new gey got - no: continue waiting
                            
                            ldx #HL_KeyNew_None             ; get initial value
                            stx HL_KeyNew                   ; ini new key input
                            
                            rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSign          Does    : spin game over billboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSign           .block                           ; 
                            lda #HL_SpinSignSpeed_Fast      ; get initial value
                            sta TabWrkGameOverSignSpinSpeed ; set init flip sign spin speed
                            
                            lda #>HL_ScreenGfxDisplay       ; get adr gfx display screen HI
                            sta HLZ_ImageOutputScreen       ; set graphic output  ($20=$2000-$2fff  $40=$4000-$4fff)
                            
GameOverSpinSignNextRound   jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_05    ; 
                            
                            jsr GameOverSpinSignPhase_0a    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_06    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_0a    ; 
                            
                            lda TabWrkGameOverSignSpinSpeed ; get flip sign spin speed
                            cmp #HL_SpinSignSpeed_Slow      ; test slowest
                            bcc GameOverSpinSignNextRound   ; check: lower - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set final phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            
                            clc                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_00  Does    : show game over sign spin phase 0
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_00   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
GameOverSpinSignParmTab     = *                             ; spin sign row data number tabele
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_03  ; $03
                            .byte TabGameOverSignRowNum_04  ; $04
                            .byte TabGameOverSignRowNum_05  ; $05
                            .byte TabGameOverSignRowNum_06  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_08  ; $08
                            .byte TabGameOverSignRowNum_09  ; $09
                            .byte TabGameOverSignRowNum_0a  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
GameOverSpinSignParmTab_Len = * - GameOverSpinSignParmTab   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_01  Does    : show game over sign spin phase 1
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_01   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_03  ; $04
                            .byte TabGameOverSignRowNum_04  ; $05
                            .byte TabGameOverSignRowNum_05  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_09  ; $08
                            .byte TabGameOverSignRowNum_0a  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_02  Does    : show game over sign spin phase 2
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_02   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_03  ; $05
                            .byte TabGameOverSignRowNum_04  ; $06
                            .byte TabGameOverSignRowNum_09  ; $07
                            .byte TabGameOverSignRowNum_0a  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_03  Does    : show game over sign spin phase 3
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_03   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_04  Does    : show game over sign spin phase 4
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_04   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_05  Does    : show game over sign spin phase 5
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_05   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_00  ; $05
                            .byte TabGameOverSignRowNum_01  ; $06
                            .byte TabGameOverSignRowNum_01  ; $07
                            .byte TabGameOverSignRowNum_00  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_06  Does    : show game over sign spin phase 6
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_06   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_0a  ; $03
                            .byte TabGameOverSignRowNum_09  ; $04
                            .byte TabGameOverSignRowNum_08  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_06  ; $07
                            .byte TabGameOverSignRowNum_05  ; $08
                            .byte TabGameOverSignRowNum_04  ; $09
                            .byte TabGameOverSignRowNum_03  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_07  Does    : show game over sign spin phase 7
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_07   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_0a  ; $04
                            .byte TabGameOverSignRowNum_09  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_05  ; $07
                            .byte TabGameOverSignRowNum_04  ; $08
                            .byte TabGameOverSignRowNum_03  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_08  Does    : show game over sign spin phase 8
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_08   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_0a  ; $05
                            .byte TabGameOverSignRowNum_09  ; $06
                            .byte TabGameOverSignRowNum_04  ; $07
                            .byte TabGameOverSignRowNum_03  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_09  Does    : show game over sign spin phase 9
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_09   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_0a  Does    : show game over sign spin phase 10
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_0a   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
;                         Row_00  ................................................................................................ 
;                         Row_01  ....#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.......
;                         Row_02  ..#.......................................................................................#.....
;                         Row_03  ..#...#.#.#.#...#.#.#...#.#.#.#.#...#.#.#.#.......#.#.#.#...#.#...#...#.#.#.#...#.#.#.#...#.....
;                         Row_04  ..#...#.....#...#...#...#.#.#...#...#.#...........#...#.#...#.#...#...#.#.#.#...#.....#...#.....
;                         Row_05  ..#...#.........#...#...#...#...#...#.#...........#...#.#...#.#...#...#.#.......#.....#...#.....
;                         Row_06  ..#...#.........#...#...#...#...#...#.#.#.#.......#...#.#...#.#...#...#.#.#.....#.#.#.#...#.....
;                         Row_07  ..#...#...#.#...#.#.#...#...#...#...#.#.#.#.......#.....#...#.#...#...#.........#.#.#.....#.....
;                         Row_08  ..#...#.....#...#...#...#...#...#...#.............#.....#...#.#.#.#...#.........#.#.#.....#.....
;                         Row_09  ..#...#.....#...#...#...#...#...#...#.............#.....#.....#.#.....#.........#.#...#...#.....
;                         Row_0a  ..#...#.#.#.#...#...#...#...#...#...#.#.#.#.......#.#.#.#.....#.......#.#.#.#...#.....#...#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRow_00   .byte %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000 ; 
TabGameOverDataSignRow_01   .byte %00001010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10000000 ; 
TabGameOverDataSignRow_02   .byte %00100000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00100000 ; 
TabGameOverDataSignRow_03   .byte %00100010, %10101000, %10101000, %10101010, %10001010, %10100000, %00101010, %10001010, %00100010, %10101000, %10101010, %00100000 ; 
TabGameOverDataSignRow_04   .byte %00100010, %00001000, %10001000, %10101000, %10001010, %00000000, %00100010, %10001010, %00100010, %10101000, %10000010, %00100000 ; 
TabGameOverDataSignRow_05   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %00000000, %00100010, %10001010, %00100010, %10000000, %10000010, %00100000 ; 
TabGameOverDataSignRow_06   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %10100000, %00100010, %10001010, %00100010, %10100000, %10101010, %00100000 ; 
TabGameOverDataSignRow_07   .byte %00100010, %00101000, %10101000, %10001000, %10001010, %10100000, %00100000, %10001010, %00100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_08   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10001010, %10100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_09   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10000010, %10000010, %00000000, %10100010, %00100000 ; 
TabGameOverDataSignRow_0a   .byte %00100010, %10101000, %10001000, %10001000, %10001010, %10100000, %00101010, %10000010, %00000010, %10101000, %10100010, %00100000 ; 
TabGameOverDataSignRow_Len  = * - TabGameOverDataSignRow_0a ; length data of each game over spin sign row
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRowAdr   = * ; spin game over sign data address tab
                            .word TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02 ; $8fd1
                            .word TabGameOverDataSignRow_01 - TabGameOverDataSignRow_Len - $02 ; $8fdd
                            .word TabGameOverDataSignRow_02 - TabGameOverDataSignRow_Len - $02 ; $8fe9
                            .word TabGameOverDataSignRow_03 - TabGameOverDataSignRow_Len - $02 ; $8ff5
                            .word TabGameOverDataSignRow_04 - TabGameOverDataSignRow_Len - $02 ; $9001
                            .word TabGameOverDataSignRow_05 - TabGameOverDataSignRow_Len - $02 ; $900d
                            .word TabGameOverDataSignRow_06 - TabGameOverDataSignRow_Len - $02 ; $9019
                            .word TabGameOverDataSignRow_07 - TabGameOverDataSignRow_Len - $02 ; $9025
                            .word TabGameOverDataSignRow_08 - TabGameOverDataSignRow_Len - $02 ; $9031
                            .word TabGameOverDataSignRow_09 - TabGameOverDataSignRow_Len - $02 ; $903d
                            .word TabGameOverDataSignRow_0a - TabGameOverDataSignRow_Len - $02 ; $9049
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverSignRowNum       = * ;                 
TabGameOverSignRowNum_00    = (TabGameOverDataSignRow_00 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_01    = (TabGameOverDataSignRow_01 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_02    = (TabGameOverDataSignRow_02 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_03    = (TabGameOverDataSignRow_03 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_04    = (TabGameOverDataSignRow_04 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_05    = (TabGameOverDataSignRow_05 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_06    = (TabGameOverDataSignRow_06 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_07    = (TabGameOverDataSignRow_07 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_08    = (TabGameOverDataSignRow_08 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_09    = (TabGameOverDataSignRow_09 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_0a    = (TabGameOverDataSignRow_0a - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhases    Does    : display the different game over billboard pahases
;                           Expects : pointer to $0d phase numbers on the stack
;                           Returns : 
;                           Remark  : checks player input to end spinning
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhases     .block                           ; 
                            pla                             ; get start address of data number array LO
                            sta HLZ_SignRowNumberTabPtr_Lo  ; set start address of data number array LO
                            pla                             ; get start address of data number array HI
                            sta HLZ_SignRowNumberTabPtr_Hi  ; set start address of data number array HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init output row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #HLZ_ScreenRow_Spin         ; get grafic screen row offset
                            sty HLZ_ScreenRow               ; ini screen row ($00-$0f)
                            bne SetNextGameOverDataPtr      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSignScreenRow        jsr ScreenSetRowPointerStart    ; set grafic screen pointer to row start
                            
                            ldy #$00                        ; get offset
                            lda (HLZ_SignRowNumberTabPtr),y ; get next sign data number byte
                            asl a                           ; *2 - address length
                            tax                             ; set as table game over data sign row addresses offset
; --------------------------------------------------------------------------------------------------------------------- ;
; each entry is set to TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabGameOverDataSignRowAdr + $00,x ; get flip data address tab LO
                            sta smGetSignDataAdr_Lo         ; set get data address LO
                            
                            lda TabGameOverDataSignRowAdr + $01,x ; get flip data address tab HI
                            sta smGetSignDataAdr_Hi         ; set get data address HI
                            
                            ldy #HLZ_ScreenSpinColOff_Left  ; get grafic screen column offset
                            sty HLZ_ScreenSpinColOff        ; ini gfx screen image column offset
                            
                            ldy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len ; get spin sign row number parm table length
                            sty HLZ_WorkGameOverParmTabOff  ; set game over sign parm row number table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get offset to real address
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSignParmRowTabOff    ldy HLZ_WorkGameOverParmTabOff  ; get next game over sign parm row number table offset
                            inc HLZ_WorkGameOverParmTabOff  ; inc game over sign parm row number table offset
smGetSignDataAdr_Lo         = * + $01                       ; 
smGetSignDataAdr_Hi         = * + $02                       ; 
GetSignDataByte             lda GetSignDataByte,y           ; get sign data byte
                            lsr a                           ; /2
                            ldy HLZ_ScreenSpinColOff        ; get gfx screen image row offset
                            sta (HLZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance output column offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            clc                             ; 
                            adc #$08                        ; point to next screen column position
                            sta HLZ_ScreenSpinColOff        ; set gfx screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy HLZ_WorkGameOverParmTabOff  ; get sign data row length
                            cpy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len * $02 - $02 ; test  max
                            bcc GetNextSignParmRowTabOff    ; check: LT - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextGameOverDataPtr      jsr GameOverSpinSignIncTabPtr   ; inc pointer to game over sign number table
; --------------------------------------------------------------------------------------------------------------------- ;
; inc game over sign screen row and check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc HLZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            ldy HLZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #HLZ_ScreenRow_Spin + GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len + $01 ; test max
                            bcc SetNextSignScreenRow        ; check: LT - no: continue with next row
; --------------------------------------------------------------------------------------------------------------------- ;
; handle spin timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkGameOverSignSpinSpeed ; get flip sign spin speed timer HI value
                            ldy #$ff                        ; ini wait timer LO
DecNextWaitTimerCount       dey                             ; dec wait timer LO
                            bne DecNextWaitTimerCount       ; check: timer LO underrun - no: continue
                            
                            dex                             ; dec wait timer HI
                            bne DecNextWaitTimerCount       ; check: timer HI underrun - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; slow down sign rotation speed a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkGameOverSignSpinSpeed ; flip sign spin speed so wait longer the next time
; --------------------------------------------------------------------------------------------------------------------- ;
; check player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            beq GameOverSpinSignPhasesX     ; check: pressed - yes: exit
                            
                            lda HL_KeyNew                   ; get actual key
                            bne GameOverSpinSignPhasesX     ; check: got a new one - yes: exit
                            
                            lda #$01                        ; get short wait time                                       .hbu001.
                            sta DemoWaitInit.smDemoWaitCounter_Hi ; set short wait time                                 .hbu001.
                            
                            rts                             ; return to next phase
; --------------------------------------------------------------------------------------------------------------------- ;
; player interrupt ends spinnig - do not return to GameOverSpinSignPhase_nn but to DemoWaitInit
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhasesX     pla                             ; pull return address from stack
                            pla                             ; 
                            
                            sec                             ; set flag player interrupt
                            rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGameOverSignSpinSpeed .byte $00                       ; save actual game over sign spinning speed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignIncTabPtr Does    : inc game over sign number table data pointer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignIncTabPtr  .block                           ; 
                            inc HLZ_SignRowNumberTabPtr_Lo  ; 
                            bne GameOverSpinSignIncTabPtrX  ; check: overflow - no
                            inc HLZ_SignRowNumberTabPtr_Hi  ; 
                            
GameOverSpinSignIncTabPtrX  rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RND_LevelNumberTableInit  Does    : initialize a table with all possible level numbers
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RND_LevelNumberTableInit   .block                           ;                                                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; get maximum level numbers available
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HL_LevelNumGame_Max        ; get initial value                                         .hbu021.
                            sta HL_BufRndRemainNumOff       ; set maximum level random number                           .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; init random field with all possible level numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial value                                         .hbu021.
GetNextLevelNumber          tya                             ; get next level number                                     .hbu021.
                            sta HL_BufRndRemainNum,y        ; set next level number                                     .hbu021.
                            
                            iny                             ; inc level number/offset                                   .hbu021.
                            cpy HL_BufRndRemainNumOff       ; test maximum level random number reached                  .hbu021.
                            bne GetNextLevelNumber          ; check: EQ - no: continue                                  .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the remaining table bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; get initial value                                         .hbu021.
ClrNextLevelNumber          sta HL_BufRndRemainNum,y        ; ini next level number                                     .hbu021.
                            
                            iny                             ; inc level number/offset                                   .hbu021.
                            bne ClrNextLevelNumber          ; check: max - no: continue                                 .hbu021.
                           .bend                            ;                                                           .hbu021.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RND_RandomNumberTableInit Does    : create the random level number table
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RND_RandomNumberTableInit  .block                           ;                                                           .hbu021.
                            ldx #$00                        ; ini table offset                                          .hbu021.
GetNextRandomNumber         jsr RND_RandomLevelNumberPick   ; get an available RND number                               .hbu021.
                            sta HL_BufRndLevelNum,x         ; store it                                                  .hbu021.
                            
                            inx                             ; inc table offset                                          .hbu021.
                            bne GetNextRandomNumber         ; check: max - no: continue                                 .hbu021.
                            
                            rts                             ;                                                           .hbu021.
                           .bend                            ;                                                           .hbu021.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RND_RandomLevelNumberPick Does    : get a unique random level number
;                           Expects : 
;                           Returns : .A=random level number
; --------------------------------------------------------------------------------------------------------------------- ;
RND_RandomLevelNumberPick  .block                           ;                                                           .hbu021.
                            lda HL_BufRndRemainNumOff       ; get                                                       .hbu021.
                            beq RND_RandomLevelNumberPickX  ;                                                           .hbu021.
                            
TryNextRandomNum            lda TIMALO                      ; CIA 1 - $DC04 = Timer A (low byte)                        .hbu021.
                            eor TIMAHI                      ; CIA 1 - $DC05 = Timer A (high byte)                       .hbu021.
                            eor TI2ALO                      ; CIA 2 - $DD04 = Timer A (low byte)                        .hbu021.
                            adc TI2AHI                      ; CIA 2 - $DD05 = Timer A (high byte)                       .hbu021.
                            eor TI2BLO                      ; CIA 2 - $DD06 = Timer B (low byte)                        .hbu021.
                            eor TI2BHI                      ; CIA 2 - $DD07 = Timer B (high byte)                       .hbu021.
                            
                            cmp HL_BufRndRemainNumOff       ; test with maximum level random number                     .hbu021.
                            bcs TryNextRandomNum            ; check: GE - yes: not possible - get another               .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; get a still unselected number from the table
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set the generated random number as an offset              .hbu021.
                            lda HL_BufRndRemainNum,y        ; get an available level number                             .hbu021.
                            pha                             ; save the selected random level num                        .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; drop the number found - compress the random number table to ensure unique random numbers
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRandomLevelNum       lda HL_BufRndRemainNum + $01,y  ; move the entire table one position up                     .hbu021.
                            sta HL_BufRndRemainNum,y        ; ensure that the level number isn't reselectable           .hbu021.
                            
                            iny                             ; inc offset                                                .hbu021.
                            cpy HL_BufRndRemainNumOff       ; test with actual maximum level random number              .hbu021.
                            bne GetNextRandomLevelNum       ; check: EQ - no: continue compression                      .hbu021.
; --------------------------------------------------------------------------------------------------------------------- ;
; discount the selected number from max
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec HL_BufRndRemainNumOff       ; discount the number found                                 .hbu021.
                            
GetRandomLevelNumber        pla                             ; restore the generated random level number                 .hbu021.
                            
RND_RandomLevelNumberPickX  rts                             ;                                                           .hbu021.
                           .bend                            ;                                                           .hbu021.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RND_GetNextLevelNumber    Does    : get next random level number from table
;                           Expects : 
;                           Returns : .A=random level number
;                                   : .X=disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
RND_GetNextLevelNumber     .block                           ;                                                           .hbu021.
                            ldx HL_BufRndLevelNumOff        ; get random number table offset                            .hbu021.
                            inx                             ; inc offset                                                .hbu021.
                            cpx #HL_LevelNumDisk_Max        ; test max                                                  .hbu021.
                            bcc GetRandomLvlNum             ; check: LT - yes                                           .hbu021.
                            beq GetRandomLvlNum             ; check: EQ - yes                                           .hbu021.
                            
                            ldx #HL_LevelNumDisk_Min        ; set min level random number table offset                  .hbu021.
                            
GetRandomLvlNum             lda HL_BufRndLevelNum,x         ; get next number from table                                .hbu021.
                            
                            stx HL_BufRndLevelNumOff        ; set new random number table offset                        .hbu021.
                            
                            rts                             ;                                                           .hbu021.
                           .bend                            ;                                                           .hbu021.
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RND_GetPrevLevelNumber    Does    : get previous random level number from table
;                           Expects : 
;                           Returns : .A=random level number
;                                   : .X=disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
RND_GetPrevLevelNumber     .block                           ;                                                           .hbu021.
                            ldx HL_BufRndLevelNumOff        ; get random number table offset                            .hbu021.
                            dex                             ; dec offset                                                .hbu021.
                            cpx #$ff                        ; test min                                                  .hbu021.
                            bne GetRandomLvlNum             ; check: EQ - no                                            .hbu021.
                            
                            ldx #HL_LevelNumDisk_Max        ; set max level random number table offset                  .hbu021.
                            
GetRandomLvlNum             lda HL_BufRndLevelNum,x         ; get previous number from table                            .hbu021.
                            
                            stx HL_BufRndLevelNumOff        ; set new random number table offset                        .hbu021.
                            
                            rts                             ;                                                           .hbu021.
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
Jingles                     .include "..\inc\HL_DATA_Jingle.asm"   ; jingle data                                        .hbu000.
;Images                     .include "..\inc\HL_DATA_Image_Compressed.asm" ; original image data                        .hbu000. removed
Images                      .include "..\inc\HL_DATA_Image.asm"    ; uncompressed image data                            .hbu000.
Demo                        .include "..\inc\HL_DATA_Demo.asm"     ; demo moves and level data                          .hbu000.
; --------------------------------------------------------------------------------------------------------------------- ;
